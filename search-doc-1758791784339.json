{"searchDocs":[{"title":"Couchbase Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/couchbase-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#version-compatibility","content":" Component\tVersion RequirementCouchbase Java Client\t3.6.0+  Couchbase Java Client 3.6.0+ is required and must be included in your project dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#installation","content":" Add the Couchbase Java Client dependency to your project:  GradleMaven implementation(&quot;com.couchbase.client:java-client:3.7.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#basic-setup","content":" Configure the audit store:  var auditStore = new CouchbaseSyncAuditStore(cluster, bucket);   The constructor requires the Couchbase cluster and bucket. Optional configurations can be added via .withXXX() methods.  Register Audit Store Once created, you need to register this audit store with Flamingock. See Registering the community audit store for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Audit Store Configuration‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#audit-store-configuration","content":" The Couchbase audit store uses explicit configuration with no global context fallback.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#constructor-dependencies-mandatory","content":" These dependencies must be provided at audit store creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionCluster\tcluster\tCouchbase cluster connection - required for audit store configuration Bucket\tbucket\tTarget bucket instance - required for storing audit data  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#configuration-example","content":" Here's a comprehensive example showing the configuration:  // Audit store configuration (mandatory via constructor) var auditStore = new CouchbaseSyncAuditStore(cluster, bucket) .withScopeName(&quot;custom-scope&quot;) // Optional configuration .withAutoCreate(true); // Optional configuration // Register with Flamingock Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(targetSystems...) .build();   Audit store configuration resolution:  Cluster: Must be provided via constructorBucket: Must be provided via constructorScope settings: Uses explicit configuration via properties  This architecture ensures explicit audit store configuration with no fallback dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Optional Configuration (.withXXX() methods)‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#optional-configuration-withxxx-methods","content":" These configurations can be customized via .withXXX() methods with no global context fallback:  Configuration\tMethod\tDefault\tDescriptionAuto Create\t.withAutoCreate(enabled)\ttrue\tAuto-create collections and indexes Scope Name\t.withScopeName(name)\t_default\tScope where audit collections will be created Audit Repository Name\t.withAuditRepositoryName(name)\tflamingockAuditLogs\tCollection name for audit entries Lock Repository Name\t.withLockRepositoryName(name)\tflamingockLocks\tCollection name for distributed locks  ‚ö†Ô∏è Warning: Ensure your Couchbase user has permissions to create collections if autoCreate is enabled.  ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"DynamoDB Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/dynamodb-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#version-compatibility","content":" Component\tVersion RequirementAWS SDK DynamoDB Enhanced\t2.25.0+  AWS SDK DynamoDB Enhanced 2.25.0+ is required and must be included in your project dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#installation","content":" Add the AWS SDK DynamoDB Enhanced dependency to your project:  GradleMaven implementation(&quot;software.amazon.awssdk:dynamodb-enhanced:2.28.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#basic-setup","content":" Configure the audit store:  var auditStore = new DynamoSyncAuditStore(dynamoDbClient);   The constructor requires the DynamoDB client. Optional configurations can be added via .withXXX() methods.  Register Audit Store Once created, you need to register this audit store with Flamingock. See Registering the community audit store for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Audit Store Configuration‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#audit-store-configuration","content":" The DynamoDB audit store uses explicit configuration with no global context fallback.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#constructor-dependencies-mandatory","content":" These dependencies must be provided at audit store creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionDynamoDbClient\tdynamoDbClient\tAWS DynamoDB client - required for audit store configuration and data access  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#configuration-example","content":" Here's a comprehensive example showing the configuration:  // Audit store configuration (mandatory via constructor) var auditStore = new DynamoSyncAuditStore(dynamoDbClient) .withReadCapacityUnits(10) // Optional configuration .withWriteCapacityUnits(10); // Optional configuration // Register with Flamingock Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(targetSystems...) .build();   Audit store configuration resolution:  DynamoDbClient: Must be provided via constructorCapacity settings: Uses explicit configuration via properties  This architecture ensures explicit audit store configuration with no fallback dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Optional Configuration (.withXXX() methods)‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#optional-configuration-withxxx-methods","content":" These configurations can be customized via .withXXX() methods with no global context fallback:  Configuration\tMethod\tDefault\tDescriptionRead Capacity Units\t.withReadCapacityUnits(units)\t5\tRead capacity units (PROVISIONED mode only) Write Capacity Units\t.withWriteCapacityUnits(units)\t5\tWrite capacity units (PROVISIONED mode only) Audit Repository Name\t.withAuditRepositoryName(name)\tflamingockAuditLogs\tTable name for audit entries Lock Repository Name\t.withLockRepositoryName(name)\tflamingockLocks\tTable name for distributed locks  ‚ö†Ô∏è Warning: Adjust capacity units based on your workload. Under-provisioning may cause throttling. Consider using ON_DEMAND billing mode for unpredictable workloads.  ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"Audit stores","type":0,"sectionRef":"#","url":"/docs/audit-stores/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"What is the audit store?‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#what-is-the-audit-store","content":" The audit store tracks:  Execution history: Which Changes ran, when, and with what outcomeDistributed locking: Prevents concurrent executions across multiple instancesIssue tracking: Failed or uncertain executions requiring resolution  Unlike target systems (which your code modifies), the audit store is managed automatically by Flamingock and never modified by your Changes.  Conceptual overview: For architectural understanding, see Target systems vs audit store  ","version":"1.0.0","tagName":"h2"},{"title":"Cloud audit store‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#cloud-audit-store","content":" The audit store is automatically provided and managed by Flamingock Cloud. No configuration needed - just focus on your changes while Flamingock handles the audit infrastructure.  ","version":"1.0.0","tagName":"h2"},{"title":"Community audit store‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#community-audit-store","content":" Alternatively, you can configure your own audit store using one of the supported databases:  MongoDB audit storeDynamoDB audit storeCouchbase audit storeSQL audit store(coming next)  ","version":"1.0.0","tagName":"h2"},{"title":"Registering the community audit store‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#registering-the-community-audit-store","content":" Flamingock BuilderSpring Boot Register the audit store with the Flamingock builder: // Generic example - audit store configuration public class App { public static void main(String[] args) { // Create your audit store connection var auditStore = new MongoDBSyncAuditStore(mongoClient, mongoDatabase); // Register with Flamingock Flamingock.builder() .setAuditStore(auditStore) // Set the audit store .addTargetSystems(myTargetSystem) .build() .run(); } }  ","version":"1.0.0","tagName":"h3"},{"title":"MongoDB Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/mongodb-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#version-compatibility","content":" Component\tVersion RequirementMongoDB Java Driver\t4.0.0+  MongoDB 4.0+ is recommended for optimal performance and feature support.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#installation","content":" Add the MongoDB Java sync driver dependency to your project:  GradleMaven implementation(&quot;org.mongodb:mongodb-driver-sync:5.2.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#basic-setup","content":" Configure the audit store:  var auditStore = new MongoDBSyncAuditStore(mongoClient, mongoDatabase);   The constructor requires the MongoDB client and database. Optional configurations can be added via .withXXX() methods.  Register Audit Store Once created, you need to register this audit store with Flamingock. See Registering the community audit store for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Audit Store Configuration‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#audit-store-configuration","content":" The MongoDB audit store uses explicit configuration with no global context fallback.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#constructor-dependencies-mandatory","content":" These dependencies must be provided at audit store creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionMongoClient\tmongoClient\tMongoDB connection client - required for audit store configuration MongoDatabase\tmongoDatabase\tTarget database instance - required for storing audit data  ","version":"1.0.0","tagName":"h3"},{"title":"Optional Configuration (.withXXX() methods)‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#optional-configuration-withxxx-methods","content":" These configurations can be customized via .withXXX() methods with no global context fallback:  Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads Audit Repository Name\t.withAuditRepositoryName(name)\tflamingockAuditLogs\tCollection name for audit entries Lock Repository Name\t.withLockRepositoryName(name)\tflamingockLocks\tCollection name for distributed locks  Important: These default values are optimized for maximum consistency and should ideally be left unchanged. Override them only for testing purposes or exceptional cases.  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#configuration-example","content":" Here's a comprehensive example showing the configuration:  // Audit store configuration (mandatory via constructor) var auditStore = new MongoDBSyncAuditStore(mongoClient, auditDatabase) .withWriteConcern(WriteConcern.W1) // Optional configuration .withReadPreference(ReadPreference.secondary()); // Optional configuration // Register with Flamingock Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(targetSystems...) .build();   Audit store configuration resolution:  MongoClient: Must be provided via constructorMongoDatabase: Must be provided via constructorWriteConcern: Uses explicit configuration instead of defaultReadPreference: Uses explicit configuration instead of default  This architecture ensures explicit audit store configuration with no fallback dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"Change Anatomy & Structure","type":0,"sectionRef":"#","url":"/docs/changes/anatomy-and-structure","content":"","keywords":"","version":"1.0.0"},{"title":"Required properties‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#required-properties","content":" Every Change must define these three properties:  ","version":"1.0.0","tagName":"h2"},{"title":"id - Unique identifier‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#id---unique-identifier","content":" The id must be unique across all Changes in your application.  @Change(id = &quot;add-user-status&quot;, author = &quot;dev-team&quot;) // order extracted from filename   Rules:  Must be unique application-wideUse descriptive names (e.g., add-user-status, not change1)Cannot be modified once deployed    ","version":"1.0.0","tagName":"h3"},{"title":"order - Execution sequence‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#order---execution-sequence","content":" The order determines when the Change executes relative to others.  @Change(id = &quot;create-indexes&quot;, order = &quot;20250923_01&quot;, author = &quot;dev-team&quot;) @Change(id = &quot;migrate-data&quot;, order = &quot;20250923_02&quot;, author = &quot;dev-team&quot;) @Change(id = &quot;cleanup-temp-data&quot;, order = &quot;20250923_03&quot;, author = &quot;dev-team&quot;)   Requirements:  Recommended format: YYYYMMDD_NN (e.g., 20250923_01, 20250923_02)YYYY = year, MM = month, DD = day, NN = sequence number (01-99)Determines execution order across all target systemsCannot be changed once deployed  Order Field Rules The order must be specified in at least one of these places: In the file/class name following the pattern _ORDER_DescriptiveName.[java|yaml]In the annotation (@Change) or YAML structure Both are optional, but at least one is requiredIf order is specified in both locations, they must be identicalFor file/class names - Order Extraction Rule: Must start with underscore _ (first character)Order is everything between the first _ and the last _Examples of order extraction: _20250923_01_CreateUserTable.java ‚Üí order: 20250923_01_001_SimpleChange.java ‚Üí order: 001_2024_12_25_HolidayUpdate.yaml ‚Üí order: 2024_12_25_V1_0_1_DatabaseUpgrade.java ‚Üí order: V1_0_1 Recommended format: YYYYMMDD_NN (year-month-day-sequence) Orders are evaluated in alphanumeric order  For recommendations on order field placement and naming patterns, see Best Practices - Naming Patterns.    ","version":"1.0.0","tagName":"h3"},{"title":"author - Responsibility tracking‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#author---responsibility-tracking","content":" Identifies who is responsible for this change.  @Change(id = &quot;update-schema&quot;, order = &quot;20250923_01&quot;, author = &quot;database-team&quot;) @Change(id = &quot;migrate-users&quot;, order = &quot;20250923_02&quot;, author = &quot;john.doe@company.com&quot;)   Best practices:  Use team names for shared responsibility: database-team, api-teamUse individual emails for personal changes: john.doe@company.comKeep consistent within your organization  ","version":"1.0.0","tagName":"h3"},{"title":"Optional properties‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#optional-properties","content":" ","version":"1.0.0","tagName":"h2"},{"title":"transactional - Transaction behavior‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#transactional---transaction-behavior","content":" Controls whether the change runs within a transaction (default: true).  @Change( id = &quot;create-large-index&quot;, order = &quot;20250923_01&quot;, author = &quot;db-team&quot;, transactional = false // DDL operations may require this )   Important: For non-transactional target systems (S3, Kafka, etc.), this flag has no effect.  tip For detailed information on transaction handling, see Transactions.    ","version":"1.0.0","tagName":"h3"},{"title":"recovery - Failure handling strategy‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#recovery---failure-handling-strategy","content":" Controls how Flamingock handles execution failures (default: MANUAL_INTERVENTION).  // Default behavior (manual intervention) @Change(id = &quot;critical-change&quot;, order = &quot;20250923_01&quot;, author = &quot;team&quot;) public class CriticalChange { // Execution stops on failure, requires manual resolution } // Automatic retry @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) @Change(id = &quot;idempotent-change&quot;, order = &quot;20250923_02&quot;, author = &quot;team&quot;) public class IdempotentChange { // Automatically retries on failure until successful }   Recovery strategies:  MANUAL_INTERVENTION (default): Stops execution on failure, requires CLI resolutionALWAYS_RETRY: Automatically retries on subsequent executions until successful  For detailed information on recovery strategies, see Safety and Recovery.    ","version":"1.0.0","tagName":"h3"},{"title":"description - Change explanation‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#description---change-explanation","content":" Briefly describes what the change does, especially useful for complex operations.  @Change( id = &quot;optimize-user-queries&quot;, order = &quot;20250923_01&quot;, author = &quot;performance-team&quot;, description = &quot;Add composite index on user table to improve search performance&quot; )   ","version":"1.0.0","tagName":"h3"},{"title":"Required annotations‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#required-annotations","content":" ","version":"1.0.0","tagName":"h2"},{"title":"@TargetSystem - System specification‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#targetsystem---system-specification","content":" Declares which target system this Change affects.  @TargetSystem(&quot;user-database&quot;) @Change(id = &quot;add-user-fields&quot;, author = &quot;api-team&quot;) // order extracted from filename public class _20250923_01_AddUserFields { // Implementation }   ","version":"1.0.0","tagName":"h3"},{"title":"@Change - Class marker‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#change---class-marker","content":" Marks the class as a Change and contains all metadata.  @Change( id = &quot;migrate-user-data&quot;, order = &quot;20250923_01&quot;, author = &quot;migration-team&quot;, description = &quot;Migrate legacy user format to new schema&quot;, transactional = true )   ","version":"1.0.0","tagName":"h3"},{"title":"Required methods‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#required-methods","content":" ","version":"1.0.0","tagName":"h2"},{"title":"@Apply - Change logic‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#apply---change-logic","content":" Contains the actual change implementation.  @Apply public void apply(MongoDatabase database, ClientSession session) { // Your change logic here database.getCollection(&quot;users&quot;) .insertOne(session, new Document(&quot;status&quot;, &quot;active&quot;)); }   Method characteristics:  Must be publicCan have any name (execute, run, apply, etc.)Parameters are dependency-injected by FlamingockShould contain idempotent operations when possible  ","version":"1.0.0","tagName":"h3"},{"title":"@Rollback - Undo logic‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#rollback---undo-logic","content":" Provides logic to reverse the change, essential for safety and CLI undo operations.  @Rollback public void rollback(MongoDatabase database, ClientSession session) { // Undo the change database.getCollection(&quot;users&quot;) .deleteMany(new Document(&quot;status&quot;, &quot;active&quot;)); }   Why rollback is required:  Non-transactional systems: Used automatically if execution failsAll systems: Required for CLI/UI undo operationsSafety: Ensures every change can be reversedGovernance: Demonstrates you've thought through the change impact  ","version":"1.0.0","tagName":"h3"},{"title":"Method parameters and dependency injection‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#method-parameters-and-dependency-injection","content":" Changes receive dependencies through method parameters, automatically injected by Flamingock using a flexible, multi-source approach with fallback hierarchy.  ","version":"1.0.0","tagName":"h2"},{"title":"Change Execution Dependency Resolution‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#change-execution-dependency-resolution","content":" Change execution uses a flexible dependency resolution flow(in this priority order):  Target system context - dependencies from constructor + .withXXX() methodsTarget system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h3"},{"title":"Key Benefits of This Architecture‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#key-benefits-of-this-architecture","content":" Target system isolation: Each target system has its own dependency contextFlexible fallback: Changes can access both system-specific and shared dependenciesClear precedence: Target system dependencies always override global onesType safety: Strongly typed dependency injection with compile-time checking  For complete details on target system configuration vs change execution dependencies, see Target Systems Introduction.  ","version":"1.0.0","tagName":"h3"},{"title":"File naming conventions‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#file-naming-conventions","content":" All Change files must follow the _ORDER_DescriptiveName pattern, with recommended format _YYYYMMDD_NN_DescriptiveName:  _20250923_01_CreateUserIndexes.java _20250923_02_MigrateUserData.java _20250924_01_AddUserStatusColumn.yaml _20250925_01_OptimizeQueries.java   ","version":"1.0.0","tagName":"h2"},{"title":"How Flamingock Extracts Order from Filenames‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#how-flamingock-extracts-order-from-filenames","content":" Flamingock uses a simple rule to extract the order value from your filename:  Filename must start with underscore _Everything between the first _ and the last _ becomes the orderEverything after the last _ is treated as the descriptive name  Step-by-step examples:  Filename\tFirst _\tLast _\tExtracted Order\tDescriptive Name_20250923_01_CreateUsers.java\tposition 0\tposition 11\t20250923_01\tCreateUsers.java _001_SimpleChange.yaml\tposition 0\tposition 4\t001\tSimpleChange.yaml _V1_0_1_DatabaseUpgrade.java\tposition 0\tposition 7\tV1_0_1\tDatabaseUpgrade.java  Rules:  Start with underscore and order (recommended: YYYYMMDD_NN format)Use PascalCase for descriptive namesIf order is also specified in annotation/YAML, both values must be identicalApplies to both code (.java/.kt/.groovy) and template (.yaml/.json) filesOrders are compared alphanumerically for execution sequence  ","version":"1.0.0","tagName":"h3"},{"title":"Complete example‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#complete-example","content":" Here's a complete Change showing all elements:  @TargetSystem(&quot;user-database&quot;) @Change( id = &quot;add-user-preferences&quot;, order = &quot;20250923_01&quot;, author = &quot;user-experience-team&quot;, description = &quot;Add preferences object to user documents with default values&quot;, transactional = true ) public class _20250923_01_AddUserPreferences { @Apply public void apply(MongoDatabase database, ClientSession session) { // Add preferences field with default values var defaultPreferences = new Document() .append(&quot;notifications&quot;, true) .append(&quot;theme&quot;, &quot;light&quot;) .append(&quot;language&quot;, &quot;en&quot;); database.getCollection(&quot;users&quot;) .updateMany( session, new Document(&quot;preferences&quot;, new Document(&quot;$exists&quot;, false)), new Document(&quot;$set&quot;, new Document(&quot;preferences&quot;, defaultPreferences)) ); } @Rollback public void rollback(MongoDatabase database, ClientSession session) { // Remove the preferences field database.getCollection(&quot;users&quot;) .updateMany( session, new Document(), new Document(&quot;$unset&quot;, new Document(&quot;preferences&quot;, &quot;&quot;)) ); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Change Anatomy & Structure","url":"/docs/changes/anatomy-and-structure#next-steps","content":" Change types &amp; Implementation - Deep dive into code-based vs template-based approachesChange best Practices - Learn proven patterns for reliable ChangesTarget Systems - Configure where your changes will be applied ","version":"1.0.0","tagName":"h2"},{"title":"Domain Coupling and Historical Immutability","type":0,"sectionRef":"#","url":"/docs/changes/domain-coupling","content":"","keywords":"","version":"1.0.0"},{"title":"Why this matters‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#why-this-matters","content":" Here's something that might surprise you: Changes that ran successfully in the past can break your build today. This happens when Changes depend on domain classes that evolve over time. Let's understand why this matters and how to keep your Changes stable.  ","version":"1.0.0","tagName":"h2"},{"title":"The coupling problem‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#the-coupling-problem","content":" Changes in Flamingock are meant to be historically immutable - they represent past changes that have been applied and audited. Their code should remain untouched over time to ensure:  Repeatability: The same Change produces the same resultAuditability: Historical changes can be verifiedReliability: Past Changes continue to work in new environments  However, when a Change depends on a domain class and that class evolves (fields removed, renamed, or restructured), your older Changes will no longer compile or run correctly.  ","version":"1.0.0","tagName":"h2"},{"title":"A practical example‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#a-practical-example","content":" Consider a PostgreSQL database with a customers table. Initially, your domain model includes:  public class Customer { private Long id; private String firstName; private String middleName; // Will be removed later private String lastName; private String email; // getters/setters... }   You create a Change that uses this domain class:  @Change(id = &quot;add-premium-customers&quot;, order = &quot;20250923_01&quot;, author = &quot;team&quot;) public class _20250923_01_AddPremiumCustomers { @Apply public void apply(CustomerRepository repository) { Customer customer = new Customer(); customer.setFirstName(&quot;John&quot;); customer.setMiddleName(&quot;William&quot;); // Uses the field customer.setLastName(&quot;Smith&quot;); customer.setEmail(&quot;john.smith@example.com&quot;); repository.save(customer); } }   Six months later, your team decides middleName is unnecessary and removes it from the Customer class. Now:  ‚úÖ Your application works fine with the updated model‚ùå The Change _20250923_01_AddPremiumCustomers no longer compiles‚ùå You can't run Flamingock in new environments‚ùå CI/CD pipelines break  This breaks the principle of historical immutability and undermines Flamingock's reliability.  ","version":"1.0.0","tagName":"h3"},{"title":"The solution: Generic structures‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#the-solution-generic-structures","content":" To ensure stability, avoid injecting domain classes or anything tightly coupled to your evolving business model. Instead, use schema-free or generic structures.  Here's how the same Change looks using generic structures:  @Change(id = &quot;add-premium-customers&quot;, order = &quot;20250923_01&quot;, author = &quot;team&quot;) public class _20250923_01_AddPremiumCustomers { @Apply public void apply(RestTemplate restTemplate) { // Using a Map instead of the Customer domain class Map&lt;String, Object&gt; customerData = new HashMap&lt;&gt;(); customerData.put(&quot;firstName&quot;, &quot;John&quot;); customerData.put(&quot;middleName&quot;, &quot;William&quot;); customerData.put(&quot;lastName&quot;, &quot;Smith&quot;); customerData.put(&quot;email&quot;, &quot;john.smith@example.com&quot;); customerData.put(&quot;status&quot;, &quot;PREMIUM&quot;); // Send to customer service API restTemplate.postForObject( &quot;/api/customers&quot;, customerData, Map.class ); } @Rollback public void rollback(RestTemplate restTemplate) { // Remove the customer using email as identifier restTemplate.delete(&quot;/api/customers/john.smith@example.com&quot;); } }   This Change remains stable even if the Customer domain class evolves or the middleName field is removed. The Map structure is decoupled from your domain model.  ","version":"1.0.0","tagName":"h2"},{"title":"When you need reusable logic‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#when-you-need-reusable-logic","content":" If you have complex logic that needs to be shared across Changes, consider these approaches:  ","version":"1.0.0","tagName":"h2"},{"title":"Utility classes for Changes‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#utility-classes-for-changes","content":" Create utilities specifically for your Changes that are isolated from your domain:  public class ChangeUtils { public static Map&lt;String, Object&gt; createCustomerData( String firstName, String lastName, String email) { return Map.of( &quot;firstName&quot;, firstName, &quot;lastName&quot;, lastName, &quot;email&quot;, email, &quot;createdAt&quot;, Instant.now().toString() ); } }   ","version":"1.0.0","tagName":"h3"},{"title":"SQL files or scripts‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#sql-files-or-scripts","content":" For complex SQL operations, consider external scripts:  @Apply public void apply(JdbcTemplate jdbc) throws IOException { String sql = Files.readString( Paths.get(&quot;changes/sql/001_create_premium_customers.sql&quot;) ); jdbc.execute(sql); }   ","version":"1.0.0","tagName":"h3"},{"title":"Best practices summary‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#best-practices-summary","content":" Treat Changes as historical artifacts - They are versioned records of the past, not part of your live business logic Use generic structures - Maps, Documents, ResultSets, or direct queries instead of domain objects Keep Changes self-contained - Minimize dependencies on external classes that might change Test with evolution in mind - Ensure your Changes compile and run even as your domain evolves Document data structures - When using generic structures, add comments explaining the expected schema  ","version":"1.0.0","tagName":"h2"},{"title":"The balance‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#the-balance","content":" We're not suggesting you should never use any classes in your Changes. The key is understanding the trade-off:  Domain classes: Type safety now, brittleness over timeGeneric structures: Less type safety, long-term stability  Choose based on your context, but be aware of the implications. For most production systems where Changes need to remain stable for years, generic structures are the safer choice.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Domain Coupling and Historical Immutability","url":"/docs/changes/domain-coupling#next-steps","content":" Review existing Changes for domain couplingEstablish team conventions for Change implementationsConsider using Templates for standardized, decoupled change patterns ","version":"1.0.0","tagName":"h2"},{"title":"Changes","type":0,"sectionRef":"#","url":"/docs/changes/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Key characteristics‚Äã","type":1,"pageTitle":"Changes","url":"/docs/changes/introduction#key-characteristics","content":" Atomic execution: Each Change runs exactly onceOrdered sequence: Executed based on their order propertyAuditable: Recorded in the audit store to prevent duplicate executionSafe by default: If Flamingock is uncertain about a change's outcome, it stops and requires manual interventionRollback capable: Can be undone through rollback methods  ","version":"1.0.0","tagName":"h2"},{"title":"What Changes can do‚Äã","type":1,"pageTitle":"Changes","url":"/docs/changes/introduction#what-changes-can-do","content":" Changes enable you to version and track changes across your entire technology stack:  Message queue operations: Topic creation, schema registry updatesObject storage: Bucket setup, file migrations, policy updatesDatabase migrations: Schema changes, data transformations, index creationExternal API integrations: Service configurations, webhook setupsInfrastructure changes: Feature flag updates, configuration changes  ","version":"1.0.0","tagName":"h2"},{"title":"Types of Changes‚Äã","type":1,"pageTitle":"Changes","url":"/docs/changes/introduction#types-of-changes","content":" Template basedCode based Written in Java, Kotlin, or Groovy with annotations. Best for complex logic or when you need full programmatic control. @TargetSystem(&quot;user-database&quot;) @Change(id = &quot;add-user-status&quot;, author = &quot;dev-team&quot;) public class _20250923_01_AddUserStatus { @Apply public void apply(MongoDatabase database) { // Your change logic here } @Rollback public void rollback(MongoDatabase database) { // Your rollback logic here } }   ","version":"1.0.0","tagName":"h2"},{"title":"Safety and recovery‚Äã","type":1,"pageTitle":"Changes","url":"/docs/changes/introduction#safety-and-recovery","content":" While Change executions typically complete successfully, Flamingock provides configurable recovery strategies to handle any exceptional circumstances that may arise. If results are uncertain, Flamingock stops and requires manual intervention rather than risking data corruption, ensuring you always know the exact state of your systems.  You can configure different recovery strategies based on your requirements. For complete details on failure handling and recovery workflows, see Safety and Recovery.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Changes","url":"/docs/changes/introduction#next-steps","content":" Dive deeper into specific aspects of Changes:  Anatomy &amp; Structure - Learn the technical structure, required properties, and annotationsTypes &amp; Implementation - Understand code-based vs template-based approachesBest Practices - Follow proven patterns for reliable Changes  Or continue to other key concepts:  Target Systems - Configure where your changes will be appliedTemplates - Explore reusable change patterns ","version":"1.0.0","tagName":"h2"},{"title":"Transactions","type":0,"sectionRef":"#","url":"/docs/changes/transactions","content":"","keywords":"","version":"1.0.0"},{"title":"How Flamingock handles transactions‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#how-flamingock-handles-transactions","content":" Flamingock's transaction handling is determined by the target system's capabilities, not just the transactional flag. The behavior differs fundamentally between transactional and non-transactional target systems.  ","version":"1.0.0","tagName":"h2"},{"title":"üîÑ Transactional target systems‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#-transactional-target-systems","content":" Examples: PostgreSQL, MySQL, MongoDB, SQL databases, DynamoDB, Couchbase  These systems support native transaction capabilities:  When transactional = true (default):  Execution runs within a native database transactionOn failure: Automatic rollback using database's native transaction mechanismSession/connection managed automatically by Flamingock@Rollback used only for manual operations (CLI undo)  When transactional = false:  Execution runs without transactionOn failure: Safety through compensation logic (@Rollback)Useful for DDL operations or any operation that requires not participating in a transaction  ","version":"1.0.0","tagName":"h3"},{"title":"‚ö° Non-transactional target systems‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#-non-transactional-target-systems","content":" Examples: Kafka, S3, REST APIs, file systems, message queues  These systems have no native transaction support:  The transactional flag is ignored - behavior is always the same:  Execution runs normally (no native transaction possible)On failure: Safety through compensation logic (@Rollback)Safety relies entirely on idempotent operations and rollback methods  ","version":"1.0.0","tagName":"h3"},{"title":"Behavior summary table‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#behavior-summary-table","content":" Target System Type\ttransactional = true (default)\ttransactional = falseTransactional\tNative transaction rollback on failure\t@Rollback on failure Non-transactional\tFlag ignored - @Rollback on failure\tFlag ignored - @Rollback on failure  ","version":"1.0.0","tagName":"h3"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Always provide @Rollback‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#always-provide-rollback","content":" Transactional systems with transactional = true: Used for manual rollback operations (CLI undo)Transactional systems with transactional = false: Called automatically on failureNon-transactional systems: Always called automatically on failure (flag ignored)All cases: Essential for complete change management  ","version":"1.0.0","tagName":"h3"},{"title":"Use appropriate transactionality‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/changes/transactions#use-appropriate-transactionality","content":" Keep default transactional = true for regular data changes on transactional systemsUse transactional = false only when necessary on transactional systems (DDL, bulk operations)For non-transactional systems: The flag doesn't matter - design idempotent operations and robust rollback logic  Key takeaway: Flamingock's transaction behavior is determined by your target system's capabilities. For transactional systems, the transactional flag controls failure handling (native rollback vs @Rollback). For non-transactional systems, the flag is ignored and @Rollback is always used. ","version":"1.0.0","tagName":"h3"},{"title":"Cloud Edition","type":0,"sectionRef":"#","url":"/docs/cloud-edition","content":"","keywords":"","version":"1.0.0"},{"title":"What the Cloud Edition will offer‚Äã","type":1,"pageTitle":"Cloud Edition","url":"/docs/cloud-edition#what-the-cloud-edition-will-offer","content":" Once released, the Cloud Edition will enable:  Centralized dashboards to track and visualize changes across services and environmentsBuilt-in user and team management with Role-Based Access Control (RBAC)Cross-environment visibility for staging, production, and everything in betweenAdvanced template and extension support for faster integration and reuseGovernance, auditability, and compliance built into every change lifecycleMulti-tenant and multi-service support, ready for real-world deployment complexity  note The Cloud Edition still relies on the Flamingock client library to run within your application.  ","version":"1.0.0","tagName":"h2"},{"title":"What's coming in this section‚Äã","type":1,"pageTitle":"Cloud Edition","url":"/docs/cloud-edition#whats-coming-in-this-section","content":" This section will guide you through:  How to set up your Cloud Edition environmentHow to configure the Flamingock client for Cloud EditionHow to use the dashboard, explore audits, and manage servicesBest practices for working with multi-environment and multi-team setups ","version":"1.0.0","tagName":"h2"},{"title":"Change Best Practices","type":0,"sectionRef":"#","url":"/docs/changes/best-practices","content":"","keywords":"","version":"1.0.0"},{"title":"Core principles‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#core-principles","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Treat Changes as immutable‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#treat-changes-as-immutable","content":" Once a Change is deployed, never modify it. Create new Changes for corrections.  ‚ùå Don't do this:  // Modifying an existing Change after deployment @Change(id = &quot;add-user-field&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_AddUserField { @Apply public void apply(MongoDatabase db) { // Original: db.getCollection(&quot;users&quot;).updateMany(/* add field */) // Modified: db.getCollection(&quot;users&quot;).updateMany(/* different logic */) } }   ‚úÖ Do this instead:  // Keep the original unchanged @Change(id = &quot;add-user-field&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_AddUserField { @Apply public void apply(MongoDatabase db) { // Original logic remains unchanged } } // Create a new Change for corrections @Change(id = &quot;fix-user-field-values&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_02_FixUserFieldValues { @Apply public void apply(MongoDatabase db) { // Correction logic } }     ","version":"1.0.0","tagName":"h3"},{"title":"Avoid domain object coupling‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#avoid-domain-object-coupling","content":" Building on the idea of immutability, another common pitfall is coupling Changes too tightly to domain objects. Changes are historical records that must remain stable over time, even as your application evolves. When Changes depend on domain classes that later change (fields removed, renamed, or restructured), your previously successful Changes can break compilation or execution.  The issue: If a Change uses a Customer domain class and you later remove the middleName field from that class, the Change will no longer compile - breaking Flamingock's ability to verify or re-execute historical changes.  ‚úÖ Use generic structures instead:  // Instead of domain objects, use framework-native structures @Apply public void apply(JdbcTemplate jdbc) { Map&lt;String, Object&gt; customer = jdbc.queryForMap( &quot;SELECT * FROM customers WHERE id = ?&quot;, customerId ); // Work with the Map directly, not a Customer object }   ‚Üí Learn more: Domain Coupling and Historical Immutability - Understand why this happens and explore different approaches to keep your Changes stable.    ","version":"1.0.0","tagName":"h3"},{"title":"Always provide rollback logic‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#always-provide-rollback-logic","content":" Every Change must have a @Rollback method, regardless of target system type.  Why rollback matters:  Non-transactional systems: Automatic cleanup on failureAll systems: CLI/UI undo operationsSafety: Proves you understand the change impactGovernance: Required for audit compliance  Example with comprehensive rollback:  @Change(id = &quot;setup-user-indexes&quot;, author = &quot;db-team&quot;) // order extracted from filename public class _20250923_01_SetupUserIndexes { @Apply public void apply(MongoDatabase database) { MongoCollection&lt;Document&gt; users = database.getCollection(&quot;users&quot;); // Create compound index for user queries users.createIndex( new Document(&quot;email&quot;, 1).append(&quot;status&quot;, 1), new IndexOptions().name(&quot;idx_user_email_status&quot;).unique(false) ); // Create text index for search users.createIndex( new Document(&quot;firstName&quot;, &quot;text&quot;).append(&quot;lastName&quot;, &quot;text&quot;), new IndexOptions().name(&quot;idx_user_search&quot;) ); } @Rollback public void rollback(MongoDatabase database) { MongoCollection&lt;Document&gt; users = database.getCollection(&quot;users&quot;); // Drop only if the index exists if (isIndexCreated(users, &quot;idx_user_search&quot;)) { users.dropIndex(&quot;idx_user_search&quot;); } if (isIndexCreated(users, &quot;idx_user_email_status&quot;)) { users.dropIndex(&quot;idx_user_email_status&quot;); } } }     ","version":"1.0.0","tagName":"h3"},{"title":"Keep scope focused‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#keep-scope-focused","content":" Each Change should address one logical change. Avoid combining unrelated operations.  ‚ùå Avoid mixing concerns:  @Change(id = &quot;big-refactor&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_BigRefactor { @Apply public void apply(MongoDatabase db, KafkaProducer producer) { // Adding user field db.getCollection(&quot;users&quot;).updateMany(/* ... */); // Creating Kafka topic producer.send(/* create topic message */); // Updating configuration db.getCollection(&quot;config&quot;).updateOne(/* ... */); } }   ‚úÖ Separate concerns:  @TargetSystem(&quot;user-database&quot;) @Change(id = &quot;add-user-status&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_AddUserStatus { // Focus: User schema change only } @TargetSystem(&quot;kafka-events&quot;) @Change(id = &quot;create-user-topic&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_CreateUserTopic { // Focus: Kafka topic creation only }   ","version":"1.0.0","tagName":"h3"},{"title":"Technical guidelines‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#technical-guidelines","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Design for idempotency‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#design-for-idempotency","content":" Make operations safe to re-run whenever possible.  Example: Idempotent field addition:  @Change(id = &quot;add-user-preferences&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_AddUserPreferences { @Apply public void apply(MongoDatabase database) { // Only update users that don't already have preferences database.getCollection(&quot;users&quot;).updateMany( new Document(&quot;preferences&quot;, new Document(&quot;$exists&quot;, false)), new Document(&quot;$set&quot;, new Document(&quot;preferences&quot;, getDefaultPreferences())) ); } private Document getDefaultPreferences() { return new Document() .append(&quot;theme&quot;, &quot;light&quot;) .append(&quot;notifications&quot;, true); } }     ","version":"1.0.0","tagName":"h3"},{"title":"Handle errors gracefully‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#handle-errors-gracefully","content":" Don't catch exceptions unless you have specific recovery logic. Let Flamingock handle error management.  ‚ùå Don't suppress errors:  @Apply public void apply(MongoDatabase database) { try { // Some operation database.getCollection(&quot;users&quot;).updateMany(/* ... */); } catch (Exception e) { // Silently ignoring errors prevents proper error handling System.out.println(&quot;Error occurred: &quot; + e.getMessage()); } }   ‚úÖ Let exceptions bubble up:  @Apply public void apply(MongoDatabase database) { // Let Flamingock handle exceptions and recovery database.getCollection(&quot;users&quot;).updateMany(/* ... */); }     ","version":"1.0.0","tagName":"h3"},{"title":"Use meaningful method names‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#use-meaningful-method-names","content":" Method names should clearly indicate their purpose.  Good examples:  @Apply public void migrateUserProfilesToNewSchema(MongoDatabase db) { } @Apply public void addEmailIndexForFasterLookups(MongoDatabase db) { } @Rollback public void removeEmailIndexAndRevertSchema(MongoDatabase db) { }   ","version":"1.0.0","tagName":"h3"},{"title":"Naming and organization‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#naming-and-organization","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Follow consistent naming patterns‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#follow-consistent-naming-patterns","content":" File names:  Use _ORDER_DescriptiveName format where ORDER is extracted between first and last underscoresRecommended format: YYYYMMDD_NN where: YYYY = year, MM = month, DD = dayNN = sequence number (01-99) for changes on the same day When using this naming pattern, the order in @Change annotation or YAML is optionalUse PascalCase for class names  Good examples:  _20250923_01_CreateUserIndexes.java _20250923_02_MigrateUserData.java _20250924_01_AddUserPreferences.java _20250925_01_OptimizeUserQueries.java _20250930_01_MigrateToNewFormat.yaml   Recommendation We recommend specifying the order in the file/class name using the YYYYMMDD_NN format: Benefits: Natural chronological sorting - Files automatically sort by date in foldersClear timeline visibility - Instantly see when changes were createdPractical daily limit - 99 changes per day is more than sufficientEasy identification - Quick visual scan shows change historyNo annotation needed - Order is extracted from filename Examples: _20250923_01_CreateUserTable.java ‚Üí order: &quot;20250923_01&quot; (no need for order in @Change)_20250923_02_MigrateData.yaml ‚Üí order: &quot;20250923_02&quot; (no need for order in YAML)_20250924_01_AddIndexes.java ‚Üí order: &quot;20250924_01&quot;  For detailed rules about order field placement (filename vs annotation), see Anatomy &amp; Structure - Order.    ","version":"1.0.0","tagName":"h3"},{"title":"Use descriptive IDs and descriptions‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#use-descriptive-ids-and-descriptions","content":" Make your Changes self-documenting:  @Change( id = &quot;migrate-legacy-user-format-to-v2&quot;, order = &quot;20250923_01&quot;, author = &quot;data-migration-team&quot;, description = &quot;Migrate user documents from legacy format to v2 schema with new preference structure&quot; )     ","version":"1.0.0","tagName":"h3"},{"title":"Organize by chronological order‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#organize-by-chronological-order","content":" Changes should be organized chronologically by their order within stages. If you need logical grouping, use stages - but remember that execution order is only guaranteed within a stage, not between stages.  src/main/java/com/company/changes/ ‚îú‚îÄ‚îÄ _20250923_01_CreateUserCollection.java ‚îú‚îÄ‚îÄ _20250923_02_AddUserIndexes.java ‚îú‚îÄ‚îÄ _20250924_01_MigrateUserData.java ‚îú‚îÄ‚îÄ _20250924_02_CreateOrdersTable.java ‚îî‚îÄ‚îÄ _20250925_01_AddOrderStatusColumn.java   ","version":"1.0.0","tagName":"h3"},{"title":"Testing and validation‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#testing-and-validation","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Test both execution and rollback‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#test-both-execution-and-rollback","content":" Create comprehensive tests for your Changes:  @Test public void testUserMigrationChange() { // Arrange MongoDatabase testDb = getTestDatabase(); insertTestUsers(testDb); var change = new _20250923_01_MigrateUsers(); // Act - Test execution change.execute(testDb); // Assert - Verify execution results MongoCollection&lt;Document&gt; users = testDb.getCollection(&quot;users&quot;); assertEquals(5, users.countDocuments(new Document(&quot;status&quot;, &quot;active&quot;))); // Act - Test rollback change.rollback(testDb); // Assert - Verify rollback results assertEquals(0, users.countDocuments(new Document(&quot;status&quot;, new Document(&quot;$exists&quot;, true)))); }     ","version":"1.0.0","tagName":"h3"},{"title":"Validate with real-like data‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#validate-with-real-like-data","content":" Test with data that resembles production:  @Test public void testWithRealisticData() { // Use realistic data volumes and edge cases insertUsers(1000); // Test batch processing insertUsersWithMissingFields(); // Test data inconsistencies insertUsersWithEdgeCaseValues(); // Test boundary conditions // Run your Change change.execute(database); // Verify all scenarios handled correctly }   ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Change Best Practices","url":"/docs/changes/best-practices#next-steps","content":" Templates - Explore reusable change patternsTarget Systems - Configure where changes are appliedTesting - Comprehensive testing strategies for Changes ","version":"1.0.0","tagName":"h2"},{"title":"Additional configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/additional-configuration","content":"","keywords":"","version":"1.0.0"},{"title":"Metadata‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#metadata","content":" Flamingock provides a Metadata object - which is a flexible Map&lt;String, Object&gt; that allows you to attach custom information to your Flamingock process.  The metadata is stored as part of the audit log, and can be used for labeling, traceability, and future reporting.  ","version":"1.0.0","tagName":"h2"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#use-cases","content":" You can use metadata to:  Tag executions by team, service, or regionInclude a deployment ID, build number, or triggering userAttach comments or labels for easier traceability  ","version":"1.0.0","tagName":"h3"},{"title":"Example‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#example","content":" YAMLBuilder metadata: owner: platform-team triggeredBy: ci-cd-pipeline notes: initial deployment setup   ","version":"1.0.0","tagName":"h3"},{"title":"Disable flamingock process‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#disable-flamingock-process","content":" This global toggle allows you to enable or disable Flamingock.  If set to false, Flamingock will not runA log message will appear in the application logs, indicating that Flamingock is disabledNo changes will be applied and no audit entries will be created  note Useful in test environments, local runs, or cases where you want to conditionally skip changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#example-1","content":" YAMLBuilder enabled: false  ","version":"1.0.0","tagName":"h3"},{"title":"Change Types & Implementation","type":0,"sectionRef":"#","url":"/docs/changes/types-and-implementation","content":"","keywords":"","version":"1.0.0"},{"title":"File organization‚Äã","type":1,"pageTitle":"Change Types & Implementation","url":"/docs/changes/types-and-implementation#file-organization","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Recommended project structure:‚Äã","type":1,"pageTitle":"Change Types & Implementation","url":"/docs/changes/types-and-implementation#recommended-project-structure","content":" src/main/java/com/yourapp/changes/ ‚îú‚îÄ‚îÄ _20250923_01_CreateUserIndexes.java ‚îú‚îÄ‚îÄ _20250923_02_AddUserStatus.yaml ‚îú‚îÄ‚îÄ _20250924_01_MigrateUserData.java ‚îú‚îÄ‚îÄ _20250924_02_SetupNotifications.yaml ‚îî‚îÄ‚îÄ _20250925_01_OptimizeQueries.java   ","version":"1.0.0","tagName":"h3"},{"title":"Best practices:‚Äã","type":1,"pageTitle":"Change Types & Implementation","url":"/docs/changes/types-and-implementation#best-practices","content":" Keep together: Store both code and template files in the same directoryConsistent naming: Follow _ORDER_DescriptiveName pattern for both types (recommended: YYYYMMDD_NN)Order in filename: When using the naming pattern, order in annotation/yaml is optional  Order Field Rules When using the _ORDER_DescriptiveName pattern, the order field in annotations or YAML becomes optional. For complete rules about order field placement, see Anatomy &amp; Structure - Order.  ","version":"1.0.0","tagName":"h3"},{"title":"Template development‚Äã","type":1,"pageTitle":"Change Types & Implementation","url":"/docs/changes/types-and-implementation#template-development","content":" Flamingock and the community provide useful templates for common operations. Organizations can also develop their own templates to standardize patterns and integrations specific to their needs.  For more information about available templates and how to create custom templates, see Templates.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Change Types & Implementation","url":"/docs/changes/types-and-implementation#next-steps","content":" Best Practices - Learn proven patterns for reliable ChangesTemplates - Explore available templates and create custom onesTarget Systems - Configure where your changes will be applied ","version":"1.0.0","tagName":"h2"},{"title":"Flamingock CLI","type":0,"sectionRef":"#","url":"/docs/cli","content":"","keywords":"","version":"1.0.0"},{"title":"Overview‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#overview","content":" The Flamingock CLI provides operational commands for audit management and maintenance. Use these commands to view audit history, identify issues, and perform resolution operations.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#installation","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Download‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#download","content":" # Download the latest CLI distribution curl -L https://github.com/flamingock/flamingock-java/releases/latest/download/flamingock-cli.tar.gz -o flamingock-cli.tar.gz # Extract the archive tar -xzf flamingock-cli.tar.gz # Make it executable chmod +x flamingock # Run the CLI ./flamingock --help   ","version":"1.0.0","tagName":"h3"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#configuration","content":" Create a flamingock.yaml configuration file in your working directory:  MongoDB Configuration‚Äã  serviceIdentifier: my-service # Optional, defaults to &quot;flamingock-cli&quot; audit: mongodb: connectionString: mongodb://localhost:27017 database: myapp # Or use individual properties: # host: localhost # port: 27017 # username: admin # password: secret   DynamoDB Configuration‚Äã  serviceIdentifier: my-service audit: dynamodb: region: us-east-1 # Optional endpoint for local development: # endpoint: http://localhost:8000 # accessKey: local # secretKey: local   You can specify a custom configuration file using the -c or --config option:  flamingock -c custom-config.yaml audit list   ","version":"1.0.0","tagName":"h3"},{"title":"Core Commands‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#core-commands","content":" ","version":"1.0.0","tagName":"h2"},{"title":"View Audit Entries‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#view-audit-entries","content":" List the current state of all changes (snapshot view):  flamingock audit list   View the complete chronological history:  flamingock audit list --history   View changes since a specific date:  flamingock audit list --since 2025-01-01T00:00:00   Show extended information including execution details:  flamingock audit list --extended   ","version":"1.0.0","tagName":"h3"},{"title":"Find Issues‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#find-issues","content":" List all change units with inconsistent audit states:  flamingock issue list   Output in JSON format for automation:  flamingock issue list --json   ","version":"1.0.0","tagName":"h3"},{"title":"Investigate Issues‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#investigate-issues","content":" Get detailed information about a specific issue:  flamingock issue get -c user-migration-v2   Include resolution guidance:  flamingock issue get -c user-migration-v2 --guidance   Get the next priority issue (when no change ID specified):  flamingock issue get --guidance   ","version":"1.0.0","tagName":"h3"},{"title":"Resolve Issues‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#resolve-issues","content":" After manually verifying or fixing the state, mark the change as resolved:  If the change was successfully applied:  flamingock audit fix -c user-migration-v2 -r APPLIED   If the change was not applied or rolled back:  flamingock audit fix -c user-migration-v2 -r ROLLED_BACK   For detailed workflows on issue resolution, see Issue resolution.  ","version":"1.0.0","tagName":"h3"},{"title":"Command Reference‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#command-reference","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Global Options‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#global-options","content":" flamingock [global-options] &lt;command&gt; [command-options]   -c, --config &lt;file&gt; - Configuration file path (default: flamingocka)--verbose - Enable verbose logging--debug - Enable debug logging--trace - Enable trace logging (most detailed level)--quiet - Suppress non-essential output--help - Show help information--version - Show version information  ","version":"1.0.0","tagName":"h3"},{"title":"audit list‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#audit-list","content":" Display audit entries from the audit store.  Options:  --history - Show full chronological history (all entries)--since &lt;datetime&gt; - Show entries since date (ISO-8601 format: 2025-01-01T00:00:00)-e, --extended - Show extended information (execution ID, duration, class, method, hostname)  Examples:  # View current state (latest per change unit) flamingock audit list # View all historical entries flamingock audit list --history # View changes from last 24 hours flamingock audit list --since 2025-01-07T00:00:00 # View with extended details flamingock audit list --extended   ","version":"1.0.0","tagName":"h3"},{"title":"audit fix‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#audit-fix","content":" Resolve an inconsistent audit state after manual intervention.  Options:  -c, --change-id &lt;id&gt; - Change unit ID to fix (required)-r, --resolution &lt;type&gt; - Resolution type: APPLIED or ROLLED_BACK (required)  Examples:  # Mark as successfully applied flamingock audit fix -c create-user-index -r APPLIED # Mark as rolled back (will be retried on next execution) flamingock audit fix -c create-user-index -r ROLLED_BACK   ","version":"1.0.0","tagName":"h3"},{"title":"issue list (alias: ls)‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#issue-list-alias-ls","content":" List all change units with inconsistent audit states.  Options:  -j, --json - Output in JSON format  Examples:  # List issues in table format flamingock issue list # Output as JSON for automation flamingock issue list --json   ","version":"1.0.0","tagName":"h3"},{"title":"issue get (alias: describe)‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#issue-get-alias-describe","content":" Show detailed information about an issue.  Options:  -c, --change-id &lt;id&gt; - Specific change unit ID (optional, shows next issue if omitted)-g, --guidance - Include resolution guidance-j, --json - Output in JSON format  Examples:  # Get next priority issue flamingock issue get --guidance # Get specific issue details flamingock issue get -c user-migration-v3 # Get with resolution guidance flamingock issue get -c user-migration-v3 --guidance # Output as JSON flamingock issue get -c user-migration-v3 --json   ","version":"1.0.0","tagName":"h3"},{"title":"Example Output‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#example-output","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Audit List Output‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#audit-list-output","content":" Audit Entries Snapshot (Latest per Change Unit): ================================================== ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Change ID ‚îÇ State ‚îÇ Author ‚îÇ Time ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ create-users-collection ‚îÇ ‚úì ‚îÇ platform-team ‚îÇ 2025-01-07 10:15:23 ‚îÇ ‚îÇ add-user-indexes ‚îÇ ‚úì ‚îÇ platform-team ‚îÇ 2025-01-07 10:15:24 ‚îÇ ‚îÇ seed-initial-data ‚îÇ ‚úó ‚îÇ data-team ‚îÇ 2025-01-07 10:15:25 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Legend: ‚úì = EXECUTED | ‚úó = FAILED | ‚ñ∂ = STARTED | ‚Ü© = ROLLED_BACK Total entries: 3   ","version":"1.0.0","tagName":"h3"},{"title":"Issue Details Output‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#issue-details-output","content":" Issue Details: seed-initial-data ================================================== üìã OVERVIEW Change ID: seed-initial-data State: STARTED (‚ùå) Target System: user-database Author: data-team Time: 2025-01-07 10:15:25 Execution ID: exec-123456 Duration: 1523ms ‚ö†Ô∏è ERROR DETAILS Execution interrupted unexpectedly Technical Details: - Class: i.f.changes.SeedData - Method: execute - Hostname: prod-server-01 üîß Resolution Process: 1. Review the error details above to understand the root cause 2. Verify the actual state in your target system (user-database): ‚Ä¢ Check if the change was successfully applied despite the audit failure ‚Ä¢ Determine if the change was partially applied or not applied at all 3. Fix the audit state based on your findings: ‚úÖ If change was successfully applied: flamingock audit fix -c seed-initial-data -r APPLIED ‚Ü©Ô∏è If change was not applied or you've manually rolled it back: flamingock audit fix -c seed-initial-data -r ROLLED_BACK (Flamingock will retry this change in the next execution) ‚ö†Ô∏è Important: For partially applied changes, you must either: ‚Ä¢ Manually complete the change, then fix it with resolution(-r) APPLIED ‚Ä¢ Manually revert the change, then fix it with resolution(-r) ROLLED_BACK   ","version":"1.0.0","tagName":"h3"},{"title":"Logging Levels‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#logging-levels","content":" Control the verbosity of output using logging options:  # Normal output (default) flamingock audit list # Verbose output with info logs flamingock --verbose audit list # Debug output with detailed logs flamingock --debug audit list # Minimal output flamingock --quiet audit list   ","version":"1.0.0","tagName":"h2"},{"title":"Troubleshooting‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#troubleshooting","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Connection Issues‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#connection-issues","content":" If you see &quot;Cannot connect to audit store&quot;:  Verify your configuration file exists and is valid YAMLCheck database connection parametersEnsure the database is accessible from your locationTest with verbose logging: flamingock --verbose audit list  ","version":"1.0.0","tagName":"h3"},{"title":"No Issues Found‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#no-issues-found","content":" If issue list shows no issues but you expect some:  Verify you're connecting to the correct audit storeCheck if issues were already resolvedUse audit list --history to see all historical entries  ","version":"1.0.0","tagName":"h3"},{"title":"Permission Errors‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#permission-errors","content":" If you get permission errors when running audit fix:  Ensure your database credentials have write accessVerify the audit collection/table permissionsCheck if the database user can modify audit entries ","version":"1.0.0","tagName":"h3"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/events","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#introduction","content":" Flamingock utilizes events to notify the main application about the current state of the Flamingock process, as well as the eventual outcome of its execution.  The event-handling approach differs significantly depending on the type of runner being used:  For Spring-based applications, Flamingock leverages the ApplicationEventPublisher, which is provided during the build process.For standalone applications, Flamingock requires an explicit event handler to be defined at build time.  Flamingock offers event handling capabilities for both Pipelines and Stages.  ","version":"1.0.0","tagName":"h2"},{"title":"Type of events‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#type-of-events","content":" Flamingock emits three types of events:  Start Event: Triggered just before the migration process begins, following successful validation.Success Event: Emitted upon successful completion of the migration. This indicates that no unhandled exceptions occurred, or that any errors were either properly handled or associated changeLogs were marked with 'Fail' as false.Failure Event: Emitted when a change log fails and the failure is not handled, as described above.  warning The Success and Failure events are mutually exclusive, only one of them will be raised for a given migration execution.  ","version":"1.0.0","tagName":"h2"},{"title":"Getting started with events‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#getting-started-with-events","content":" Each runner's documentation page provides the necessary information for using events in accordance with that runner's specific implementation.  ","version":"1.0.0","tagName":"h2"},{"title":"Standalone basic example‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#standalone-basic-example","content":" In the Flamingock builder, you must configure the events you intend to use and implement the corresponding listeners.  ","version":"1.0.0","tagName":"h2"},{"title":"Builder‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#builder","content":" JavaKotlin Flamingock.builder() .setPipelineStartedListener(new PipelineStartedListener()) .setPipelineCompletedListener(new PipelineCompletedListener()) .setPipelineFailedListener(new PipelineFailedListener()) .setStageStartedListener(new StageStartedListener()) .setStageCompletedListener(new StageCompletedListener()) .setStageFailedListener(new StageFailedListener()) .build() .run();   ","version":"1.0.0","tagName":"h3"},{"title":"Listener‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#listener","content":" JavaKotlin public class StageCompletedListener implements Consumer&lt;IStageCompletedEvent&gt; { public static int executed = 0; @Override public void accept(IStageCompletedEvent iStageCompletedEvent) { executed++; } }   ","version":"1.0.0","tagName":"h3"},{"title":"Spring-based basic example‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#spring-based-basic-example","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Listeners‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#listeners","content":" JavaKotlin @Bean public PipelineStartedListener startFlamingockListener() { return new PipelineStartedListener(); } @Bean public PipelineCompletedListener successFlamingockListener() { return new PipelineCompletedListener(); } @Bean public PipelineFailedListener sailedFlamingockListener() { return new PipelineFailedListener(); } @Bean public StageStartedListener stageStartedListener() {return new StageStartedListener();} @Bean public StageCompletedListener stageCompletedListener() {return new StageCompletedListener();} @Bean public StageFailedListener stageFailedListener() {return new StageFailedListener();}  ","version":"1.0.0","tagName":"h3"},{"title":"Context and dependencies","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/context-and-dependencies","content":"","keywords":"","version":"1.0.0"},{"title":"What is the context?‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#what-is-the-context","content":" The context is Flamingock's dependency container that holds all the dependencies your Changes might need. It's organized hierarchically, allowing for proper scoping and isolation of dependencies.  Contexts can contain:  System connectors (databases, message queues, storage services, APIs)Configuration properties and objectsService instances and business logic componentsFramework-specific beans (like Spring components)Custom utilities and helpers  ","version":"1.0.0","tagName":"h2"},{"title":"Dependency resolution hierarchy‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#dependency-resolution-hierarchy","content":" Flamingock uses a hierarchical resolution strategy that searches for dependencies in this order:  Target system context - Dependencies provided by the specific target system. For more information, see Target systems.General application context - Shared dependencies registered globally directly in the builderFramework context - When using Spring Boot, beans from the Spring container. For more information, see Spring Boot integration.  This approach ensures that system-specific dependencies are properly scoped while allowing shared utilities to be available everywhere.  ","version":"1.0.0","tagName":"h2"},{"title":"How it works in practice‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#how-it-works-in-practice","content":" When a Change needs a dependency, Flamingock follows a specific search pattern. For example, imagine your Change requires a NotificationService:  Scenario 1: If the Kafka target system provides its own notification service specifically for event streaming, and your Change belongs to that Kafka target system, Flamingock will use the Kafka-specific notification service. The target system context always wins.  Scenario 2: If your MongoDB target system doesn't provide a notification service, but you've registered one globally in Flamingock's builder, the Change will receive that global notification service. Flamingock searches the target system first, doesn't find it, then falls back to the global context.  Scenario 3: In a Spring Boot application, if neither the target system nor the global context provides the dependency, Flamingock will look for a Spring bean of that type. This allows seamless integration with your existing Spring components.  This hierarchy ensures that specialized implementations (like a Kafka-optimized notification service) are used when available, while still allowing shared services to be accessible across all Changes.  ","version":"1.0.0","tagName":"h3"},{"title":"Providing dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#providing-dependencies","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Target system dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#target-system-dependencies","content":" Every target system provides two ways to add dependencies:  Specific methods - Each concrete implementation offers .withXXX() methods for common dependencies:  var mongoTarget = new MongoDBSyncTargetSystem(&quot;user-db&quot;) .withDatabase(database) // MongoDB-specific method .withMongoClient(client); // MongoDB-specific method   Generic methods - All target systems (including NonTransactionalTargetSystem) support generic dependency injection:  var kafkaTarget = new NonTransactionalTargetSystem(&quot;events-id&quot;) .addDependency(kafkaProducer) .addDependency(&quot;notification-service&quot;, notificationService) .setProperty(&quot;batch.size&quot;, 1000);   This flexibility allows NonTransactionalTargetSystem to inject any dependencies needed for non-transactional systems, while specialized target systems provide convenience methods for their common dependencies.  ","version":"1.0.0","tagName":"h3"},{"title":"Global dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#global-dependencies","content":" You can register dependencies globally to make them available to all Changes:  Flamingock.builder() .addDependency(userService) .addDependency(emailService) .addDependency(configurationProperties) .addTargetSystems(mongoTarget) .build();   ","version":"1.0.0","tagName":"h3"},{"title":"Framework dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#framework-dependencies","content":" When using frameworks like Spring Boot, Flamingock automatically accesses beans from the framework container:  @Service public class UserService { // This service is automatically available to Changes }   warning Remember that target system contexts are isolated. Dependencies in one target system aren't available to Changes in another target system.  ","version":"1.0.0","tagName":"h3"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Scope dependencies appropriately‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#scope-dependencies-appropriately","content":" Target system specific: System connectors (DB, Kafka, S3, etc.), system-specific configurationsGlobal: Shared services, utilities, application-wide configurationFramework: Let Spring manage beans, services, and repositories  Key takeaway: Flamingock's hierarchical dependency resolution provides flexibility while maintaining clear separation of concerns. Use target system contexts for system-specific dependencies and global context for shared resources. ","version":"1.0.0","tagName":"h3"},{"title":"Flamingock library configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"What you can configure‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#what-you-can-configure","content":" Area\tDescription\tLink‚≠ê Setup &amp; stages\tOrganize changes into ordered stages - Essential\tSetup &amp; stages ‚≠ê Target systems\tConfigure target systems for your changes - Essential\tTarget systems ‚≠ê Audit store\tConfigure audit storage - Essential\tAudit stores Global dependency injection\tDependency injection to Changes and environment\tContext and dependencies Cloud Edition\tCloud-specific setup: token, env, service\tCloud Edition Framework integration\tIntegration with frameworks (currently Spring Boot)\tSpring Boot integration Lock\tDistributed locking and timing options\tLock configuration Extra\tMetadata, default author, enable/disable\tAdditional configuration  Each of these topics is explained in its own section.  ","version":"1.0.0","tagName":"h2"},{"title":"Applying runtime configuration‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#applying-runtime-configuration","content":" Runtime configuration (everything except the pipeline) can be applied in the following ways:  Runtime environment\tBuilder\tFileStandalone\t‚úÖ\t‚ùå (coming soon) Springboot\t‚úÖ\t‚úÖ(framework native)  info You can combine both approaches. If a property is defined in both, the builder value takes precedence.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#next-steps","content":" Start with the essential configurations marked with ‚≠ê, then explore additional options based on your needs:  ","version":"1.0.0","tagName":"h2"},{"title":"Essential configurations (start here)‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#essential-configurations-start-here","content":" ‚≠ê Setup &amp; stages - Define how changes are organized and discovered‚≠ê Target systems - Configure systems where changes will be applied‚≠ê Audit stores - Set up audit storage (not needed for Cloud Edition)  ","version":"1.0.0","tagName":"h3"},{"title":"Additional configurations‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#additional-configurations","content":" Global dependency injection - Configure dependency resolutionFramework integration - Spring Boot integrationLock configuration - Distributed locking optionsAdditional configuration - Metadata, author, and other settings  ","version":"1.0.0","tagName":"h3"},{"title":"Choose your edition‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#choose-your-edition","content":" ‚òÅÔ∏è Cloud Edition - Fully-featured managed solutionüß™ Community Edition - Community audit stores (feature-limited) ","version":"1.0.0","tagName":"h3"},{"title":"Setup & Stages","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/setup-and-stages","content":"","keywords":"","version":"1.0.0"},{"title":"Setup configuration‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#setup-configuration","content":" Flamingock is configured using the @EnableFlamingock annotation on any class in your application. This annotation is required for all environments ‚Äî whether you're using the standalone runner or Spring Boot integration.  The annotation is only used for defining the setup (stages and their sources). No runtime configuration should be placed here.  ","version":"1.0.0","tagName":"h2"},{"title":"Defining the setup‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#defining-the-setup","content":" Here's the default single-stage configuration:  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } ) public class FlamingockConfig { // Configuration class }   Alternatively, using a YAML file:  @EnableFlamingock( pipelineFile = &quot;config/setup.yaml&quot; ) public class FlamingockConfig {}   Where config/setup.yaml contains:  pipeline: stages: - name: main location: com.yourcompany.changes   Advanced options: Multiple stages: For complex scenarios requiring independent change sets go to the stage section belowFile-based configuration: Use pipelineFile parameter for YAML configurationExplicit naming: Use @Stage(name = &quot;custom&quot;, location = &quot;com.yourcompany.changes&quot;)  ","version":"1.0.0","tagName":"h2"},{"title":"Multiple Stages (Advanced)‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#multiple-stages-advanced","content":" Most applications will naturally fit into a single stage, which keeps things simple and ensures a clear, deterministic execution order. However, if you prefer to organize changes into multiple stages‚Äîfor example, to separate concerns or enforce isolated execution flows‚ÄîFlamingock fully supports that as well. We‚Äôll explain how it works and what to consider when taking that approach.  Default approach: Most applications use a single stage: @Stage(location = &quot;com.yourcompany.changes&quot;). The name is auto-derived (&quot;changes&quot;) and this is the recommended default setup.  ","version":"1.0.0","tagName":"h2"},{"title":"When to Use Multiple Stages‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#when-to-use-multiple-stages","content":" Multiple stages are beneficial in specific scenarios:  Multi-module Applications‚Äã  In monolithic applications with well-defined module boundaries, you can give each module its own stage for full autonomy:  @EnableFlamingock( stages = { @Stage(name = &quot;user-module&quot;, location = &quot;com.yourapp.users.changes&quot;), @Stage(name = &quot;billing-module&quot;, location = &quot;com.yourapp.billing.changes&quot;), @Stage(name = &quot;notification-module&quot;, location = &quot;com.yourapp.notifications.changes&quot;) } )   This approach allows:  Independent change management across modulesDifferent release cycles for different modulesClear separation of concerns and responsibilities  Functional Separation‚Äã  You might want to separate changes by function or lifecycle:  @EnableFlamingock( stages = { @Stage(name = &quot;core-setup&quot;, location = &quot;com.yourapp.setup.changes&quot;), @Stage(name = &quot;business-logic&quot;, location = &quot;com.yourapp.business.changes&quot;), @Stage(name = &quot;monitoring-setup&quot;, location = &quot;com.yourapp.monitoring.changes&quot;) } )   ","version":"1.0.0","tagName":"h3"},{"title":"Restrictions and Important Considerations‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#restrictions-and-important-considerations","content":" No Execution Order Guarantees‚Äã  Critical limitation: Flamingock does not guarantee execution order between stages. This means:  Stage A might execute before, after, or concurrently with Stage BYou cannot rely on changes in one stage being applied before another stage startsEach stage should be completely independent from others  Why This Matters‚Äã  Consider this problematic scenario:  // ‚ùå PROBLEMATIC: Relies on execution order @EnableFlamingock( stages = { @Stage(name = &quot;create-tables&quot;, location = &quot;com.yourapp.schema&quot;), // Creates tables @Stage(name = &quot;seed-data&quot;, location = &quot;com.yourapp.data&quot;) // Inserts data - DEPENDS on tables existing! } )   The seed-data stage might execute before create-tables, causing failures.  Correct Approach‚Äã  Instead, group dependent changes in the same stage:  // ‚úÖ CORRECT: All related changes in one stage @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) // Contains both table creation AND data seeding in order } )   ","version":"1.0.0","tagName":"h3"},{"title":"When NOT to Use Multiple Stages‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#when-not-to-use-multiple-stages","content":" Avoid multiple stages when:  You need execution order across different change types - Use a single stage insteadChanges are logically related - Keep them together for easier maintenanceSimple applications - The complexity isn't worth the overheadCross-cutting concerns - Changes that affect multiple areas should be in one stage  Future Enhancements Conditional stage execution based on dependencies or conditions is planned for future releases, which would allow: Running stages based on success/failure of other stagesDefining explicit dependencies between stagesMore sophisticated stage orchestration patterns  ","version":"1.0.0","tagName":"h3"},{"title":"Required fields‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#required-fields","content":" Each stage must define:  name (optional): A unique identifier - if not provided, it will be auto-derived from the locationlocation: The package or directory where changes are located  ","version":"1.0.0","tagName":"h2"},{"title":"Stage fields‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#stage-fields","content":" Field\tRequired\tDescriptionlocation\t‚úÖ\tPackage or directory scanned for both code-based and template-based changes name\t‚ùå\tUnique identifier for the stage (auto-derived from location if not provided) description\t‚ùå\tOptional text explaining the stage's purpose  ","version":"1.0.0","tagName":"h2"},{"title":"Where Changes are located‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#where-changes-are-located","content":" location refers to a source package (e.g., com.company.changes), a relative(e.g., my/path/changes) or absolute(e.g., /my/path/changes) resources directory. Template-based and code-based changes can co-exist if location is a source package.If location references a resource directory, it only accepts template-based changes.Default source roots: src/main/java, src/main/kotlin, src/main/scala, src/main/groovy.Source root can be customized via the sources compiler option.Resource root can be customized via the resources compiler option. Customizing Source and Resource Root Paths  GradleMaven tasks.withType&lt;JavaCompile&gt; { options.compilerArgs.addAll(listOf( &quot;-Asources=custom/src&quot;, &quot;-Aresources=custom/resources&quot; )) }   ","version":"1.0.0","tagName":"h2"},{"title":"Example Pipeline‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#example-pipeline","content":" pipeline: stages: - name: user-setup description: User-related DB setup location: com.yourapp.flamingock.users   Folder view:  src/ main/ java/ com/ yourapp/ flamingock/ users/ _20250923_01_CreateUsersTable.java _20250923_02_AaddIndex.yaml   ","version":"1.0.0","tagName":"h2"},{"title":"Best Practices‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Single Stage Execution (default and recommended)‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#single-stage-execution-default-and-recommended","content":" In most applications, changes that require a specific, deterministic execution order should be grouped into a single stage. This ensures they are applied sequentially and in the exact order they are defined.  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } )   Grouping related changes into a single stage:  Ensures predictable, sequential executionAvoids ambiguity from cross-stage execution timingEliminates the need to manage inter-stage dependenciesKeeps setup simple and easier to maintainSupports mixing all types of changes (Kafka, MongoDB, SQL, S3, etc.) in a well-defined order  Advanced scenarios If your application benefits from separating changes‚Äîfor example, by module or lifecycle‚Äîyou can define Multiple Stages (Advanced). Just remember: deterministic execution is guaranteed only within a stage, not across them.  ","version":"1.0.0","tagName":"h3"},{"title":"Placing your changes‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#placing-your-changes","content":" We strongly recommend placing all your changes ‚Äî code-based and template-based ‚Äî in a single location defined by the @Stage annotation.  Ensures changes are always scanned, regardless of typeAvoids needing two locations if one template-based change requires fallback to codeKeeps everything in one logical location  ","version":"1.0.0","tagName":"h3"},{"title":"Naming Convention for Changes‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#naming-convention-for-changes","content":" To ensure clarity and enforce ordering, we recommend naming changes using the following format:  _20250923_01_CreateClientsTable.java _20250923_02_AaddindexToEmail.yaml _20250924_01_MigrateData.java _20250925_01_ComplexChange.yaml   ORDER: The execution order extracted between the first _ and last _ Recommended format: YYYYMMDD_NN where YYYY=year, MM=month, DD=day, NN=sequence (01-99) CHANGE_NAME: Descriptive name of what the change does  This convention:  Eliminates the need for order in annotations/YAML - the order is extracted from the filenameNatural chronological sorting - files automatically sort by date in foldersClear timeline visibility - instantly see when changes were createdWorks across both code-based and template-based formatsPractical daily limit - 99 changes per day is more than sufficientEnsures consistent naming and project hygiene  tip While Java typically avoids underscores and leading digits, change units are not traditional classes. Prioritizing readability and order is more valuable in this context.  Complete Order Field Rules For detailed rules about order field placement and how filename order works with annotations, see Change Anatomy - Order.  ","version":"1.0.0","tagName":"h3"},{"title":"üõ† Troubleshooting‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#-troubleshooting","content":" ","version":"1.0.0","tagName":"h2"},{"title":"My stage isn't picked up‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#my-stage-isnt-picked-up","content":" Make sure the stage has a location field definedCheck the file path is correct and uses / as a separator, not . in YAMLIf using resource directory paths, make sure the file is placed under src/main/resources/your-dir  ","version":"1.0.0","tagName":"h3"},{"title":"No changes found in stage‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#no-changes-found-in-stage","content":" Verify that the class or YAML file is located in the expected package/directoryFor code-based changes, ensure the class is annotated with @Change or @ChangeFor template-based changes, check file names and YAML formatting ","version":"1.0.0","tagName":"h3"},{"title":"Lock","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/lock","content":"","keywords":"","version":"1.0.0"},{"title":"Configurable properties‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#configurable-properties","content":" Property\tDefault\tDescriptionlockAcquiredForMillis\t60000 (1 min)\tTime the lock remains valid once acquired. Automatically released if not refreshed. lockQuitTryingAfterMillis\t180000 (3 min)\tHow long to retry acquiring the lock if another instance holds it. lockTryFrequencyMillis\t1000 (1 sec)\tInterval between attempts while waiting for the lock. throwExceptionIfCannotObtainLock\ttrue\tWhether Flamingock should fail if the lock can't be acquired. enableRefreshDaemon\ttrue\tWhether to run a background thread that periodically extends the lock.  ","version":"1.0.0","tagName":"h2"},{"title":"Why locking matters‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#why-locking-matters","content":" In distributed systems, multiple app instances may start simultaneously ‚Äî but only one should apply pending changes. Flamingock uses locking to:  Prevent race conditionsEnsure consistent and safe state transitionsGuarantee single execution of each change  info If no pending changes exist, the lock is not acquired and startup proceeds normally.  ","version":"1.0.0","tagName":"h2"},{"title":"Refresh Daemon (safety net)‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#refresh-daemon-safety-net","content":" The refresh daemon is a background thread that extends the lock before it expires. It‚Äôs critical for long-running changes that might exceed the lock duration.  Without the daemon:  A long-running change (e.g., 90s) could outlive a default lock (e.g., 60s)Another instance might acquire the lock prematurely, causing conflict  note By default, Flamingock uses proxy-based injection guards. Before executing any injected dependency, Flamingock verifies that the lock is still valid.  If you're injecting non-critical components (e.g., a local list or stateless helper), you can annotate them with @NonLockGuarded to avoid the proxy overhead.  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration Examples‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#configuration-examples","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Builder‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#builder","content":" Flamingock.builder() .setLockAcquiredForMillis(120000) .setLockQuitTryingAfterMillis(300000) .setLockTryFrequencyMillis(2000) .setThrowExceptionIfCannotObtainLock(true) .setEnableRefreshDaemon(true) ...   ","version":"1.0.0","tagName":"h3"},{"title":"When to tweak Lock settings‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#when-to-tweak-lock-settings","content":" Most projects can use the default configuration. You may need to adjust values if:  You expect long-running changes (increase lockAcquiredForMillis)You run many app instances and want to reduce startup wait (decrease lockTryFrequencyMillis)You want Flamingock to fail fast if it can't acquire a lock (keep throwExceptionIfCannotObtainLock as true)  ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best Practices‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#-best-practices","content":" Keep the refresh daemon enabled, especially for distributed or slow-processing environmentsAvoid setting lockAcquiredForMillis too short if any changes might run longerUse @NonLockGuarded sparingly ‚Äî only when you're sure no side-effects will occur ","version":"1.0.0","tagName":"h2"},{"title":"Builder-based (manual)","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/builder-based-setup","content":"","keywords":"","version":"1.0.0"},{"title":"Import the springboot integration library‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#import-the-springboot-integration-library","content":" Add the Flamingock Spring Boot integration dependency:  GradleMaven implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#version-compatibility","content":" Check Version Compatibility  ","version":"1.0.0","tagName":"h3"},{"title":"Configure setup and build Flamingock manually‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#configure-setup-and-build-flamingock-manually","content":" With the manual setup, you first need to configure Flamingock using @EnableFlamingock annotation with setup = SetupType.BUILDER, then manually configure and run Flamingock using the builder API.  ","version":"1.0.0","tagName":"h2"},{"title":"1. Configure the annotation‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#1-configure-the-annotation","content":" @EnableFlamingock( setup = SetupType.BUILDER, stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @Configuration public class FlamingockConfig { // Configuration class }   ","version":"1.0.0","tagName":"h3"},{"title":"2. Manual builder configuration‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#2-manual-builder-configuration","content":" With the manual setup, you are responsible for configuring and running Flamingock using the builder API. This includes:  Providing your configuration (e.g., lock settings, metadata) directly via the builderRegistering the required platform components using .addDependency(...)ApplicationContextApplicationEventPublisher  FlamingockBuilder builder = Flamingock .setLockAcquiredForMillis(120000) // example config .addDependency(applicationContext) .addDependency(applicationEventPublisher);   info Platform components are registered using the same .addDependency(...) method used for change unit dependencies. For details, see the Context and dependencies page.  ","version":"1.0.0","tagName":"h3"},{"title":"Overriding Spring-provided dependencies‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#overriding-spring-provided-dependencies","content":" When using the builder-based setup, Flamingock will attempt to resolve dependencies using the Spring context.  However, if you manually register a dependency via .addDependency(...), that dependency will take precedence over anything resolved from the Spring context. This gives you fine-grained control when you want to:  Override a Spring-managed bean with a custom instanceInject mock or test-specific versions of servicesProvide external or non-Spring-managed components directly  builder .addDependency(customClientService) // Overrides Spring's bean of same type .addDependency(applicationContext); // Registers Spring context for base dependency injection   In a nutshell, Flamingock resolves dependencies using the following order:  Manually added dependencies via .addDependency(...)Beans from the Spring context (if ApplicationContext was registered)  ","version":"1.0.0","tagName":"h2"},{"title":"Running Flamingock‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#running-flamingock","content":" Once you've configured the builder, you can choose how to execute Flamingock:  ","version":"1.0.0","tagName":"h2"},{"title":"Option 1: Run manually‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#option-1-run-manually","content":" You can run Flamingock manually:  builder.build().run();   ","version":"1.0.0","tagName":"h3"},{"title":"Option 2: Expose as a Spring Bean‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#option-2-expose-as-a-spring-bean","content":" Alternatively, you can integrate Flamingock into the Spring Boot lifecycle by exposing it as an ApplicationRunner or InitializingBean:  @Bean public ApplicationRunner flamingockRunner() { return SpringbootUtil.toApplicationRunner(builder.build()); }   Or:  @Bean public InitializingBean flamingockRunner() { return SpringbootUtil.toInitializingBean(builder.build()); }   This ensures Flamingock executes automatically as part of the Spring Boot startup sequence.  ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#next-steps","content":" Want to avoid manual setup? Explore the Automatic Setup for automatic integration with minimal code. ","version":"1.0.0","tagName":"h2"},{"title":"GraalVM support","type":0,"sectionRef":"#","url":"/docs/frameworks/graalvm","content":"","keywords":"","version":"1.0.0"},{"title":"How it works‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#how-it-works","content":" When building your application, Flamingock's annotation processor:  Scans for all annotated code-based changes (@Change)Discovers template-based changes from sourcesPackage and resourcesDirGenerates metadata files containing all required classes for reflection  At native image generation time, Flamingock‚Äôs GraalVM feature picks up these files and registers the required types with GraalVM, so they‚Äôre available at runtime.  tip Learn more about the basics of GraalVM native image compilation in the GraalVM Native Image basics guide.  ","version":"1.0.0","tagName":"h2"},{"title":"Step-by-step setup‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#step-by-step-setup","content":" ","version":"1.0.0","tagName":"h2"},{"title":"1. Add Flamingock GraalVM dependency‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#1-add-flamingock-graalvm-dependency","content":" GradleMaven implementation(&quot;io.flamingock:flamingock-graalvm:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h3"},{"title":"2. Add plugin management (only for Gradle)‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#2-add-plugin-management-only-for-gradle","content":" If using Gradle, ensure your settings.gradle.kts includes:  pluginManagement { repositories { mavenLocal() gradlePluginPortal() mavenCentral() } }   ","version":"1.0.0","tagName":"h3"},{"title":"3. Add GraalVM resource config‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#3-add-graalvm-resource-config","content":" Create a file named resource-config.json in your project root:  { &quot;resources&quot;: { &quot;includes&quot;: [ { &quot;pattern&quot;: &quot;META-INF/flamingock/metadata.json&quot; } ] } }   info This file declares which resource files should be accessible to your native image. You can add other application-specific resources here as needed. See the GraalVM resource configuration documentation for more details.  ","version":"1.0.0","tagName":"h3"},{"title":"4. Build the application‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#4-build-the-application","content":" ./gradlew clean build   Expected build output‚Äã  During the build process, Flamingock will emit logs similar to the following ‚Äî indicating successful annotation processing and metadata generation.  Click to see the expected logs GradleMaven &gt; Task :compileJava Note: [Flamingock] Starting Flamingock annotation processor initialization. Note: [Flamingock] 'resources' parameter NOT passed. Using default 'src/main/resources' Note: [Flamingock] 'sources' parameter NOT passed. Searching in: '[src/main/java, src/main/kotlin, src/main/scala, src/main/groovy]' Note: [Flamingock] Reading flamingock pipeline from file: 'src/main/resources/flamingock/pipeline.yaml' Note: [Flamingock] Initialization completed. Processed templated-based changes. Note: [Flamingock] Searching for code-based changes (Java classes annotated with @Change or legacy @Change annotations) Note: [Flamingock] Reading flamingock pipeline from file: 'src/main/resources/flamingock/pipeline.yaml' Note: [Flamingock] Finished processing annotated classes and generating metadata. Note: [Flamingock] Final processing round detected - skipping execution.   ","version":"1.0.0","tagName":"h3"},{"title":"5. Create the native image‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#5-create-the-native-image","content":" native-image \\ --no-fallback \\ --features=io.flamingock.graalvm.RegistrationFeature \\ -H:ResourceConfigurationFiles=resource-config.json \\ -H:+ReportExceptionStackTraces \\ --initialize-at-build-time=org.slf4j.simple \\ -jar build/libs/your-app.jar   What these options do:‚Äã  --features=io.flamingock.graalvm.RegistrationFeature: Registers all Flamingock-related classes for reflection using metadata gathered during build time.-H:ResourceConfigurationFiles=resource-config.json: Informs GraalVM of required static resource files to include.--initialize-at-build-time: ‚Äì Optional. Build‚Äëtime init for listed classes/packages (freeze static state; faster start; avoids early reflection/I/O). Flamingock does not require specific entries. Use only if a library benefits (e.g., logging). Example: --initialize-at-build-time=org.slf4j.impl,org.slf4j.simple. Omit if unsure.  Expected native image output‚Äã  When creating the native image, you should see log output from Flamingock's GraalVM RegistrationFeature, confirming that Flamingock successfully scanned and registered internal classes, templates, system modules, and user-defined change units.  The actual output may differ slightly depending on the modules you‚Äôve included, but it should look similar to the following:  Click to see the expected logs - io.flamingock.graalvm.RegistrationFeature [Flamingock] Starting GraalVM classes registration [Flamingock] Starting registration of internal classes Registering class: io.flamingock.core.task.TaskDescriptor Registering class: io.flamingock.core.task.AbstractTaskDescriptor Registering class: io.flamingock.core.preview.PreviewPipeline Registering class: io.flamingock.core.preview.PreviewStage Registering class: io.flamingock.core.preview.CodePreviewChange Registering class: io.flamingock.core.preview.CodePreviewLegacyChange Registering class: io.flamingock.core.preview.PreviewMethod Registering class: io.flamingock.core.api.template.ChangeTemplateConfig Registering class: io.flamingock.core.preview.TemplatePreviewChange Registering class: io.flamingock.core.pipeline.Pipeline Registering class: io.flamingock.core.pipeline.LoadedStage Registering class: io.flamingock.core.task.loaded.AbstractLoadedTask Registering class: io.flamingock.core.task.loaded.AbstractReflectionLoadedTask Registering class: io.flamingock.core.task.loaded.AbstractLoadedChange Registering class: io.flamingock.core.task.loaded.CodeLoadedChange Registering class: io.flamingock.core.task.loaded.TemplateLoadedChange Registering class: java.nio.charset.CoderResult [Flamingock] Completed internal classes [Flamingock] Starting registration of templates Registering class: io.flamingock.core.api.template.TemplateFactory Registering class: io.flamingock.core.api.template.ChangeTemplate Registering class: io.flamingock.core.api.template.AbstractChangeTemplate Registering class: io.flamingock.template.mongodb.MongoChangeTemplate Registering class: io.flamingock.template.mongodb.model.MongoOperation Registering class: io.flamingock.template.mongodb.MongoChangeTemplateConfig [Flamingock] Completed templates [Flamingock] Starting registration of system modules Registering class: io.flamingock.core.engine.audit.importer.changeunit.MongockImporterChange Registering class: io.flamingock.core.engine.audit.importer.ImporterModule [Flamingock] Completed system modules [Flamingock] Starting registration of user classes Registering class: io.flamingock.changes._1_create_clients_collection_change Registering class: io.flamingock.changes._2_insertClientFederico_change Registering class: io.flamingock.changes._3_insert_client_jorge [Flamingock] Completed user classes [Flamingock] Completed GraalVM classes registration   tip For more information on image creation and options, refer to the GraalVM build overview documentation.  ","version":"1.0.0","tagName":"h3"},{"title":"6. Run the native image‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#6-run-the-native-image","content":" ./your-app   ","version":"1.0.0","tagName":"h3"},{"title":"Example project‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#example-project","content":" We have built a complete example project for GraalVM that demonstrates:  A working Flamingock configuration with GraalVMSample change unitsProper resource configurationNative image generation process  You can use this example as a reference implementation while following the steps in this guide. ","version":"1.0.0","tagName":"h2"},{"title":"Automatic Setup","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup","content":"","keywords":"","version":"1.0.0"},{"title":"Import the springboot integration library‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#import-the-springboot-integration-library","content":" Add the Flamingock Spring Boot integration dependency:  GradleMaven implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#version-compatibility","content":" The flamingock-springboot-integration artifact is compatible with both Spring Boot 2.x and 3.x. See Version Compatibility for details.  ","version":"1.0.0","tagName":"h3"},{"title":"Configure setup and activate integration‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#configure-setup-and-activate-integration","content":" To activate the integration, add @EnableFlamingock to any class in your application (commonly on your main class or a configuration class):  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }   The @EnableFlamingock annotation enables automatic Spring Boot integration, which:  Detect and use Spring‚Äôs ApplicationContext and ApplicationEventPublisherLoads Flamingock configuration directly from your Spring Boot config fileAutomatically configures the runner (e.g., ApplicationRunner or InitializingBean)Processes the setup configuration from the annotation  ","version":"1.0.0","tagName":"h2"},{"title":"Bean registration requirements‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#bean-registration-requirements","content":" With automatic setup, Flamingock needs access to your target systems and (for Community Edition) audit stores. Since these aren't configured directly via the builder, they must be registered as Spring beans:  Example target system bean registration:  @Bean public NonTransactionalTargetSystem redisTargetSystem() { return new NonTransactionalTargetSystem(&quot;redis-cache-id&quot;); }   Flamingock will automatically detect and use these beans during execution.  ","version":"1.0.0","tagName":"h2"},{"title":"Providing configuration‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#providing-configuration","content":" Runtime configuration is defined using standard Spring Boot configuration files. Use the flamingock section for all core and edition-specific options.  flamingock: lockAcquiredForMillis: 1200 runnerType: InitializingBean # other configuration...   info If the runnerType property is not provided, Flamingock defaults to using ApplicationRunner.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#next-steps","content":" Want full control over the builder? See Builder-based setupExplore Spring Boot profile supportLearn about Flamingock lifecycle events ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot profiles","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/profiles","content":"","keywords":"","version":"1.0.0"},{"title":"What is a Spring profile?‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#what-is-a-spring-profile","content":" Spring profiles provide a way to segregate parts of your application configuration and behavior based on the active environment.  You can define profiles like dev, test, staging, or prod, and activate one or more of them using any of the following methods:  Inside application.yaml or application.properties: spring: profiles: active: dev,staging Using profile-specific configuration files like application-dev.yaml or application-prod.yaml As command-line arguments: --spring.profiles.active=dev,staging Through environment variables: SPRING_PROFILES_ACTIVE=dev,staging   When multiple profiles are active, Flamingock evaluates each change unit against all active profiles, and includes it if any match.  ","version":"1.0.0","tagName":"h2"},{"title":"How Flamingock uses profiles‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#how-flamingock-uses-profiles","content":" Flamingock automatically retrieves the active profiles from Spring‚Äôs ApplicationContext. You don‚Äôt need to manually provide them.  You can then annotate any change unit with Spring‚Äôs native @Profile annotation to control whether it runs:  @Change(id = &quot;add-test-data&quot;, order = &quot;20250207_01&quot;) @Profile(&quot;dev&quot;) public class AddTestDataChange { // will only run if &quot;dev&quot; profile is active }   Flamingock applies the same logic as Spring Boot when evaluating whether a change unit should run.  ","version":"1.0.0","tagName":"h2"},{"title":"Multiple profiles‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#multiple-profiles","content":" You can declare multiple profiles in a single @Profile expression:  @Profile({&quot;dev&quot;, &quot;staging&quot;})   This change unit will run if any of the listed profiles is active.  ","version":"1.0.0","tagName":"h2"},{"title":"Excluding profiles‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#excluding-profiles","content":" To exclude a change unit from a specific profile, you can use Spring Expression Language (SpEL):  @Profile(&quot;!prod&quot;)   This will run the change unit in all environments except prod.  ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#-best-practices","content":" Use profiles to isolate test data, preview features, or tenant-specific migrationsAvoid mixing profile-specific logic inside a single change unit ‚Äî split them into separate classesKeep profile names consistent across your team and environments (e.g., use dev everywhere, not development, dev-env, etc.)Consider grouping related change units under a shared profile for easier activation ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot integration","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Why integrate Flamingock with Spring Boot?‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#why-integrate-flamingock-with-spring-boot","content":" Using Flamingock with Spring Boot allows you to:  Inject Spring-managed beans directly into change unitsConfigure Flamingock via Spring Boot's native configuration filesUse Spring profiles to control when specific change units runReceive execution lifecycle events using ApplicationEventPublisherChoose between Spring Boot lifecycle hooks (ApplicationRunner or InitializingBean) to run Flamingock.  ","version":"1.0.0","tagName":"h2"},{"title":"Two setup approaches‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#two-setup-approaches","content":" Flamingock offers two ways to integrate with Spring Boot, depending on how much control you want over the configuration and lifecycle.  ","version":"1.0.0","tagName":"h2"},{"title":"Builder-based setup (manual)‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#builder-based-setup-manual","content":" This approach gives you full control and uses the standard Flamingock builder with @EnableFlamingock(setup = SetupType.BUILDER). You manually inject the required Spring Boot components(ApplicationContext and ApplicationEventPublisher) as well as any Flamingock core configuration.  In addition, you can register other dependencies manually ‚Äî these will take precedence over beans from the Spring context when resolving what to inject into change units.  This is recommended for advanced users or highly customized environments.  See: Builder-based setup  ","version":"1.0.0","tagName":"h3"},{"title":"Automatic setup‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#automatic-setup","content":" This is the simplest way to enable Flamingock in Spring Boot. Just annotate any class with @EnableFlamingock (commonly your main application class), and Flamingock will:  Auto-detect the application context and event publisherRead configuration from Spring Boot config filesAutomatically wire the FlamingockRunner beanProcess the setup configuration from the annotation  Ideal for most users who prefer convention over configuration.  See: Automatic setup  ","version":"1.0.0","tagName":"h3"},{"title":"Runner strategy: ApplicationRunner vs InitializingBean‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#runner-strategy-applicationrunner-vs-initializingbean","content":" Flamingock supports two strategies for executing its process during Spring Boot startup. You can control this via the runnerType property in your Spring configuration (flamingock.runnerType), or programmatically if using the manual builder.  ","version":"1.0.0","tagName":"h2"},{"title":"Comparison‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#comparison","content":" \tApplicationRunner\tInitializingBeanPhase\tAfter all beans are initialized ‚Äî just before the app is marked as started\tDuring bean initialization ‚Äî before the app is considered started Context availability\t‚úÖ Full ‚Äî all Spring beans and profiles available\t‚ö†Ô∏è Limited ‚Äî not all beans may be available Typical use case\tMost common ‚Äî recommended for production environments\tFor lightweight internal logic or strict startup ordering Events fully supported?\t‚úÖ Yes\t‚ö†Ô∏è Risky ‚Äî context may not be fully ready Spring beans available in change units\t‚úÖ Yes\t‚ö†Ô∏è May fail or be incomplete  ","version":"1.0.0","tagName":"h3"},{"title":"Startup failure behavior‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#startup-failure-behavior","content":" If Flamingock encounters an error during execution ‚Äî whether using ApplicationRunner or InitializingBean ‚Äî the Spring Boot application will fail to start.  This is intentional: Flamingock runs before the application is marked as ready. In deployment platforms such as Kubernetes, a failure at this stage will:  Prevent the container from reaching a Ready stateTrigger restart policies, health checks, or rollbacks as configuredEnsure that the system is never exposed in a partially initialized or inconsistent state  This behavior ensures your application only starts when all change units have been applied successfully.  ","version":"1.0.0","tagName":"h3"},{"title":"Dependency‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#dependency","content":" To use the Spring Boot integration, add the following dependency:  GradleMaven implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#version-compatibility","content":" The flamingock-springboot-integration artifact is compatible with both Spring Boot 2.x and 3.x. Your project's Spring Boot version determines the appropriate Spring framework and JDK requirements.  Package Name\tSpring Boot Versionflamingock-springboot-integration\t2.x and 3.x  ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#white_check_mark-best-practices","content":" Consider the following recommendations to get the most out of Flamingock‚Äôs Spring Boot integration:  Prefer ApplicationRunner as your runner strategy It ensures Flamingock runs after the application context is fully initialized, giving it access to all beans, profiles, and configuration. It also integrates more safely with event publishing and external monitoring tools like Actuator or Prometheus. Use automatic setup (@EnableFlamingock) for simpler setups Unless you have advanced needs (such as injecting non-Spring-managed dependencies), the automatic setup provides a clean and reliable integration path. Use Spring profiles to scope change units Profiles let you control when specific change units execute, avoiding the need for environment-specific pipelines. Avoid manual execution unless absolutely necessary Letting Spring handle the execution via ApplicationRunner or InitializingBean ensures Flamingock runs at the appropriate time in your application lifecycle. Register custom platform components using .addDependency(...) only when required Most applications using automatic setup will not need to register components manually. ","version":"1.0.0","tagName":"h2"},{"title":"Target systems vs audit store","type":0,"sectionRef":"#","url":"/docs/overview/audit-store-vs-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"The dual-system architecture‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#the-dual-system-architecture","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Target systems: where changes are applied‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#target-systems-where-changes-are-applied","content":" Target systems are your business systems where actual changes happen:  Examples: User database, Product catalog, Order management system, Kafka topics, S3 buckets, REST APIsPurpose: Store and process your business data and configurationsModified by: Your business logic through ChangesConfiguration: See Target Systems for technical setup  ","version":"1.0.0","tagName":"h3"},{"title":"Audit store: where execution is tracked‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#audit-store-where-execution-is-tracked","content":" Audit store is Flamingock's dedicated system for tracking what happened:  Examples: Flamingock Cloud backend or dedicated audit table/collection in the user's database.Purpose: Record execution history, compliance data, issue trackingModified by: Flamingock framework automatically (never your code)Configuration: See Audit Stores for technical setup  ","version":"1.0.0","tagName":"h3"},{"title":"Why this separation matters‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#why-this-separation-matters","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Enterprise safety benefits‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#enterprise-safety-benefits","content":" Complete Audit Trail: Every change attempt is recorded regardless of business system failuresGovernance Separation: Business data and compliance data have different access patternsRecovery Capabilities: Operations team can resolve issues by reading audit state, not business dataCompliance Independence: Audit integrity is maintained even during business system issues  ","version":"1.0.0","tagName":"h3"},{"title":"Target system types‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#target-system-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Transactional target systems‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#transactional-target-systems","content":" Systems with native ACID transaction support (PostgreSQL, MySQL, MongoDB 4.0+):  Safety and coordination:  Community Audit Stores: Reliable execution tracking and recovery capabilitiesCloud Edition: Advanced coordination protocols ensure complete recoverability  ","version":"1.0.0","tagName":"h3"},{"title":"Non-transactional target systems‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#non-transactional-target-systems","content":" Systems without native transaction support (Kafka, S3, REST APIs, File Systems):  Safety and coordination:  Community Audit Stores: Reliable execution tracking and rollback-based recoveryCloud Edition: Enhanced recoverability with custom validation options  ","version":"1.0.0","tagName":"h3"},{"title":"Audit store types‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#audit-store-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Cloud Edition audit store‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#cloud-edition-audit-store","content":" Flamingock Cloud provides a fully managed audit store with superior synchronization and recovery through advanced coordination protocols, real-time dashboards, advanced analytics, and multi-environment governance.  ","version":"1.0.0","tagName":"h3"},{"title":"Community Audit Stores audit store‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#community-audit-stores-audit-store","content":" User-provided audit store (MongoDB, DynamoDB, Couchbase) that ensures complete execution tracking, prevents duplicate executions, and provides basic recovery capabilities. See Audit stores for setup.  ","version":"1.0.0","tagName":"h3"},{"title":"How it works‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#how-it-works","content":"  Your Changes: ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ 1. Change[UpdateKafkaSchema] ‚Üí Target System[Kafka Schema Registry] ‚îÇ ‚îÇ 2. Change[SeedKafkaEvents] ‚Üí Target System[Kafka Topics] ‚îÇ ‚îÇ 3. Change[AddUserStatus] ‚Üí Target System[User Database] ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Flamingock ‚îÇ ‚îÇ (Orchestrator) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ Executes sequentially ‚îÇ Change #1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê (UpdateKafkaSchema) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ñº ‚ñº ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Target System: ‚îÇ ‚îÇ Audit Store ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Schema Registry ‚îÇ ‚îÇ ‚îÇ Records: ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ #1 applied ‚îÇ ‚îÇ ‚îÇ (applies change) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ Change #2 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê (SeedKafkaEvents) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ñº ‚ñº ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Target System: ‚îÇ ‚îÇ Audit Store ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Kafka Topics ‚îÇ ‚îÇ ‚îÇ Records: ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ #2 applied ‚îÇ ‚îÇ ‚îÇ (applies change) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ Change #3 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê (AddUserStatus) ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ñº ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Target System: ‚îÇ ‚îÇ Audit Store ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ User Database ‚îÇ ‚îÇ ‚îÇ Records: ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ #3 applied ‚îÇ ‚îÇ (applies change) ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   The Flow:  You create Changes - Define what changes need to happenFlamingock orchestrates - Safely applies changes across all your systemsTarget systems evolve - Your business systems get updatedAudit store tracks everything - Complete history for compliance and recovery  ","version":"1.0.0","tagName":"h2"},{"title":"Key takeaways‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#key-takeaways","content":" ","version":"1.0.0","tagName":"h2"},{"title":"For developers‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#for-developers","content":" Target systems: Where your business logic runs and makes changesAudit store: Automatically managed by Flamingock for tracking and complianceImplementation: See Target Systems and Audit Stores  ","version":"1.0.0","tagName":"h3"},{"title":"For architects‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#for-architects","content":" Clean separation: Business logic separated from execution trackingEnterprise scalability: Architecture supports compliance, governance, multi-environmentFlexibility: Works with any target system type (transactional, non-transactional, hybrid)  ","version":"1.0.0","tagName":"h3"},{"title":"For operations‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#for-operations","content":" Issue resolution: Tools operate on audit store, you fix target systemsCompliance: Complete audit trail independent of business system availabilityRecovery: Always know the state, even during complex failure scenarios  Bottom Line: This dual-system architecture is what enables Flamingock to provide enterprise-grade safety and governance capabilities that traditional tools cannot match. ","version":"1.0.0","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/overview/Introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Core principles‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#core-principles","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Safety by default‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#safety-by-default","content":" When Flamingock cannot guarantee a safe outcome, it stops and requires manual intervention. This prevents silent data corruption and ensures predictable deployments.  ","version":"1.0.0","tagName":"h3"},{"title":"Complete auditability‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#complete-auditability","content":" Every change execution is tracked in an audit store, providing a complete history of what was applied, when, by whom, and with what result.  ","version":"1.0.0","tagName":"h3"},{"title":"Recovery strategies‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#recovery-strategies","content":" Configurable recovery mechanisms determine how Flamingock handles failures:  Manual intervention (default): Stops on failure and requires human reviewAlways retry: Automatically retries idempotent operations  ","version":"1.0.0","tagName":"h3"},{"title":"Target systems‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#target-systems","content":" Flamingock can apply changes to any external service your application interacts with. Examples include:  Message brokers: Kafka, RabbitMQ, AWS SQSCloud services: S3, Lambda, API GatewayAPIs: REST endpoints, GraphQL schemasConfiguration systems: Feature flags, vault secretsDatabases: SQL (PostgreSQL, MySQL) and NoSQL (MongoDB, DynamoDB)And any other external system your application needs to evolve  ","version":"1.0.0","tagName":"h2"},{"title":"Architecture overview‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#architecture-overview","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Changes‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#changes","content":" The fundamental unit of change. Each Change:  Has a unique identifier and execution orderTargets a specific systemContains execution and rollback logicIs executed exactly once  ","version":"1.0.0","tagName":"h3"},{"title":"Audit store vs target system‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#audit-store-vs-target-system","content":" Audit store: Where Flamingock tracks execution history (managed by Flamingock)Target system: Where your business changes are applied (any external service your application interacts with)  ","version":"1.0.0","tagName":"h3"},{"title":"Execution flow‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#execution-flow","content":" Application startup triggers FlamingockFlamingock discovers all ChangesChecks audit store for pending changesAcquires distributed lockExecutes changes in orderRecords results in audit storeHandles failures according to recovery strategy  ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/overview/Introduction#next-steps","content":" Quick start - Minimum setup to run FlamingockCore concepts - Detailed explanation of key conceptsAudit store vs target system - Understanding the dual-system architecture ","version":"1.0.0","tagName":"h2"},{"title":"Core concepts","type":0,"sectionRef":"#","url":"/docs/overview/core-concepts","content":"","keywords":"","version":"1.0.0"},{"title":"Changes‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#changes","content":" Changes are the fundamental building blocks of Flamingock's Change-as-Code architecture. They represent atomic and immutable versioned changes applied to target systems with complete safety guarantees and audit capabilities.  Each Change includes:  Unique identity: ID, order, and metadata for trackingTarget system: Where the changes is applied toExecution logic: The actual change implementationRollback capability: Compensation logic for governance and undo operationsRecovery strategy: Configurable behavior for handling failuresImmutability: Once applied, a Change must never be modified  Changes can be implemented in two forms:  Code-based: Java classes with annotations that contain the change logicTemplate-based: Declarative low-code approach using YAML configurations  For a deeper dive around Changes, see the Changes and best practices section.  ","version":"1.0.0","tagName":"h2"},{"title":"Templates‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#templates","content":" Templates provide a reusable layer on top of Changes for common change patterns. When you have multiple changes that share similar logic (for example, executing SQL statements), templates allow you to abstract that common logic and reuse it.  With templates, you create multiple Changes using a declarative, low-code approach. Each Change uses a template and passes its specific configuration. For example, an SQL template receives the SQL statement as configuration, executes it, and handles errors consistently.  This approach is particularly useful for:  Standardizing common operations across your codebaseReducing boilerplate codeEnabling non-developers to define changes through configuration  For more information about templates, see the Templates section.  ","version":"1.0.0","tagName":"h2"},{"title":"Recovery strategies‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#recovery-strategies","content":" Recovery strategies define how Flamingock responds when a Change fails during execution. They determine whether the system should stop and wait for manual intervention or automatically retry the operation.  Flamingock provides two main strategies:  Manual intervention (default): Stops execution and requires human review when failures occurAlways retry: Automatically retries the change on the next execution attempt  The choice of strategy depends on whether your changes are idempotent and how critical they are to your system's integrity.  For detailed configuration and implementation, see the Recovery strategies section.  ","version":"1.0.0","tagName":"h2"},{"title":"Audit store‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#audit-store","content":" The audit store is where Flamingock records metadata about change executions. Its purpose is to track which Changes have been executed, when they ran, and their outcomes. This ensures idempotency, enables rollbacks, and provides audit capabilities. The audit store is managed entirely by Flamingock - your code never directly interacts with it.  info In Cloud Edition, the audit store is automatically provided - no configuration needed in your builder. Community Edition users must configure their own audit store.  ","version":"1.0.0","tagName":"h2"},{"title":"Target system‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#target-system","content":" The target system is where your actual business changes are applied. These are the systems your Changes modify - databases, message queues, APIs, configuration services, etc. Each Change declares which target system it operates on.  For more details about how these systems work together, see the Audit store vs target system section.  ","version":"1.0.0","tagName":"h2"},{"title":"Transaction handling‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#transaction-handling","content":" Flamingock adapts its behavior based on the transactional capabilities of your target systems:  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional target systems‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#transactional-target-systems","content":" Systems that support ACID transactions, such as MongoDB 4.0+, PostgreSQL, MySQL, or other transactional stores. When working with these systems, Flamingock can leverage native transaction support to ensure atomicity of changes. If a failure occurs mid-execution, the native rollback mechanism ensures no partial changes are left in the system.  ","version":"1.0.0","tagName":"h3"},{"title":"Non-transactional target systems‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#non-transactional-target-systems","content":" Systems like Kafka, S3, REST APIs, or file systems that don't support transactions. For these systems, Flamingock relies on explicit rollback methods and careful change design to maintain consistency. Recovery strategies become particularly important for handling failures in non-transactional contexts.  For implementation details, see the Transactions section.  ","version":"1.0.0","tagName":"h3"},{"title":"Stages‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#stages","content":" Stages organize your changes into logical groups within Flamingock's execution pipeline. By default, you work with a single stage that contains all your changes, ensuring they execute sequentially in a deterministic order.  Key characteristics:  Changes within a stage execute sequentially with guaranteed orderMost applications only need a single stageMultiple stages can be used for modular architectures, but execution order between stages is not guaranteedEach stage defines where to find its changes (package or directory location)  For detailed information about stages and advanced configurations, see the Setup and stages section. ","version":"1.0.0","tagName":"h2"},{"title":"Coming from Mongock","type":0,"sectionRef":"#","url":"/docs/resources/coming-from-mongock","content":"Coming from Mongock üöÄ Transition Support Coming Soon We're actively working on a smooth transition path from Mongock to Flamingock. Our team is developing the mechanisms and best practices to make your transition as easy as possible, following Flamingock's architectural principles. Both the transition features and the complete guide will be available soon. Stay tuned for updates!","keywords":"","version":"1.0.0"},{"title":"Quick start","type":0,"sectionRef":"#","url":"/docs/overview/quick-start","content":"","keywords":"","version":"1.0.0"},{"title":"1. Set up Flamingock in your project‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#1-set-up-flamingock-in-your-project","content":" Add Flamingock to your build:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community&quot;) annotationProcessor(&quot;io.flamingock:flamingock-processor:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"2. Create target systems‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#2-create-target-systems","content":" Target systems represent the external systems Flamingock will apply your changes to. They are configured in the builder and shared across Changes.  For our example:  A MySQL database (mysql-inventory)An S3 bucket service (aws-s3)A Kafka cluster (kafka)  var sql = new SqlTargetSystem(&quot;mysql-inventory&quot;).withDatasource(ds); var s3 = new NonTransactionalTargetSystem(&quot;aws-s3-id&quot;); var kafka = new NonTransactionalTargetSystem(&quot;kafka-id&quot;);   See Target systems for more details.  ","version":"1.0.0","tagName":"h2"},{"title":"3. Define your first Changes‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#3-define-your-first-changes","content":" Each Change represents a single change. For our example, we'll define three:  MySQL: Add a column category to productsS3: Create a product-images bucketKafka: Create a stock-updates topic  Changes can be:  Code-based: Java classes with annotationsTemplate-based: YAML files using reusable templates  Template basedCode based id: add-product-category author: team order: &quot;20250923_01&quot; targetSystem: mysql-inventory template: sql-template apply: | ALTER TABLE products ADD COLUMN category VARCHAR(255) rollback: | ALTER TABLE products DROP COLUMN category   For more details, see Core concepts.  ","version":"1.0.0","tagName":"h2"},{"title":"4. Configure stages‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#4-configure-stages","content":" Flamingock organizes your changes in stages. Most applications only need one stage:  @EnableFlamingock( stages = { @Stage(location = &quot;com.company.inventory.changes&quot;) } ) public class App {}   location: Where Flamingock should look for changes (package or resources)name: Optional ‚Äî defaults to the location name  See Stages for more details and advanced setups.  ","version":"1.0.0","tagName":"h2"},{"title":"5. Configure Flamingock runtime‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#5-configure-flamingock-runtime","content":" Finally, configure Flamingock before running your application.  Community Audit Stores: Set your audit store (MongoDB, DynamoDB, Couchbase, etc.) in the builder Cloud Edition (coming soon): Provide your API token, service name, and environment  CommunityCloud (coming soon) Flamingock.builder() .setAuditStore(new MongoDBSyncAuditStore(mongoClient, mongoDatabase)) .addTargetSystems(sql, s3, kafka) .build() .run();   ","version":"1.0.0","tagName":"h2"},{"title":"6. Run your application‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#6-run-your-application","content":" When your service starts, Flamingock automatically:  Discovers your ChangesChecks pending changesExecutes them safely in orderRecords everything in the audit store  If Flamingock cannot guarantee a safe outcome, it stops and alerts you. Safety first.  ","version":"1.0.0","tagName":"h2"},{"title":"Example output‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#example-output","content":" Click to see the expected logs GradleMaven &gt; Task :compileJava Note: [Flamingock] Starting Flamingock annotation processor initialization. Note: [Flamingock] 'resources' parameter NOT passed. Using default 'src/main/resources' Note: [Flamingock] 'sources' parameter NOT passed. Searching in: '[src/main/java, src/main/kotlin, src/main/scala, src/main/groovy]' Note: [Flamingock] Reading flamingock setup from annotation configuration Note: [Flamingock] Initialization completed. Processed templated-based changes. Note: [Flamingock] Searching for code-based changes (Java classes annotated with @Change annotations) Note: [Flamingock] Reading flamingock setup from annotation configuration Note: [Flamingock] Finished processing annotated classes and generating metadata. Note: [Flamingock] Final processing round detected - skipping execution.   ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/overview/quick-start#next-steps","content":" Spring Boot integrationConfiguration optionsRecovery and safety ","version":"1.0.0","tagName":"h2"},{"title":"Safety and Recovery","type":0,"sectionRef":"#","url":"/docs/safety-and-recovery/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Safety-first philosophy‚Äã","type":1,"pageTitle":"Safety and Recovery","url":"/docs/safety-and-recovery/introduction#safety-first-philosophy","content":" In the rare cases where Flamingock cannot guarantee a safe outcome, it stops execution and requires explicit resolution rather than risking data corruption or system inconsistency. This approach ensures you always know the exact state of your systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Recovery strategies‚Äã","type":1,"pageTitle":"Safety and Recovery","url":"/docs/safety-and-recovery/introduction#recovery-strategies","content":" Flamingock provides two recovery strategies to handle execution failures:  ","version":"1.0.0","tagName":"h2"},{"title":"Manual intervention (default)‚Äã","type":1,"pageTitle":"Safety and Recovery","url":"/docs/safety-and-recovery/introduction#manual-intervention-default","content":" When it activates: Any failure where the outcome is uncertainWhat happens: Execution stops and requires human review before continuingUse case: When safety is prioritized over automation  ","version":"1.0.0","tagName":"h3"},{"title":"Always retry‚Äã","type":1,"pageTitle":"Safety and Recovery","url":"/docs/safety-and-recovery/introduction#always-retry","content":" When it activates: Any failure, automatically retrying on next executionWhat happens: Continues attempting the change until successfulUse case: When changes are idempotent and safe to retry  ","version":"1.0.0","tagName":"h3"},{"title":"How it works‚Äã","type":1,"pageTitle":"Safety and Recovery","url":"/docs/safety-and-recovery/introduction#how-it-works","content":" Change execution - Flamingock attempts to execute a ChangeFailure detection - If execution fails, the recovery strategy determines next stepsStrategy application - Either automatic retry or manual intervention workflowIssue resolution - For manual intervention, use CLI tools to investigate and resolve  ","version":"1.0.0","tagName":"h2"},{"title":"In this section‚Äã","type":1,"pageTitle":"Safety and Recovery","url":"/docs/safety-and-recovery/introduction#in-this-section","content":" Recovery strategies - Technical details and configurationIssue resolution - Operational workflows for handling issues ","version":"1.0.0","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/docs/resources/examples","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#introduction","content":" The Flamingock Examples repository showcases a growing collection of real-world use cases demonstrating how to use Flamingock in different environments, integrations, and technologies. Each top-level folder represents a target technology and contains one or more self-contained example projects. Each project is designed to be cloned, explored, and run as a reference or foundation for your own implementation.  üëâ GitHub Repository: github.com/flamingock/flamingock-examples  ","version":"1.0.0","tagName":"h2"},{"title":"What you‚Äôll find‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#what-youll-find","content":" Within each technology folder, you‚Äôll find one or more example ‚Äãprojects that demonstrate how to configure Flamingock and apply change units in various scenarios. Each folder contains its own README.md with setup instructions, and each project inside has its own documentation.  Technology Folder\tDescriptionmongodb\tFolder containing Flamingock CE projects using MongoDB as the audit‚Äêlog backend. Each project shows different integration scenarios (standalone Java, Spring Boot, etc.). dynamodb\tFolder containing Flamingock CE projects using Amazon DynamoDB for audit logging. Includes both standalone and Spring Boot examples. couchbase\tFolder containing Flamingock CE projects using Couchbase as the audit‚Äêlog backend.  More examples are planned ‚Äî including PostgreSQL, Redis, LocalStack, Kafka, Spring Native, multi‚Äêmodule projects, and custom runners.  ","version":"1.0.0","tagName":"h2"},{"title":"How to use the examples‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#how-to-use-the-examples","content":" Each example folder and project includes its own README.md with detailed setup and run instructions. In general:  Clone the examples repository git clone https://github.com/flamingock/flamingock-examples.git This repository contains all the example folders for various technologies. Navigate to the technology folder of interest cd flamingock-examples/s3 Replace s3 with the folder name for the technology you are interested in (e.g., kafka, mongodb, dynamodb, etc.). Navigate to a specific example project cd s3 Each folder contains one or more projects. Move into the project folder that matches your use case or environment. Run the example For standalone Java applications: ./gradlew run For Spring Boot projects: ./gradlew bootRun Follow any additional instructions in the project‚Äôs README.md. Some examples may use Testcontainers or LocalStack; if so, ensure Docker is running on your machine.  ","version":"1.0.0","tagName":"h2"},{"title":"Who this is for‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#who-this-is-for","content":" New users: Learn by example. Pick an example that matches your tech stack and explore how Flamingock integrates with your environment.Advanced users: Discover integration patterns with external systems like Kafka, AWS, or NoSQL databases.Contributors: Want to improve or submit a new example? Fork the repo, add your example folder, and create a pull request!  ","version":"1.0.0","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#contributing","content":" We welcome community contributions to expand this repository! Please consider:  Adding new example projects or folders (e.g., Wiremock, Kafka, PostgreSQL, Redis)Fixing or modernizing existing examplesImproving documentation and setup instructions  See the CONTRIBUTING.md for detailed guidelines. ","version":"1.0.0","tagName":"h2"},{"title":"Change-as-Code (CaC)","type":0,"sectionRef":"#","url":"/docs/overview/Change-as-Code","content":"","keywords":"","version":"1.0.0"},{"title":"Why CaC matters today‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#why-cac-matters-today","content":" Modern applications increasingly span dozens of external systems‚Äîranging from relational and NoSQL databases to SaaS feature flags, message buses, and infrastructure APIs. Managing these changes manually or with ad-hoc scripts leads to:  Drift and ‚Äúsnowflake‚Äù environments When teams manually tweak production configurations, environments diverge, making rollbacks or audits nearly impossible. Lack of auditability Regulatory and security teams require a full record of ‚Äúwhat changed, when, and who made it.‚Äù Spreadsheets and one-off commands don‚Äôt cut it. Inefficient collaboration Developers, operations, and security need a single source of truth: change definitions in code, reviewed and versioned via pull requests. Increased risk of human error Pasting commands into a console or clicking UI checkboxes invites typos, misconfigurations, and stress during deployment windows.  Flamingock's CaC approach solves these problems by treating every external-system change as first-class code‚Äîcomplete with version control, automated execution, and a centralized audit trail.  ","version":"1.0.0","tagName":"h2"},{"title":"Four Pillars of Change-as-Code‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#four-pillars-of-change-as-code","content":" One-Hundred-Percent VersionedAll Changes live in your Git repository (or other VCS). This means you can review, diff, and roll back changes just like application code. Automated ExecutionFlamingock scans and applies Changes at application startup or on-demand via the CLI. No manual intervention‚Äîjust code running code. Auditable &amp; TraceableEvery Change outcome is recorded in an audit store (your database or Flamingock Cloud). Teams can query &quot;who ran what change, and when,&quot; ensuring full compliance. Cross-Component Support Whether it's SQL/NoSQL DDL, S3 buckets, Kafka topics, feature-flag toggles, or REST API calls‚ÄîFlamingock treats them all as code. Your entire system evolves in lockstep.  ","version":"1.0.0","tagName":"h2"},{"title":"\"Hello, CaC\" Code Snippet‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#hello-cac-code-snippet","content":" Imagine you need to toggle a feature flag in a downstream service (not a database). In Flamingock, you‚Äôd write:  @Change(id = &quot;enable-autosave&quot;, author = &quot;ops-team&quot;) // order extracted from filename public class _20250925_01_EnableAutoSaveFeature { @Apply public void enableAutoSave(FeatureFlagClient client) { client.setFlag(&quot;autosave_feature&quot;, true); } @Rollback public void disableAutoSave(FeatureFlagClient client) { client.setFlag(&quot;autosave_feature&quot;, false); } }   Versioned: This code-based or template-based Change lives in your VCS.Automated: Flamingock executes it in order (0005) at startup or via CLI.Auditable: Upon success, an audit entry is written to your audit store.Cross-Component: The same pattern works for a DynamoDB schema change, a Kafka topic creation, or any REST API call.  ","version":"1.0.0","tagName":"h2"},{"title":"Illustration: CaC vs. IaC‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#illustration-cac-vs-iac","content":"   Infrastructure as Code (IaC): Use Terraform, CloudFormation, Pulumi, etc., to provision VMs, networks, and databases (the ‚Äúfoundation‚Äù).Change as Code (CaC): Use Flamingock to version and apply everything that lives on that foundation‚Äîdatabase schemas, feature flags, SaaS configurations, message topics, and more.  ","version":"1.0.0","tagName":"h2"},{"title":"Real-World Use Cases‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#real-world-use-cases","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Multi-tenant SaaS Onboarding‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#multi-tenant-saas-onboarding","content":" Problem: Over the lifetime of your application, you might need to create and then later modify external resources‚Äîsuch as an S3 bucket, Kafka topics, IAM roles, and initial database state‚Äîas part of each new release. Doing this manually or with ad-hoc scripts risks drift, missing audits, and inconsistent environments..  CaC Solution: Define a sequence of Changes that run in order on mutiple deployments, inserting audit entries and ensuring reproducible, versioned updates::  CodeTemplate @Change(id = &quot;provision-bucket&quot;, author = &quot;team-a&quot;, transactional = false) // order extracted from filename public class _20250923_01_ProvisionBucketChange { @Apply public void apply(S3Client s3) { s3.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .build()); } @Rollback public void rollback(S3Client s3) { s3.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .build()); } } @Change(id = &quot;create-kafka-topics&quot;, author = &quot;devops&quot;, transactional = false) // order extracted from filename public class _20250923_02_CreateKafkaTopicsChange { @Apply public void apply(KafkaAdminClient admin) { var topic1 = new NewTopic(&quot;app-events&quot;, 3, (short) 1); var topic2 = new NewTopic(&quot;user-notifications&quot;, 2, (short) 1); admin.createTopics(Arrays.asList(topic1, topic2)); } @Rollback public void rollback(KafkaAdminClient admin) { admin.deleteTopics(Arrays.asList(&quot;app-events&quot;, &quot;user-notifications&quot;)); } } @Change(id = &quot;setup-iam-roles&quot;, author = &quot;devops&quot;, transactional = false) // order extracted from filename public class _20250924_01_SetupIamRolesChange { @Apply public void apply(IamClient iam) { CreateRoleResponse response = iam.createRole(CreateRoleRequest.builder() .roleName(&quot;flamingock-app-role&quot;) .assumeRolePolicyDocument(&quot;{...}&quot;) // truncated for brevity .build()); } @Rollback public void rollback(IamClient iam) { iam.deleteRole(DeleteRoleRequest.builder() .roleName(&quot;flamingock-app-role&quot;) .build()); } } @Change(id = &quot;seed-database&quot;, author = &quot;devops&quot;, transactional = true) // order extracted from filename public class _20250924_02_SeedTenantDataChange { @Apply public void apply(DataSource ds) { try (Connection conn = ds.getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate( &quot;INSERT INTO tenants (id, name, created_at) &quot; + &quot;VALUES (1, 'TenantA', NOW()), (2, 'TenantB', NOW())&quot; ); } catch (SQLException e) { throw new RuntimeException(e); } } @Rollback public void rollback(DataSource ds) { try (Connection conn = ds.getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate(&quot;DELETE FROM tenants WHERE id IN (1, 2)&quot;); } catch (SQLException e) { throw new RuntimeException(e); } } } @Change(id = &quot;update-bucket-settings&quot;, author = &quot;team-a&quot;, transactional = false) // order extracted from filename public class _20250925_01_UpdateBucketSettingsChange { @Apply public void apply(S3Client s3) { // Example: enable versioning on the bucket s3.putBucketVersioning(PutBucketVersioningRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .versioningConfiguration(VersioningConfiguration.builder() .status(&quot;Enabled&quot;) .build()) .build()); } @Rollback public void rollback(S3Client s3) { // Example: disable versioning on the bucket s3.putBucketVersioning(PutBucketVersioningRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .versioningConfiguration(VersioningConfiguration.builder() .status(&quot;Suspended&quot;) .build()) .build()); } }   Flamingock ensures these four steps run in sequence‚Äînever twice‚Äîand logs them in your audit store for future reference.  ","version":"1.0.0","tagName":"h3"},{"title":"Change-as-Code Checklist‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#change-as-code-checklist","content":" ‚úÖ Change lives in VCS: Every Change class (or YAML template) is versioned.‚úÖ Automated pipeline: Flamingock applies changes automatically at startup or via CLI.‚úÖ Audit trail: Query your audit store for a complete history of applied changes.‚úÖ Rollback logic: Each Change provides @Rollback to undo or compensate if needed.‚úÖ Consistent ordering: All Changes follow a strict, declared ordering (via the order attribute).‚úÖ Cross-component: You can target databases, SaaS APIs, feature flags, message systems‚Äîanything with a client API.  ","version":"1.0.0","tagName":"h2"},{"title":"Next Steps‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#next-steps","content":" Quick start ‚Üí Learn how to create your first Change and run Flamingock.Core concepts ‚Üí Dive deeper into auditing, drivers, transactions, and distributed locking.Real use case examples ‚Üí Explore real-world code samples: MongoDB, DynamoDB, Couchbase, Kafka, and more. ","version":"1.0.0","tagName":"h2"},{"title":"Issue Resolution","type":0,"sectionRef":"#","url":"/docs/safety-and-recovery/issue-resolution","content":"","keywords":"","version":"1.0.0"},{"title":"Understanding Issues‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#understanding-issues","content":" ","version":"1.0.0","tagName":"h2"},{"title":"What Creates an Issue?‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#what-creates-an-issue","content":" An &quot;issue&quot; is detected when:  Change execution fails during the @Apply methodChange starts but never completes (process crash, timeout)Rollback fails during @Rollback methodChange needs to run again but is in uncertain state  ","version":"1.0.0","tagName":"h3"},{"title":"CLI-Driven Resolution Workflow‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#cli-driven-resolution-workflow","content":" ","version":"1.0.0","tagName":"h2"},{"title":"1. Issue Discovery‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#1-issue-discovery","content":" flamingock issue list   Example Output:  ISSUES FOUND (3) ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Change ID ‚îÇ State ‚îÇ Error ‚îÇ Target ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ user-data-sync-v2 ‚îÇ STARTED ‚îÇ Connection lost ‚îÇ user-db ‚îÇ ‚îÇ cache-warming-q4 ‚îÇ FAILED ‚îÇ Redis timeout ‚îÇ redis-cache ‚îÇ ‚îÇ payment-processing ‚îÇ FAILED ‚îÇ Validation error ‚îÇ payment-api ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Use 'flamingock issue get' to process issues automatically, or 'flamingock issue get -c &lt;change-id&gt;' for specific issue details.   ","version":"1.0.0","tagName":"h3"},{"title":"2. Automated Issue Triage‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#2-automated-issue-triage","content":" flamingock issue get   What This Does:  Automatically selects the next issueProvides detailed context and diagnostic informationSuggests resolution approaches based on failure typeNo need to copy/paste change IDs  Example Output:  ISSUE: user-data-sync-v2 Status: STARTED (execution began but never completed) Target System: user-database Author: platform-team Started: 2024-01-15 14:32:15 UTC Error: Connection lost during execution DIAGNOSTIC INFORMATION: - Change was modifying user profiles in MongoDB - Execution started but connection dropped after 30 seconds - No rollback was triggered (connection failure before completion) - Potentially partial state in target system RESOLUTION GUIDANCE: 1. Check target system state: - Query user-database for partially updated records - Look for users with incomplete profile updates - Check MongoDB logs for connection errors around 14:32:15 UTC 2. Determine actual state: - If no changes were applied ‚Üí mark as APPLIED (safe to continue) - If changes were partially applied ‚Üí complete manually, then mark APPLIED - If changes were fully applied ‚Üí mark as APPLIED - If changes caused corruption ‚Üí rollback manually, then mark ROLLED_BACK 3. Resolve the issue: flamingock audit fix -c user-data-sync-v2 --resolution APPLIED flamingock audit fix -c user-data-sync-v2 --resolution ROLLED_BACK Next: flamingock issue get (to process next issue)   ","version":"1.0.0","tagName":"h3"},{"title":"3. Verify Target System State‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#3-verify-target-system-state","content":" Based on the guidance, investigate the target system (not the audit store) to determine the actual state of the change. You will find one of three possible states:  Fully applied: The change completed successfully and all expected modifications are presentNot applied at all: The change failed before making any modifications to the target systemPartially applied: Some but not all changes were made to the target system (only possible with non-transactional target systems)  For partially applied changes, you must decide whether to:  Manually complete the remaining changes, then mark as APPLIEDManually revert the partial changes, then mark as ROLLED_BACK  ","version":"1.0.0","tagName":"h3"},{"title":"4. Mark Audit Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#4-mark-audit-resolution","content":" Based on your target system verification, mark the audit with the appropriate resolution.  If the change was successfully applied to the target system (either fully or after manual completion of partial changes), mark it as APPLIED:  flamingock audit fix -c change-id -r APPLIED   If the change was not applied or was manually reverted, mark it as ROLLED_BACK:  flamingock audit fix -c change-id -r ROLLED_BACK   ","version":"1.0.0","tagName":"h3"},{"title":"Resolution Commands‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#resolution-commands","content":" ","version":"1.0.0","tagName":"h2"},{"title":"APPLIED Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#applied-resolution","content":" Mark the change as successfully applied when the target system contains the expected changes:  flamingock audit fix -c change-id -r APPLIED   Use when:  Changes were successfully applied to target systemPartial changes were completed manuallyTarget system is in the desired end state  ","version":"1.0.0","tagName":"h3"},{"title":"ROLLED_BACK Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/safety-and-recovery/issue-resolution#rolled_back-resolution","content":" Mark the change as not applied when the target system was not modified or was reverted:  flamingock audit fix -c change-id -r ROLLED_BACK   Use when:  Changes were not applied to target systemChanges were reverted due to issuesTarget system should be left unchanged  Note: Changes marked as ROLLED_BACK will be attempted again on the next execution. ","version":"1.0.0","tagName":"h3"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/resources/faq","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#introduction","content":" This FAQ addresses frequent questions about Flamingock, from basic usage to advanced recovery strategies and operational concerns.  ","version":"1.0.0","tagName":"h2"},{"title":"Getting started‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#getting-started","content":" Should I use a template-based or code-based Change? Choose template-based Changes to eliminate boilerplate for common tools and integrations (SQL DDL, SaaS/API, etc) and for your custom Changes by defining changes declaratively in YAML or JSON. Use code-based Changes when you need custom or conditional logic in Java. See: Template introduction  Can I integrate Flamingock into a Spring Boot application? Yes, you can. You just need to import the Spring Boot integration module and annotate you main application with @EnableFlamingock. See: Spring Boot integration  Can I use Flamingock without Spring Boot? Yes. You can use Flamingock in any Java application by configuring it manually using the FlamingockBuilder. This approach is ideal for applications that do not rely on Spring Boot or that require finer control.  What Java version is required? Flamingock‚Äôs core engine runs on Java 8 and above. However, some optional integration modules (such as the Spring Boot support) target more recent ecosystems and require Java 17+. For those cases we publish two artifacts:  A modern module (e.g., flamingock-springboot-integration) built for Java 17+ and Spring Boot 3.xA legacy counterpart (e.g., flamingock-springboot-integration-v2-legacy) compatible with Java 8 and Spring Boot 2.x  Most users on Java 8 can stick with the core and legacy integrations; if you‚Äôre on Java 17 or newer, simply use the up-to-date modules.  Is it possible to use Flamingock in GraalVM native images? Yes, Flamingock provides a dedicated GraalVM integration guide. Ensure your dependencies and reflection requirements are correctly configured.  ","version":"1.0.0","tagName":"h3"},{"title":"Compatibility‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#compatibility","content":" Can I switch between different audit stores?If you are working with different audit stores that use the same underlying database (such as MongoDB), and they share the same structure and collection for storing metadata, it is possible to switch between them with minimal adjustments. This enables flexible integration depending on your preferred access layer, such as switching from the MongoDB Java Driver to the Spring Data implementation.  ","version":"1.0.0","tagName":"h3"},{"title":"Behaviour and execution‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#behaviour-and-execution","content":" Does Flamingock guarantee idempotent execution? Yes. Each Change has a unique ID and Flamingock ensures it runs only once per system, even across multiple instances.  What happens if a Change execution fails midway? Flamingock's behavior depends on your recovery strategy configuration:  With MANUAL_INTERVENTION (default):  Transactional changes: Database automatically rolls back, issue logged for manual reviewNon-transactional changes: @Rollback method called, issue logged for manual reviewResolution required: Use CLI (flamingock issue get, then flamingock audit fix) to resolve after investigation  With ALWAYS_RETRY:  Transactional changes: Database automatically rolls back, automatic retry on next executionNon-transactional changes: @Rollback method called, automatic retry on next executionNo manual intervention: Continues until successful  This intelligent failure handling prevents silent data corruption and provides operational control.  How can I ensure changes are transactional? If your database supports transactions (e.g. MongoDB ‚â• 4.0 in replica set), you can enable them using Flamingock‚Äôs transaction config.  Should I implement the @Rollback method in transactional environments?  Yes, we highly recommend to implement the @Rollback method. The main reason for this is that some other operations like undo, rely on this method to work. However it's a very good practice as it provides a robust system that is less affected when moving to non-transactional environments.  Can I react to the execution of Flamingock from my application? Yes. Flamingock provides an event system that allows your application to listen to key lifecycle moments, such as when a Change starts or finishes execution. These events can be used to trigger logging, monitoring, or other side effects external to the change execution logic itself.  This enables loose coupling between Flamingock‚Äôs core execution and your application-level behaviour, without modifying the Change directly.  For more details, see the Events guide.  Is Flamingock compatible with Spring Boot profiles? Yes. You can conditionally run Changes using @Profile, allowing changes to vary by environment.  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#configuration","content":" Where do I set MongoDB connection options like write concern or read preference? You can define these directly in the config using dedicated properties (e.g. mongodb.writeConcern.w, readPreference, etc.). Refer to the additional configuration section for detailed examples.  Can I inject Spring beans or other services into my Changes? Yes. Flamingock supports full dependency injection in both Spring and non-Spring environments.  Can I define Change dependencies and execution order? Yes. Changes can declare dependencies via annotations or configuration metadata. See Change anatomy for more.  ","version":"1.0.0","tagName":"h3"},{"title":"Testing and development‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#testing-and-development","content":" How do I test Flamingock Changes? You can perform unit, integration, and Spring Boot integration tests using test runners and mocking utilities. See the Testing section for more details.  Can I use templates to generate Changes? Yes. Flamingock offers a templating mechanism for creating new Changes and defining reusable components.  ","version":"1.0.0","tagName":"h3"},{"title":"Migrating from Mongock‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#migrating-from-mongock","content":" What‚Äôs the relationship between Flamingock and Mongock? Flamingock is the direct evolution of Mongock. While it inherits the core idea of tracking and executing changes reliably, Flamingock is a complete architectural and conceptual redesign aimed at overcoming the limitations of Mongock.  Some of the key advancements introduced by Flamingock include:  Cloud-native capabilities: Support for cloud-managed storage and execution, enabling Flamingock to run in distributed, serverless, or ephemeral environments without additional setup.Execution stages and pipelines: A structured way to group and orchestrate Changes by context, environment, or lifecycle stage.Modular architecture: Clean separation of core, editions, templates, and integrations, enabling better extensibility and maintainability.Template-based Changes: An additional declarative mechanism to define reusable changes without writing Java code, accelerating development and standardisation.  While Flamingock retains conceptual compatibility with Mongock, it represents a significant leap forward in flexibility, scalability, and developer experience.  If you are currently using Mongock, we encourage you to review the migration guide and explore what Flamingock can offer in modern change management.  ","version":"1.0.0","tagName":"h3"},{"title":"Recovery Strategies & Safety‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#recovery-strategies--safety","content":" What are recovery strategies and why do I need them? Recovery strategies determine how Flamingock handles failures - the key differentiator from traditional tools that retry blindly or fail silently. You choose between:  MANUAL_INTERVENTION (default): Stop and alert for human review when uncertainALWAYS_RETRY: Continue automatically until successful for idempotent operations  This prevents silent data corruption and gives you operational control based on your risk tolerance.  When should I use MANUAL_INTERVENTION vs ALWAYS_RETRY? Use MANUAL_INTERVENTION for:  Financial transactionsUser data modificationsCritical business logicNon-idempotent operationsCompliance-sensitive changes  Use ALWAYS_RETRY for:  Cache warming operationsIdempotent API callsEvent publishing (with consistent keys)Configuration updatesIndex creationFile operations with overwrite  How do I know if my operation is idempotent? An operation is idempotent if running it multiple times produces the same result as running it once. Examples:  ‚úÖ SET user.status = 'active' (same result every time)‚úÖ CREATE INDEX IF NOT EXISTS (safe to repeat)‚úÖ File overwrite with same content‚ùå INCREMENT user.score (different result each time)‚ùå Append operations‚ùå Time-sensitive calculations  What is the issue resolution workflow?  Detection: flamingock issue list shows all unresolved issuesTriage: flamingock issue get provides next priority issue with guidanceInvestigation: Check target system state (not audit store)Resolution: flamingock audit fix -c change-id --resolution APPLIED|ROLLED_BACK  This structured workflow eliminates guesswork and provides complete audit trails.  Can I change recovery strategies after deployment? Yes, you can update the @Recovery annotation in your code and redeploy. Existing audit entries maintain their state, but new executions use the updated strategy.  How does Cloud Edition improve recovery without changing my code? Cloud Edition uses the same recovery strategies but provides enhanced outcomes through:  Intelligent automation: Advanced reconciliation and marker mechanismsEnhanced retry logic: Sophisticated backoff and circuit breaker patternsAutomatic issue resolution: Many failures requiring manual intervention in Community Audit Stores are resolved automatically  Your change definitions remain identical - Cloud Edition just delivers better results.  ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise & Operational Concerns‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#enterprise--operational-concerns","content":" How does Flamingock ensure data integrity in distributed systems? Flamingock uses a dual-architecture separating target systems (where changes are applied) from audit store (execution tracking):  Complete audit trail: Every change attempt recorded regardless of business system failuresRecovery capabilities: CLI operates on audit state, you fix business systemsCompliance independence: Audit integrity maintained during business system issuesGovernance separation: Business and compliance data have different access patterns  What compliance and audit capabilities does Flamingock provide?  Complete execution history with timestamp, author, system, and outcomeIssue tracking and resolution workflows for failed changesCLI-based audit management for governance and complianceIntegration ready for external observability platforms (ELK, Prometheus, Datadog)Regulatory reporting capabilities in Cloud Edition  How does Flamingock compare to traditional migration tools?  Aspect\tFlyway/Liquibase\tMongock\tFlamingockFocus\tSQL databases\tMongoDB only\tAll systems Distributed Systems\t‚ùå Not designed for\t‚ùå Limited\t‚úÖ First-class support Non-transactional\t‚ùå No support\t‚ùå Assumes transactions\t‚úÖ Full support Failure Handling\tRetry blindly\tRetry blindly\tConfigurable strategies Issue Resolution\tManual SQL\tNone\tCLI + Cloud automation Safety Default\tNone\tNone\tMANUAL_INTERVENTION  Can Flamingock handle multi-system coordination? Yes, Flamingock is designed for distributed systems. A single Change can coordinate changes across multiple target systems (databases, APIs, message queues) while maintaining a unified audit trail and recovery strategy.  How do I ensure my team adopts Flamingock safely?  Start conservative: Use MANUAL_INTERVENTION (default) initiallyEstablish governance: Define organization-wide recovery strategy guidelinesCreate runbooks: Document investigation procedures for your changesTrain on CLI: Ensure team knows issue resolution workflowMonitor patterns: Review failure patterns to optimize strategies over time  What happens if the audit store goes down? Flamingock's safety guarantee: No business changes applied without proper audit tracking. If the audit store is unavailable:  Flamingock stops execution safelyNo changes are applied to target systemsSystem remains in safe, known stateResume automatically once audit store connectivity is restored  Can I use Flamingock in microservices architectures? Absolutely. Flamingock is designed for distributed systems:  Each microservice can have its own Changes for its domainShared audit store provides cross-service visibility (especially in Cloud Edition)CLI provides centralized operational control across all servicesRecovery strategies can be tailored per service's risk profile  What are the organizational benefits of adopting Flamingock?  Risk reduction: Prevent silent data corruption through safety-first defaultsTeam velocity: Eliminate deployment bottlenecks with autonomous change managementOperational excellence: Centralized governance with distributed executionCompliance automation: Complete audit trails and governance workflowsReduced dependencies: Teams control their domain without infrastructure dependencies  How does Flamingock support regulatory compliance requirements?  Complete audit trails with immutable execution historyGovernance workflows for change approval and reviewIssue resolution documentation for regulatory reportingCLI integration for compliance automationSeparation of concerns between business and compliance dataCloud Edition features: Advanced reporting, RBAC, multi-environment governance  ","version":"1.0.0","tagName":"h3"},{"title":"Other‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#other","content":" Is Flamingock open-source? Yes. The Flamingock client library ‚Äî used across all editions, including Community, Self-managed, and Cloud ‚Äî is fully open-source.  For the Cloud and Self-managed editions, additional enterprise components such as the server runtime, dashboards, and governance tools are provided under a commercial licence. These components build on top of the open-source core to deliver advanced features like observability, orchestration, and centralised management.  Is there a CLI available? Yes! The Flamingock CLI provides enterprise-grade operational control for issue resolution, audit management, and maintenance tasks.  If your question is not listed here, please check the corresponding edition‚Äôs guide or open an issue on our GitHub repository. ","version":"1.0.0","tagName":"h3"},{"title":"Couchbase Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/couchbase-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#version-compatibility","content":" Component\tVersion RequirementCouchbase Java Client\t3.6.0+  Couchbase Java Client 3.6.0+ is required and must be included in your project dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#installation","content":" Add the Couchbase Java Client dependency to your project (version 3.6.0+ required):  GradleMaven implementation(&quot;com.couchbase.client:java-client:3.6.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#basic-setup","content":" Configure the target system:  var couchbaseTarget = new CouchbaseTargetSystem(&quot;user-database-id&quot;, cluster, bucket);   The constructor requires the target system name, Couchbase cluster, and bucket. Optional configurations can be added via .withXXX() methods.  Register Target System Once created, you need to register this target system with Flamingock. See Registering target systems for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System Configuration‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#target-system-configuration","content":" The Couchbase target system uses Flamingock's split dependency resolution architecture with separate flows for target system configuration and change execution dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#constructor-dependencies-mandatory","content":" These dependencies must be provided at target system creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionCluster\tcluster\tCouchbase cluster connection - required for both target system configuration and change execution Bucket\tbucket\tTarget bucket instance - required for both target system configuration and change execution  ","version":"1.0.0","tagName":"h3"},{"title":"Dependencies Available to Changes‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#dependencies-available-to-changes","content":" Changes can access dependencies through dependency injection with fallback:  Target system context (highest priority) - Cluster, Bucket, TransactionAttemptContext, plus any added via .addDependency()Target system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#configuration-example","content":" Here's a comprehensive example showing the new architecture:  // Target system configuration (mandatory via constructor) var couchbaseTarget = new CouchbaseTargetSystem(&quot;user-database&quot;, productionCluster, userBucket) .addDependency(auditService); // Additional dependency for changes // Global context with shared dependencies Flamingock.builder() .addDependency(emailService) // Available to all target systems .addDependency(logService) // Available to all target systems .addTargetSystems(couchbaseTarget) .build();   Target system configuration resolution:  Cluster: Must be provided via constructor (productionCluster)Bucket: Must be provided via constructor (userBucket)  Change dependency resolution for Changes in &quot;user-database&quot;:  Cluster: From target system context (productionCluster)Bucket: From target system context (userBucket)TransactionAttemptContext: From target system context (created by Flamingock)AuditService: From target system additional dependenciesEmailService: From global context (fallback)LogService: From global context (fallback)  This architecture ensures explicit target system configuration while providing flexible dependency access for changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#transactional-support","content":" For a Change to leverage Couchbase's transactional capabilities, it must use the TransactionAttemptContext parameter. Flamingock uses the injected Cluster and Bucket dependencies to create and manage this context's lifecycle - creating the transaction context before execution, committing on success, and rolling back on failure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;user-database-id&quot;) @Change(id = &quot;create-users&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_CreateUsers { @Apply public void apply(Cluster cluster, Bucket bucket, TransactionAttemptContext txContext) { // TransactionAttemptContext is required for transactional execution // Flamingock uses the target system's Cluster and Bucket to handle transaction operations // and manages transaction start, commit, and rollback automatically Collection collection = bucket.defaultCollection(); JsonObject user = JsonObject.create() .put(&quot;name&quot;, &quot;John Doe&quot;) .put(&quot;email&quot;, &quot;john@example.com&quot;); txContext.insert(collection, &quot;user::001&quot;, user); } }   You can also work with the Cluster and Bucket directly without transactions:  @TargetSystem(&quot;user-database-id&quot;) @Change(id = &quot;update-configs&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_02_UpdateConfigs { @Apply public void apply(Cluster cluster, Bucket bucket) { // Operations without TransactionAttemptContext won't participate in transactions Collection collection = bucket.defaultCollection(); JsonObject config = JsonObject.create() .put(&quot;version&quot;, &quot;2.0&quot;) .put(&quot;updated&quot;, Instant.now().toString()); collection.upsert(&quot;config::app&quot;, config); } }   How transactions work:  Context creation: Flamingock uses the target system's Cluster to create an TransactionAttemptContext for transaction managementTransaction management: The same Cluster and Bucket handle transaction operations and coordinate with the contextLifecycle: Flamingock automatically creates the transaction context, commits on success, or rolls back on failure  Without the TransactionAttemptContext parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in Changes‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#available-dependencies-in-changes","content":" Your Changes can inject Couchbase-specific dependencies like Cluster, Bucket, and TransactionAttemptContext (for transactions), but are not limited to these. The target system provides these dependencies through its context, and you can add additional dependencies via .addDependency() that take precedence over global dependencies.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#next-steps","content":" Learn about Target systemsExplore ChangesSee Couchbase examples ","version":"1.0.0","tagName":"h2"},{"title":"Recovery strategies","type":0,"sectionRef":"#","url":"/docs/safety-and-recovery/recovery-strategies","content":"","keywords":"","version":"1.0.0"},{"title":"Strategy types‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#strategy-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Manual intervention (default)‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#manual-intervention-default","content":" Behavior: Stops execution and requires human intervention when any failure occursUse case: When safety is prioritized over automationTechnical challenge: Prevents silent failures and ensures human oversight for uncertain outcomes  ","version":"1.0.0","tagName":"h3"},{"title":"Always retry‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#always-retry","content":" Behavior: Automatically retries the change on subsequent executions until successfulUse case: When changes are idempotent and safe to retry automaticallyTechnical challenge: Reduces operational overhead for recoverable failures  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#configuration","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Code-based Changes‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#code-based-changes","content":" Use the @Recovery annotation to specify the strategy:  // Default behavior (manual intervention) @Change(id = &quot;example-change&quot;, order = &quot;20250207_01&quot;, author = &quot;team&quot;) public class ExampleChange { @Apply public void apply() { // Change logic here } } // Explicit always retry @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) @Change(id = &quot;retry-change&quot;, order = &quot;20250207_02&quot;, author = &quot;team&quot;) public class RetryChange { @Apply public void apply() { // Idempotent change logic here } }   ","version":"1.0.0","tagName":"h3"},{"title":"Template-based Changes‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#template-based-changes","content":" Use the recovery field in your YAML configuration:  # Default behavior (manual intervention) id: example-change order: &quot;001&quot; author: team template: example-template apply: | # Change logic here --- # Explicit always retry id: retry-change order: &quot;002&quot; author: team recovery: ALWAYS_RETRY template: example-template apply: | # Idempotent change logic here   ","version":"1.0.0","tagName":"h3"},{"title":"When failures occur‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#when-failures-occur","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Manual intervention workflow‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#manual-intervention-workflow","content":" Execution stops immediately on failureIssue is logged in the audit storeUse CLI tools to investigate and resolveMark change as applied or rolled back manually  ","version":"1.0.0","tagName":"h3"},{"title":"Always retry workflow‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#always-retry-workflow","content":" Execution fails but continues on next runChange attempts retry automaticallyProcess continues until successful or manually intervened  ","version":"1.0.0","tagName":"h3"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Choose manual intervention when:‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#choose-manual-intervention-when","content":" Changes modify critical system stateFailures require investigation before proceedingRollback logic is complex or requires validation  ","version":"1.0.0","tagName":"h3"},{"title":"Choose always retry when:‚Äã","type":1,"pageTitle":"Recovery strategies","url":"/docs/safety-and-recovery/recovery-strategies#choose-always-retry-when","content":" Operations are truly idempotentFailures are typically transient (network, temporary unavailability)Automatic recovery is acceptable  For detailed information on Change annotations and configuration, see Change anatomy.  For operational workflows when issues occur, see Issue resolution. ","version":"1.0.0","tagName":"h3"},{"title":"DynamoDB Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/dynamodb-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#version-compatibility","content":" Component\tVersion RequirementAWS SDK DynamoDB Enhanced\t2.25.0+  AWS SDK DynamoDB Enhanced 2.25.0+ is required and must be included in your project dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#installation","content":" Add the AWS SDK DynamoDB Enhanced dependency to your project (version 2.25.0+ required):  GradleMaven implementation(&quot;software.amazon.awssdk:dynamodb-enhanced:2.25.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#basic-setup","content":" Configure the target system:  var dynamoTarget = new DynamoDBTargetSystem(&quot;inventory-database-id&quot;, dynamoDbClient);   The constructor requires the target system name and DynamoDB client. Optional configurations can be added via .withXXX() methods.  Register Target System Once created, you need to register this target system with Flamingock. See Registering target systems for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System Configuration‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#target-system-configuration","content":" The DynamoDB target system uses Flamingock's split dependency resolution architecture with separate flows for target system configuration and change execution dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#constructor-dependencies-mandatory","content":" These dependencies must be provided at target system creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionDynamoDbClient\tdynamoDbClient\tAWS DynamoDB client - required for both target system configuration and change execution  ","version":"1.0.0","tagName":"h3"},{"title":"Dependencies Available to Changes‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#dependencies-available-to-changes","content":" Changes can access dependencies through dependency injection with fallback:  Target system context (highest priority) - DynamoDbClient, TransactWriteItemsEnhancedRequest.Builder, plus any added via .addDependency()Target system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#configuration-example","content":" Here's a comprehensive example showing the new architecture:  // Target system configuration (mandatory via constructor) var dynamoTarget = new DynamoDBTargetSystem(&quot;inventory-database&quot;, inventoryDynamoClient) .addDependency(inventoryService); // Additional dependency for changes // Global context with shared dependencies Flamingock.builder() .addDependency(emailService) // Available to all target systems .addDependency(logService) // Available to all target systems .addTargetSystems(dynamoTarget) .build();   Target system configuration resolution:  DynamoDbClient: Must be provided via constructor (inventoryDynamoClient)  Change dependency resolution for Changes in &quot;inventory-database&quot;:  DynamoDbClient: From target system context (inventoryDynamoClient)TransactWriteItemsEnhancedRequest.Builder: From target system context (created by Flamingock)InventoryService: From target system additional dependenciesEmailService: From global context (fallback)LogService: From global context (fallback)  This architecture ensures explicit target system configuration while providing flexible dependency access for changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#transactional-support","content":" For a Change to leverage DynamoDB's transactional capabilities, it must use the TransactWriteItemsEnhancedRequest.Builder parameter. Flamingock uses the injected DynamoDbClient dependency to create and manage this builder's lifecycle - creating it before execution and executing the transaction with all operations on success.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;inventory-database-id&quot;) @Change(id = &quot;update-inventory&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_UpdateInventory { @Apply public void apply(DynamoDbClient client, TransactWriteItemsEnhancedRequest.Builder txBuilder) { // The transaction builder is required for transactional execution // Flamingock uses the target system's DynamoDbClient to handle transaction operations // and manages transaction creation, execution, and rollback automatically DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder() .dynamoDbClient(client) .build(); DynamoDbTable&lt;Product&gt; table = enhancedClient.table(&quot;products&quot;, TableSchema.fromBean(Product.class)); // Add operations to the transaction txBuilder.addPutItem(table, new Product(&quot;123&quot;, &quot;Updated Product&quot;)); txBuilder.addDeleteItem(table, Key.builder().partitionValue(&quot;456&quot;).build()); } }   How transactions work:  Builder creation: Flamingock uses the target system's DynamoDbClient to create a TransactWriteItemsEnhancedRequest.BuilderTransaction management: The same DynamoDbClient executes the transaction with all accumulated operationsLifecycle: Flamingock automatically creates the builder, executes the transaction on success, or handles rollback on failure  Without the TransactWriteItemsEnhancedRequest.Builder parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in Changes‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#available-dependencies-in-changes","content":" Your Changes can inject DynamoDB-specific dependencies like DynamoDbClient and TransactWriteItemsEnhancedRequest.Builder, but are not limited to these. The target system provides these dependencies through its context, and you can add additional dependencies via .addDependency() that take precedence over global dependencies.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#next-steps","content":" Learn about Target systemsExplore ChangesSee DynamoDB examples ","version":"1.0.0","tagName":"h2"},{"title":"MongoDB Spring Data Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/mongodb-springdata-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#version-compatibility","content":" Component\tVersion RequirementSpring Data MongoDB\t3.1.x - 4.x  Spring Data MongoDB versions from 3.1.x through 4.x are supported. Version 3.1.x+ is included in Spring Boot 2.4.3+.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#installation","content":" Add the Spring Data MongoDB dependency to your project (versions 3.1.x - 4.x supported):  GradleMaven implementation(&quot;org.springframework.data:spring-data-mongodb:3.1.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#basic-setup","content":" Configure the target system:  var mongoTarget = new MongoDBSpringDataTargetSystem(&quot;user-database-id&quot;, mongoTemplate);   The constructor requires the target system name and MongoDB template. Optional configurations can be added via .withXXX() methods.  Register Target System Once created, you need to register this target system with Flamingock. See Registering target systems for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System Configuration‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#target-system-configuration","content":" The MongoDB Spring Data target system uses Flamingock's split dependency resolution architecture with separate flows for target system configuration and change execution dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#constructor-dependencies-mandatory","content":" These dependencies must be provided at target system creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionMongoTemplate\tmongoTemplate\tSpring Data MongoDB template - required for both target system configuration and change execution  ","version":"1.0.0","tagName":"h3"},{"title":"Optional Configuration (.withXXX() methods)‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#optional-configuration-withxxx-methods","content":" These configurations can be customized via .withXXX() methods with no global context fallback:  Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads  ","version":"1.0.0","tagName":"h3"},{"title":"Dependencies Available to Changes‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#dependencies-available-to-changes","content":" Changes can access dependencies through dependency injection with fallback:  Target system context (highest priority) - MongoTemplate, plus any added via .addDependency()Target system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#configuration-example","content":" Here's a comprehensive example showing the new architecture:  // Target system configuration (mandatory via constructor) var mongoTarget = new MongoDBSpringDataTargetSystem(&quot;user-database&quot;, userMongoTemplate) .withWriteConcern(WriteConcern.W1) // Optional configuration .withReadPreference(ReadPreference.secondary()) // Optional configuration .addDependency(userAuditService); // Additional dependency for changes // Global context with shared dependencies Flamingock.builder() .addDependency(emailService) // Available to all target systems .addDependency(logService) // Available to all target systems .addTargetSystems(mongoTarget) .build();   Target system configuration resolution:  MongoTemplate: Must be provided via constructor (userMongoTemplate)WriteConcern: Uses explicit configuration (W1) instead of defaultReadPreference: Uses explicit configuration (secondary()) instead of default  Change dependency resolution for Changes in &quot;user-database&quot;:  MongoTemplate: From target system context (userMongoTemplate)UserAuditService: From target system additional dependenciesEmailService: From global context (fallback)LogService: From global context (fallback)  This architecture ensures explicit target system configuration while providing flexible dependency access for changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#transactional-support","content":" Spring Data MongoDB target system integrates with Spring's transaction management. When a Change is marked as transactional (the default), Flamingock uses the injected MongoTemplate dependency to handle transaction operations through Spring's infrastructure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;user-database-id&quot;) @Change(id = &quot;create-users&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_CreateUsers { @Apply public void apply(MongoTemplate mongoTemplate) { // MongoTemplate automatically participates in Spring transactions // Flamingock uses the target system's MongoTemplate for transaction management // through Spring's @Transactional infrastructure mongoTemplate.save(new User(&quot;john@example.com&quot;, &quot;John Doe&quot;)); } }   How transactions work:  Spring integration: Flamingock leverages the target system's MongoTemplate within Spring's transaction contextTransaction management: The same MongoTemplate handles both Change operations and transaction coordinationLifecycle: Spring's transaction infrastructure manages start, commit, and rollback automatically  The transaction lifecycle is managed through Spring's transaction infrastructure, ensuring consistency with your existing Spring Data operations.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in Changes‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#available-dependencies-in-changes","content":" Your Changes can inject Spring Data dependencies like MongoTemplate, but are not limited to these. The target system provides these dependencies through its context, and you can add additional dependencies via .addDependency() that take precedence over global dependencies.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Spring integration‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#spring-integration","content":" This target system is designed to work seamlessly with Spring Boot applications. When using Spring Boot auto-configuration, your existing MongoTemplate beans are automatically available for injection into target systems.  For more information on Spring Boot integration, see Spring Boot integration.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#next-steps","content":" Learn about Target systemsExplore ChangesSee MongoDB Spring Data examples ","version":"1.0.0","tagName":"h2"},{"title":"MongoDB Sync Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/mongodb-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#version-compatibility","content":" Component\tVersion RequirementMongoDB Java Driver\t4.0.0+  MongoDB 4.0+ is required for transaction support.  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#installation","content":" Add the MongoDB Java sync driver dependency to your project (version 4.0.0+ required):  GradleMaven implementation(&quot;org.mongodb:mongodb-driver-sync:4.0.0&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#basic-setup","content":" Configure the target system:  var mongoTarget = new MongoDBSyncTargetSystem(&quot;user-database-id&quot;, mongoClient, &quot;userDb&quot;);   The constructor requires the target system name, MongoDB client, and database name. Optional configurations can be added via .withXXX() methods.  Register Target System Once created, you need to register this target system with Flamingock. See Registering target systems for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System Configuration‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#target-system-configuration","content":" The MongoDB target system uses Flamingock's split dependency resolution architecture with separate flows for target system configuration and change execution dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#constructor-dependencies-mandatory","content":" These dependencies must be provided at target system creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionMongoClient\tmongoClient\tMongoDB connection client - required for both target system configuration and change execution String\tdatabaseName\tTarget database name - required to identify which database changes will affect  ","version":"1.0.0","tagName":"h3"},{"title":"Optional Configuration (.withXXX() methods)‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#optional-configuration-withxxx-methods","content":" These configurations can be customized via .withXXX() methods with no global context fallback:  Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads  ","version":"1.0.0","tagName":"h3"},{"title":"Dependencies Available to Changes‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#dependencies-available-to-changes","content":" Changes can access dependencies through dependency injection with fallback:  Target system context (highest priority) - MongoClient, MongoDatabase, ClientSession, plus any added via .addDependency()Target system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#configuration-example","content":" Here's a comprehensive example showing the new architecture:  // Target system configuration (mandatory via constructor) var mongoTarget = new MongoDBSyncTargetSystem(&quot;user-database&quot;, productionMongoClient, &quot;userDb&quot;) .withWriteConcern(WriteConcern.W1) // Optional configuration .withReadPreference(ReadPreference.secondary()) // Optional configuration .addDependency(auditService); // Additional dependency for changes // Global context with shared dependencies Flamingock.builder() .addDependency(emailService) // Available to all target systems .addDependency(logService) // Available to all target systems .addTargetSystems(mongoTarget) .build();   Target system configuration resolution:  MongoClient: Must be provided via constructor (productionMongoClient)Database name: Must be provided via constructor (&quot;userDb&quot;)WriteConcern: Uses explicit configuration (W1) instead of defaultReadPreference: Uses explicit configuration (secondary()) instead of default  Change dependency resolution for Changes in &quot;user-database&quot;:  MongoClient: From target system context (productionMongoClient)MongoDatabase: From target system context (derived from productionMongoClient + &quot;userDb&quot;)ClientSession: From target system context (created by Flamingock)AuditService: From target system additional dependenciesEmailService: From global context (fallback)LogService: From global context (fallback)  This architecture ensures explicit target system configuration while providing flexible dependency access for changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#transactional-support","content":" For a Change to leverage MongoDB's transactional capabilities, it must use the ClientSession parameter. Flamingock uses the injected MongoClient and MongoDatabase dependencies to create and manage this session's lifecycle - starting the transaction before execution, committing on success, and rolling back on failure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;user-database-id&quot;) @Change(id = &quot;create-users&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_CreateUsers { @Apply public void apply(MongoDatabase db, ClientSession session) { // The ClientSession is required for transactional execution // Flamingock uses the target system's MongoClient to create this session // and handles transaction start, commit, and rollback automatically db.getCollection(&quot;users&quot;) .insertOne(session, new Document(&quot;name&quot;, &quot;John&quot;)); } }   How transactions work:  Session creation: Flamingock uses the target system's MongoClient to create a ClientSessionTransaction management: The same MongoClient and MongoDatabase handle transaction operationsLifecycle: Flamingock automatically starts the transaction, commits on success, or rolls back on failure  Without the ClientSession parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in Changes‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#available-dependencies-in-changes","content":" Your Changes can inject MongoDB-specific dependencies like MongoClient, MongoDatabase, and ClientSession (for transactions), but are not limited to these. The target system provides these dependencies through its context, and you can add additional dependencies via .addDependency() that take precedence over global dependencies.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#next-steps","content":" Learn about Target systemsExplore ChangesSee MongoDB examples ","version":"1.0.0","tagName":"h2"},{"title":"Non-transactional Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/non-transactional-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Why use NonTransactionalTargetSystem?‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#why-use-nontransactionaltargetsystem","content":" NonTransactionalTargetSystem is the fallback choice when there's no specialized target system implementation available for your technology. While Flamingock provides dedicated target systems for technologies that benefit from specific handling (like transactional systems that leverage native rollback capabilities), many systems don't require such specialization.  When to use NonTransactionalTargetSystem:  No dedicated target system exists for your technologyYour system doesn't have unique characteristics that warrant specialized handlingYou need a simple, flexible solution without technology-specific optimizations  Future extensibility: The Flamingock ecosystem may expand with more specialized target systems as specific needs are identified.  Common systems using NonTransactionalTargetSystem: Kafka Schema Registry, message queues, object storage (S3), REST APIs, file systems, cache systems, feature flags, search engines  ","version":"1.0.0","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#installation","content":" No specific dependencies are required for DefaultTargetSystem. You can add any dependencies needed for your specific use case.  ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#basic-setup","content":" Configure the target system:  var schemaRegistry = new NonTransactionalTargetSystem(&quot;kafka-schema-registry-id&quot;);   Unlike specialized target systems, NonTransactionalTargetSystem requires no mandatory constructor dependencies. You have complete flexibility to inject whatever dependencies your Changes need.  Register Target System Once created, you need to register this target system with Flamingock. See Registering target systems for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System Configuration‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#target-system-configuration","content":" The Non-transactional target system uses Flamingock's split dependency resolution architecture with separate flows for target system configuration and change execution dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (None)‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#constructor-dependencies-none","content":" Unlike specialized target systems, NonTransactionalTargetSystem requires no mandatory constructor dependencies:  // Only requires the target system name var targetSystem = new NonTransactionalTargetSystem(&quot;system-name-id&quot;);   ","version":"1.0.0","tagName":"h3"},{"title":"Dependencies Available to Changes‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#dependencies-available-to-changes","content":" Changes can access dependencies through dependency injection with fallback:  Method\tDescription.addDependency(object)\tAdd a dependency by type for changes .addDependency(name, object)\tAdd a named dependency for changes .setProperty(key, value)\tSet a configuration property for changes  Target system context (highest priority) - any dependencies added via .addDependency() or properties via .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#configuration-example","content":" Here's a comprehensive example showing the new architecture:  // Target system configuration (no mandatory constructor dependencies) var schemaRegistry = new DefaultTargetSystem(&quot;kafka-schema-registry&quot;) .addDependency(schemaRegistryClient) // Additional dependency for changes .addDependency(&quot;registry-url&quot;, &quot;http://schema-registry:8081&quot;) // Named dependency .setProperty(&quot;compatibility.level&quot;, &quot;BACKWARD&quot;); // Configuration property // Global context with shared dependencies Flamingock.builder() .addDependency(metricsService) // Available to all target systems .addDependency(notificationService) // Available to all target systems .addTargetSystems(schemaRegistry) .build();   Target system configuration resolution:  No mandatory dependencies: Target system created with name onlyAdditional dependencies: Added via .addDependency() methodsConfiguration properties: Added via .setProperty() method  Change dependency resolution for Changes in &quot;kafka-schema-registry&quot;:  SchemaRegistryClient: From target system additional dependenciesRegistry URL: From target system context as named dependency (&quot;registry-url&quot;)Compatibility level: From target system context as property (&quot;compatibility.level&quot;)MetricsService: From global context (fallback)NotificationService: From global context (fallback)  This architecture provides maximum flexibility while maintaining clear separation between target system setup and change execution.  How compensation works:  No transaction boundaries: Operations execute immediately with no automatic rollbackRollback execution: If any failure occurs, Flamingock calls the @Rollback methodManual compensation: You provide the logic to undo or compensate for the changes made  Important: Always provide @Rollback methods for NonTransactionalTargetSystem Changes to ensure safe rollback capabilities.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in Changes‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#available-dependencies-in-changes","content":" Your Changes can inject any dependencies you add to the target system context via .addDependency() or properties via .setProperty(), which take precedence over global dependencies. Common examples include system clients, configuration values, custom services, and properties.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Non-transactional Target System","url":"/docs/target-systems/non-transactional-target-system#next-steps","content":" Learn about Target systemsExplore ChangesSee NonTransactionalTargetSystem examples ","version":"1.0.0","tagName":"h2"},{"title":"Target systems","type":0,"sectionRef":"#","url":"/docs/target-systems/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Why target systems matter‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#why-target-systems-matter","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Explicit ownership‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#explicit-ownership","content":" Every change is tied to a named target system, avoiding ambiguity and enabling clear governance.  ","version":"1.0.0","tagName":"h3"},{"title":"Transactionality awareness‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#transactionality-awareness","content":" Transactional target systems (like PostgreSQL, MySQL, or MongoDB with transactions) allow Flamingock to use native rollback and guarantees.Non-transactional systems (like S3, Kafka, or REST APIs) are still safe, but Flamingock relies on rollback methods you provide.  This distinction is built into the target system definition.  For detailed information on transaction handling, see Transactions.  ","version":"1.0.0","tagName":"h3"},{"title":"Dependency isolation‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#dependency-isolation","content":" Each target system provides its own dependency context, ensuring target system isolation. This means each system has its own set of dependencies that are isolated from other target systems, providing clear boundaries and preventing dependency conflicts between different systems, while still supporting global dependency injection as a fallback.  This isolation enables:  Clear ownership of dependencies per target systemPrevention of cross-system dependency conflictsEasier testing and debugging of system-specific changes  ","version":"1.0.0","tagName":"h3"},{"title":"Target system implementations‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#target-system-implementations","content":" Flamingock provides target system implementations to handle specific behavior when needed. While most external systems work perfectly with the standard NonTransactionalTargetSystem, concrete implementations exist primarily to leverage native capabilities like transaction support. As the ecosystem evolves, new implementations may be added by the Flamingock team, community, or even custom-built by users - though custom implementations are rarely necessary.  ","version":"1.0.0","tagName":"h2"},{"title":"Non-transactional target system‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#non-transactional-target-system","content":" The standard choice for systems without native transaction support:  Non-transactional target system - For Kafka, S3, REST APIs, feature flags, file systems, and any other non-transactional system  ","version":"1.0.0","tagName":"h3"},{"title":"Transactional target systems‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#transactional-target-systems","content":" These implementations leverage native transaction capabilities for automatic rollback:  MongoDB target system - For MongoDB with the sync driverMongoDB Spring Data target system - For MongoDB with Spring DataSQL target system - For relational databases (PostgreSQL, MySQL, etc.)DynamoDB target system - For Amazon DynamoDBCouchbase target system - For Couchbase  ","version":"1.0.0","tagName":"h3"},{"title":"Target system configuration‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#target-system-configuration","content":" Target systems are configured using a strict, no-fallback approach with explicit parameters:  Mandatory configuration: Provided through constructor parameters only  Must be provided at target system creation timeNo fallback to global contextExample: MongoClient and databaseName for MongoDB target systems  Optional configuration: Provided through .withXXX() methods only  No fallback to global contextUses sensible defaults if not providedExample: WriteConcern, connection pool settings  // Mandatory configuration via constructor var mongoTarget = new MongoDBSyncTargetSystem(&quot;targetsystem-id&quot;, mongoClient, &quot;userDatabase&quot;); // Optional configuration via .withXXX() methods mongoTarget.withWriteConcern(WriteConcern.MAJORITY) .withConnectionTimeout(5000);   No global context fallback - target system configuration must be explicit and complete.  ","version":"1.0.0","tagName":"h2"},{"title":"Registering target systems‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#registering-target-systems","content":" Target systems are registered at runtime. You can define and register as many as you need:  Flamingock BuilderSpring Boot Use the Flamingock builder for standalone applications: var mysql = new SqlTargetSystem(&quot;mysql-inventory-id&quot;, dataSource); var s3 = new NonTransactionalTargetSystem(&quot;aws-s3-id&quot;); var kafka = new NonTransactionalTargetSystem(&quot;kafka-stock-id&quot;); Flamingock.builder() .setAuditStore(new MongoDBSyncAuditStore(mongoClient, mongoDatabase)) .addTargetSystems(mysql, s3, kafka) .build() .run(); At startup, Flamingock automatically injects the right dependencies from the corresponding target system into each Change.  ","version":"1.0.0","tagName":"h2"},{"title":"Linking Changes to target systems‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#linking-changes-to-target-systems","content":" When defining Changes, you specify which target system they belong to using the @TargetSystem annotation:  @TargetSystem(&quot;mysql-inventory-id&quot;) @Change(id = &quot;add-category&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_AddCategory { //... }   ","version":"1.0.0","tagName":"h2"},{"title":"Dependency injection‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#dependency-injection","content":" Dependency injection is the mechanism used for change execution, providing the dependencies that Changes need to perform their operations. Each target system exposes specific dependencies required by its Changes:  A MongoDB target system provides a MongoDatabase, ClientSessionA Kafka target system provides a KafkaTemplateA SQL target system provides a Connection or DataSource  Flamingock uses a flexible, multi-source approach with fallback hierarchy for change execution:  Target system context (highest priority) - includes configuration parameters from constructor + .withXXX() methodsTarget system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  info Target system configuration parameters (from constructor and .withXXX() methods) are automatically available as change dependencies with highest priority.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Cloud Edition visibility‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#cloud-edition-visibility","content":" In the Cloud Edition, target systems become a first-class part of the dashboard:  See all changes grouped by target systemFilter execution history by systemTrack failures and recoveries per system  This makes it easier to govern and audit distributed environments at scale.  ","version":"1.0.0","tagName":"h2"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#best-practices","content":" Use descriptive names (mysql-inventory, aws-s3, kafka-stock)Be consistent across related ChangesAvoid generic names like &quot;database&quot; or &quot;api&quot;Provide rollback logic for non-transactional systemsKeep dependencies scoped to the system they belong to ‚Äî don‚Äôt overload the general context when they are system-specific  Key Takeaway: Target systems provide the foundation for safe, auditable changes across your entire technology stack. By explicitly declaring and configuring them, you enable Flamingock to orchestrate complex distributed system evolution with confidence. ","version":"1.0.0","tagName":"h2"},{"title":"SQL Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/sql-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Installation‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#installation","content":" Add a JDBC driver dependency for your database. For example, for PostgreSQL:  GradleMaven implementation(&quot;org.postgresql:postgresql:42.3.0&quot;)   You can use any JDBC driver for your database. Common examples include:  MySQL: com.mysql:mysql-connector-jOracle: com.oracle.database.jdbc:ojdbc8SQL Server: com.microsoft.sqlserver:mssql-jdbcH2: com.h2database:h2HSQLDB: org.hsqldb:hsqldbAnd any other JDBC-compliant driver  ","version":"1.0.0","tagName":"h2"},{"title":"Basic setup‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#basic-setup","content":" Configure the target system:  var sqlTarget = new SqlTargetSystem(&quot;inventory-database-id&quot;, dataSource);   The constructor requires the target system name and DataSource. Optional configurations can be added via .withXXX() methods.  Register Target System Once created, you need to register this target system with Flamingock. See Registering target systems for details.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System Configuration‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#target-system-configuration","content":" The SQL target system uses Flamingock's split dependency resolution architecture with separate flows for target system configuration and change execution dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Constructor Dependencies (Mandatory)‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#constructor-dependencies-mandatory","content":" These dependencies must be provided at target system creation time with no global context fallback:  Dependency\tConstructor Parameter\tDescriptionDataSource\tdataSource\tJDBC DataSource connection pool - required for both target system configuration and change execution  ","version":"1.0.0","tagName":"h3"},{"title":"Dependencies Available to Changes‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#dependencies-available-to-changes","content":" Changes can access dependencies through dependency injection with fallback:  Target system context (highest priority) - DataSource, Connection, plus any added via .addDependency()Target system additional dependencies - added via .addDependency() or .setProperty()Global context (fallback) - shared dependencies available to all target systems  ","version":"1.0.0","tagName":"h2"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#configuration-example","content":" Here's a comprehensive example showing the new architecture:  // Target system configuration (mandatory via constructor) var sqlTarget = new SqlTargetSystem(&quot;inventory-database&quot;, inventoryDataSource) .addDependency(inventoryService); // Additional dependency for changes // Global context with shared dependencies Flamingock.builder() .addDependency(emailService) // Available to all target systems .addDependency(logService) // Available to all target systems .addTargetSystems(sqlTarget) .build();   Target system configuration resolution:  DataSource: Must be provided via constructor (inventoryDataSource)  Change dependency resolution for Changes in &quot;inventory-database&quot;:  DataSource: From target system context (inventoryDataSource)Connection: From target system context (derived from inventoryDataSource)InventoryService: From target system additional dependenciesEmailService: From global context (fallback)LogService: From global context (fallback)  This architecture ensures explicit target system configuration while providing flexible dependency access for changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#transactional-support","content":" For a Change to leverage SQL's transactional capabilities, it must use either the DataSource or Connection parameter. Flamingock uses the injected DataSource dependency to create connections and manage the transaction lifecycle - starting the transaction before execution, committing on success, and rolling back on failure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;inventory-database-id&quot;) @Change(id = &quot;update-products&quot;, author = &quot;team&quot;) // order extracted from filename public class _20250923_01_UpdateProducts { @Apply public void apply(DataSource dataSource) throws SQLException { // DataSource automatically participates in transactions // Flamingock uses the target system's DataSource for transaction management // and handles transaction start, commit, and rollback automatically try (Connection conn = dataSource.getConnection()) { try (PreparedStatement stmt = conn.prepareStatement( &quot;INSERT INTO products (id, name, price) VALUES (?, ?, ?)&quot;)) { stmt.setString(1, &quot;P001&quot;); stmt.setString(2, &quot;Updated Product&quot;); stmt.setBigDecimal(3, new BigDecimal(&quot;19.99&quot;)); stmt.executeUpdate(); } } } }   You can also inject a Connection directly if you prefer to work with connections instead of DataSource:  @TargetSystem(&quot;inventory-database-id&quot;) @Change(id = &quot;create-indexes&quot;, author = &quot;team&quot;) // order extracted from filename public class CreateIndexes { @Apply public void apply(Connection connection) throws SQLException { // Connection automatically participates in transactions // Flamingock uses the target system's connection for transaction operations // and handles transaction lifecycle automatically try (Statement stmt = connection.createStatement()) { stmt.execute(&quot;CREATE INDEX idx_product_name ON products(name)&quot;); } } }   How transactions work:  Connection management: Flamingock uses the target system's DataSource to obtain database connectionsTransaction management: The same DataSource or Connection handles transaction operations (begin, commit, rollback)Lifecycle: Flamingock automatically manages transaction boundaries, committing on success or rolling back on failure  Without the DataSource or Connection parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in Changes‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#available-dependencies-in-changes","content":" Your Changes can inject SQL-specific dependencies like DataSource and Connection, but are not limited to these. The target system provides these dependencies through its context, and you can add additional dependencies via .addDependency() that take precedence over global dependencies.  For comprehensive details on change dependency resolution, see Change Anatomy &amp; Structure.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#next-steps","content":" Learn about Target systemsExplore ChangesSee SQL examples ","version":"1.0.0","tagName":"h2"},{"title":"Templates","type":0,"sectionRef":"#","url":"/docs/templates/templates-introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#introduction","content":" Flamingock Templates are experimental modules designed to streamline the integration of common third-party services, databases, and configurations into the Flamingock change management system. These templates provide a structured way to define system changes in declarative format (such as YAML files), reducing the need for custom code-based Changes while ensuring execution and versioning of changes.  ","version":"1.0.0","tagName":"h2"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#how-it-works","content":" Flamingock Templates are designed to simplify change definitions by extracting reusable logic into modular building blocks. While Flamingock‚Äôs core approach relies on code-based Changes to manage database and system changes, Flamingock Templates provide a low-code alternative that simplifies the process for common integration scenarios. Instead of writing Java classes for each migration, users can leverage existing templates by defining changes in a declarative format(YAML, etc.).  ","version":"1.0.0","tagName":"h2"},{"title":"Who Provides Templates?‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#who-provides-templates","content":" Templates can be:  Provided by the Flamingock core team (e.g., SQL, Kafka, Redis)Offered by the communityCreated internally by teams to address common patterns in their own systems  This makes them highly adaptable: whether you're integrating a database, messaging system, or internal service, templates give you a low-code mechanism to structure your system changes cleanly and consistently.  ","version":"1.0.0","tagName":"h3"},{"title":"Why Do Templates Exist?‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#why-do-templates-exist","content":" Templates exist to solve a common problem in traditional, code-based changes: duplicated logic across Changes.  Instead of repeating the same boilerplate code over and over, templates let you externalize the logic into a reusable definition and parameterize what's different.  Today, Flamingock templates can already be created and used in your own projects. However, the official templates provided by the Flamingock team are experimental, and their APIs may change before GA.  ","version":"1.0.0","tagName":"h3"},{"title":"Key Features‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#key-features","content":" Reusable modules: Each template provides a well-defined structure for managing system changes and configurations.Declarative Changes: Users define changes in YAML, avoiding Java boilerplate.Support for third-party integrations: Includes databases, messaging systems, and cloud configurations.Automatic execution and versioning: Templates are applied and tracked as part of Flamingock's change management process.Designed to encourage best practices, though still experimental.Extensible by the community: Developers can contribute new templates to expand Flamingock's ecosystem.  ","version":"1.0.0","tagName":"h2"},{"title":"When Template-based Changes Shine‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#when-template-based-changes-shine","content":" Template-based Changes are ideal when you have reusable patterns in your system changes. They excel in scenarios where the same type of operation needs to be repeated with different parameters, allowing you to avoid duplicating boilerplate code across multiple Changes.  Templates shine when:  You have repetitive patterns: Creating database tables, indexes, Kafka topics, S3 buckets, or API configurations that follow the same structure but with different valuesMultiple team members need to make similar changes: Templates provide a consistent, declarative way for developers to define changes without writing boilerplate codeYou want to enforce best practices: Templates encapsulate proven logic and prevent implementation inconsistencies across your changesThe change type already has a template: Why reinvent the wheel when S3, Kafka, SQL, MongoDB, or other common templates already exist?  Stick with code-based Changes when:  You have unique, one-off logic: Complex business transformations that are specific to your application and unlikely to be repeatedYou need maximum flexibility: Custom integrations or complex workflows that require full programmatic controlNo suitable template exists: When your use case doesn't match any available templates and creating a custom template isn't justified  Remember: Templates can handle any level of complexity - from simple configuration updates to sophisticated multi-step operations. The decision isn't about complexity, but about reusability and whether the pattern is worth abstracting into a declarative format.  Flamingock Templates unlock new possibilities for application evolution. Whether you're managing databases, configurations, or third-party services, templates simplify the process, though they are still experimental and not yet recommended for production use.  tip Join the Flamingock community and start building your own templates today! üöÄ ","version":"1.0.0","tagName":"h2"},{"title":"Testing Flamingock","type":0,"sectionRef":"#","url":"/docs/testing/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#introduction","content":" This section provides guidance on how to test applications that use Flamingock, including strategies for validating your change logic, ensuring proper execution coordination, and maintaining audit and rollback guarantees.  Whether you are running Flamingock in a local development environment, as part of CI pipelines, or through framework integrations like Spring Boot, testing is a key part of ensuring consistency and reliability across deployments.  Flamingock is not limited to database systems ‚Äî it supports a wide range of targets (e.g., message brokers, file systems, APIs). Your testing strategy should reflect the behavior of the underlying systems you integrate with.  ","version":"1.0.0","tagName":"h2"},{"title":"What to test‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#what-to-test","content":" There are three primary levels at which Flamingock-related functionality can be tested:  ","version":"1.0.0","tagName":"h2"},{"title":"1. Unit test: Change logic‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#1-unit-test-change-logic","content":" Isolate and test the logic inside your @Apply and @Rollback methods without involving Flamingock‚Äôs runtime or audit mechanism.  Use mocks for dependencies (e.g., MongoTemplate, DynamoDbClient, S3Client)Focus on business correctness and expected side effectsNo audit logs or locking are involved  üëâ See Unit testing your change units  ","version":"1.0.0","tagName":"h3"},{"title":"2. Integration test: Flamingock execution‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#2-integration-test-flamingock-execution","content":" Run Flamingock end-to-end in a controlled environment to verify:  Execution of the @Apply methodAudit log persistenceRollback behavior on failure  This usually requires a real or containerized backend system (e.g., using Testcontainers).  üëâ See Integration testing Flamingock  ","version":"1.0.0","tagName":"h3"},{"title":"3. Spring Boot integration‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#3-spring-boot-integration","content":" For applications using Spring Boot, test how Flamingock integrates with your app lifecycle:  Use @SpringBootTest to validate full configurationConfirm that changes run on startupOptionally inject mocks to verify execution paths  üëâ See Testing with Spring Boot ","version":"1.0.0","tagName":"h3"},{"title":"How to use Flamingock Templates","type":0,"sectionRef":"#","url":"/docs/templates/templates-how-to-use","content":"","keywords":"","version":"1.0.0"},{"title":"Step 1: Add the Template dependency‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-1-add-the-template-dependency","content":" Ensure your Flamingock Template dependency is included in your project. Example of using sql-template:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community-sql-template&quot;)   ","version":"1.0.0","tagName":"h3"},{"title":"Step 2: define a Template-based change‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-2-define-a-template-based-change","content":" In Flamingock, a Change represents a single unit of work that needs to be applied to your system ‚Äî for example, creating a table, updating a configuration, or setting up a cloud resource.  When using template-based changes, instead of implementing a code-based file to define the logic of the change, you describe the change in a declarative format (e.g., YAML file). The structure you use will depend on the template you‚Äôre leveraging.  Create a YAML file (e.g., _20250923_01_CreatePersonsTable.yaml) inside your application‚Äôs resources directory:  id: CreatePersonsTableFromTemplate targetSystem: &quot;database-system&quot; templateName: sql-template recovery: strategy: ALWAYS_RETRY # Safe to retry - CREATE TABLE IF NOT EXISTS semantics apply: | CREATE TABLE IF NOT EXISTS Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) ) rollback: &quot;DROP TABLE IF EXISTS Persons;&quot;   info Note that your application must provide a java.sql.Connection instance as a dependency to Flamingock.  üîç Understanding the configuration attributes‚Äã  id: Unique identifier for the change, used for tracking (same as in code-based changes).order: Execution order relative to other changes (also shared with code-based).targetSystem: Specifies which target system this change applies to - required for all template-based changes, just like code-based Changes.templateName: Indicates which template should be used to handle the change logic. This is required for all template-based changes.apply: Direct apply logic for the change. The format depends on the template type (string for SQL, map for MongoDB, etc.).rollback: Direct rollback logic for the change. The format depends on the template type (string for SQL, map for MongoDB, etc.).recovery: Optional failure handling configuration. Contains: strategy: Can be MANUAL_INTERVENTION (default if not specified) or ALWAYS_RETRY. Use ALWAYS_RETRY for idempotent operations that can be safely retried. configuration: Optional configuration parameters accessible within the apply and rollback sections. The structure and available parameters are defined by the specific template being used. configuration: timeout: 30 retryCount: 3 Other fields: Templates may define additional configuration fields as needed.  Template-based changes provide both structure and flexibility. They share the core concepts of change tracking with code-based Changes, but use a standardized format with apply and rollback sections that each template interprets according to its specific requirements. Templates can also accept optional configuration parameters to customize their behavior.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 3: Configure Flamingock to use the template file‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-3-configure-flamingock-to-use-the-template-file","content":" To configure Flamingock to use the YAML template file, you need to define a stage that includes the path to the template file using the @EnableFlamingock annotation:  @EnableFlamingock( stages = { @Stage(location = &quot;src/main/resources/templates&quot;) } ) public class MainApplication { // Configuration class }   If you prefer to use a pipeline YAML file for configuration, refer to the Setup &amp; Stages guide for more details.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 4: Run Flamingock‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-4-run-flamingock","content":" At application startup, Flamingock will automatically detect the YAML file and process it as a standard change, following the same apply flow as code-based changes.  ","version":"1.0.0","tagName":"h3"},{"title":"Use case: SQL database changes‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#use-case-sql-database-changes","content":" Let's compare how an SQL change is handled using a template-based Change vs. a traditional code-based Change.  ","version":"1.0.0","tagName":"h2"},{"title":"Approach 1: Using a Traditional Code-Based Change‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#approach-1-using-a-traditional-code-based-change","content":" @Change(id = &quot;create-persons-table&quot;, order = &quot;20250408_01&quot;, author = &quot;developer&quot;) public class CreatePersonsTableChange { private final DataSource dataSource; public CreatePersonsTableChange(DataSource dataSource) { this.dataSource = dataSource; } @Apply public void apply() throws SQLException { try (Connection connection = dataSource.getConnection(); Statement statement = connection.createStatement()) { statement.executeUpdate(&quot;&quot;&quot; CREATE TABLE Persons ( PersonID int PRIMARY KEY, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) ) &quot;&quot;&quot;); } } }   ","version":"1.0.0","tagName":"h3"},{"title":"Approach 2: Using a Flamingock SQL Template‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#approach-2-using-a-flamingock-sql-template","content":" With the SQL Template, users define the same change in YAML instead of Java:  id: createPersonsTableFromTemplate order: 20250408_01 targetSystem: &quot;database-system&quot; templateName: sql-template recovery: strategy: MANUAL_INTERVENTION # Critical DDL operation - requires manual review on failure apply: | CREATE TABLE Persons ( PersonID int PRIMARY KEY, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) ) rollback: &quot;DROP TABLE Persons;&quot;   ","version":"1.0.0","tagName":"h3"},{"title":"Key Benefits of Using a Template Instead of Code-Based Changes:‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#key-benefits-of-using-a-template-instead-of-code-based-changes","content":" Less code maintenance: No need to write Java classes, inject DataSource, manage connections, or handle SQL apply manually.Faster onboarding: YAML is easier for non-Java developers.Standardised changes: Ensures best practices and avoids custom implementation errors.Improved readability: Easier to review and version control.Configurable flexibility: Templates can be customized through configuration parameters without code changes. ","version":"1.0.0","tagName":"h3"},{"title":"Create your own Flamingock template","type":0,"sectionRef":"#","url":"/docs/templates/create-your-own-template","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#introduction","content":" Flamingock Templates allow you to encapsulate common logic and reduce boilerplate when defining change units. This document explains how to create your own templates for reuse across projects or for contribution to the Flamingock community.  ","version":"1.0.0","tagName":"h2"},{"title":"Overview of the required components‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#overview-of-the-required-components","content":" To create a template, you need:  A Java class extending AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt;An @Apply method to perform the main change(Optionally) A @Rollback method for undo supportA service loader registration file (META-INF/services)(Optional) Package and distribute your template  ","version":"1.0.0","tagName":"h2"},{"title":"1. Implement the Template class‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#1-implement-the-template-class","content":" Extend AbstractChangeTemplate&lt;SHARED_CONFIG, APPLY, ROLLBACK&gt; with three generics:  SHARED_CONFIG: Shared configuration that applies to both apply and rollback (e.g., database connection, common settings). Use Void if no shared config is needed.APPLY: The type representing the apply logic/dataROLLBACK: The type representing the rollback logic/data  Example:  public class MongoChangeTemplate extends AbstractChangeTemplate&lt;Void, MongoOperation, MongoOperation&gt; { public MongoChangeTemplate() { super(MongoOperation.class); } @Apply public void apply(MongoDatabase db, @Nullable ClientSession clientSession) { if (this.isTransactional &amp;&amp; clientSession == null) { throw new IllegalArgumentException(String.format(&quot;Transactional change[%s] requires transactional ecosystem with ClientSession&quot;, changeId)); } executeOp(db, applyPayload, clientSession); } @Rollback public void rollback(MongoDatabase db, @Nullable ClientSession clientSession) { if (this.isTransactional &amp;&amp; clientSession == null) { throw new IllegalArgumentException(String.format(&quot;Transactional change[%s] requires transactional ecosystem with ClientSession&quot;, changeId)); } executeOp(db, rollbackPayload, clientSession); } private void executeOp(MongoDatabase db, MongoOperation op, ClientSession clientSession) { op.getOperator(db).apply(clientSession); } }   Important notes‚Äã  Access your apply and rollback data directly via this.applyPayload and this.rollbackPayload fields.Access shared configuration via this.configuration field (if using a non-Void shared config type).If your template references custom types, make sure to register them for reflection‚Äîespecially for GraalVM native builds. When extending AbstractChangeTemplate, you can pass your custom types to the superclass constructor to ensure proper reflection support.  note See 2. Define Execution and Rollback methods section for how to implement the core logic inside your template class using the apply/rollback data and dependency injection  ","version":"1.0.0","tagName":"h2"},{"title":"2. Define Execution and Rollback methods‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#2-define-execution-and-rollback-methods","content":" Each template must include an @Apply method, and may optionally include a @Rollback method. These methods define the core logic that will be executed when Flamingock runs the corresponding change.  Inside these methods, it‚Äôs expected that you use the data provided by the user in the template-based change unit through the following fields:  this.applyPayload ‚Äî the apply logic/data to apply during apply phasethis.rollbackPayload ‚Äî the rollback logic/data to apply during rollback or undothis.configuration ‚Äî shared configuration data (if using a non-Void shared config type)  An example of a template for Kafka topic management:  info This is an illustrative example to demonstrate the template structure. Real Kafka templates would use different parameters and configuration structures based on actual requirements.  public class KafkaTopicTemplate extends AbstractChangeTemplate&lt;Void, TopicConfig, String&gt; { public KafkaTopicTemplate() { super(TopicConfig.class); } @Apply public void apply(AdminClient adminClient) throws Exception { // Create topic using the apply configuration var newTopic = new NewTopic( this.applyPayload.getName(), this.applyPayload.getPartitions(), this.applyPayload.getReplicationFactor() ); newTopic.configs(this.applyPayload.getConfigs()); adminClient.createTopics(List.of(newTopic)).all().get(); } @Rollback public void rollback(AdminClient adminClient) throws Exception { // Delete topic using the rollback topic name adminClient.deleteTopics(List.of(this.rollbackPayload)).all().get(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Example with Shared Configuration‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#example-with-shared-configuration","content":" When you need to share configuration between apply and rollback (such as connection details, common settings, etc.), you can use a non-Void shared configuration type:  info This is an illustrative example to demonstrate the shared configuration pattern. Real S3 templates would use different parameters and configuration structures based on actual AWS SDK requirements.  public class S3BucketTemplate extends AbstractChangeTemplate&lt;S3ConnectionConfig, BucketCreationRequest, String&gt; { public S3BucketTemplate() { super(S3ConnectionConfig.class, BucketCreationRequest.class); } @Apply public void apply() { // Access shared configuration for AWS connection AmazonS3 s3Client = AmazonS3ClientBuilder.standard() .withRegion(this.configuration.getRegion()) .withCredentials(this.configuration.getCredentialsProvider()) .build(); // Create bucket using apply configuration var request = new CreateBucketRequest(this.applyPayload.getBucketName()) .withCannedAcl(this.applyPayload.getAcl()); if (this.applyPayload.getEncryption() != null) { // Apply encryption settings request.withObjectLockEnabledForBucket(this.applyPayload.getEncryption().isEnabled()); } s3Client.createBucket(request); } @Rollback public void rollback() { // Use the same shared configuration for rollback AmazonS3 s3Client = AmazonS3ClientBuilder.standard() .withRegion(this.configuration.getRegion()) .withCredentials(this.configuration.getCredentialsProvider()) .build(); // Delete bucket using rollback bucket name s3Client.deleteBucket(this.rollbackPayload); } }   This pattern is useful when:  Both apply and rollback need the same configuration data (AWS credentials, region, etc.)You want to avoid duplicating connection details or common settingsThe template needs different data for apply vs rollback operations  ","version":"1.0.0","tagName":"h3"},{"title":"Injecting dependencies into Template methods‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#injecting-dependencies-into-template-methods","content":" Template methods (such as those annotated with @Apply and @Rollback) support method-level dependency injection using the same mechanism as change units.  Template classes do not support constructor injection. All dependencies must be injected as parameters in the @Apply and @Rollback methods.  You can inject any registered dependency as a method parameter:  @Apply public void apply(MongoDatabase db, ClientService clientService) { clientService.doSomething(); }   info Flamingock will apply lock-safety guards unless you annotate the parameter with @NonLockGuarded.  ","version":"1.0.0","tagName":"h3"},{"title":"Mapping between template-base change file and template methods‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#mapping-between-template-base-change-file-and-template-methods","content":" Flamingock automatically maps the apply and rollback sections in your declarative change unit to the corresponding methods in your template class.  ","version":"1.0.0","tagName":"h3"},{"title":"3. Register the Template with ServiceLoader‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#3-register-the-template-with-serviceloader","content":" Templates are discovered automatically at runtime using Java‚Äôs ServiceLoader system.  Steps:  Create a file at:  src/main/resources/META-INF/services/io.flamingock.core.api.template.ChangeTemplate   List the fully qualified class names of all templates in the file:  io.flamingock.template.kafka.CreateTopicTemplate io.flamingock.template.kafka.UpdateTopicConfigTemplate io.flamingock.template.kafka.DeleteTopicTemplate   tip Group templates by domain or technology for better maintainability.  ","version":"1.0.0","tagName":"h2"},{"title":"4. Package and distribute the Template‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#4-package-and-distribute-the-template","content":" Depending on your target:  ","version":"1.0.0","tagName":"h2"},{"title":"Internal Templates (Private)‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#internal-templates-private","content":" No special packaging needed.Keep your template class inside your application.  ","version":"1.0.0","tagName":"h3"},{"title":"Public Templates (Contributing to the Community)‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#public-templates-contributing-to-the-community","content":" Package your template as a JAR.Notify the Flamingock team via development@flamingock.io or GitHub.Submit your template for validation.  Validation Requirements:‚Äã  Clear and justified use caseName must align and not conflict with existing templatesTechnically correct and production-grade implementationPublic classes must be Javadoc-documentedSubmit a Pull Request adding the template's documentation to flamingock.github.io  ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Best Practices‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#-best-practices","content":" Use AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt; with the appropriate generic types for your use case.Always provide an @Rollback method if rollback or undo is expected.Use Void for generics when that type is not needed (e.g., &lt;Void, String, String&gt; for simple SQL templates).Use shared configuration (&lt;ConfigType, Void, Void&gt;) when both apply and rollback need the same configuration data.Document your template's purpose and generic types clearly for users.Ensure all custom types are registered for reflection by passing them to the superclass constructor, especially when targeting native builds.Group multiple templates by domain when packaging a library. ","version":"1.0.0","tagName":"h2"},{"title":"Integration Testing","type":0,"sectionRef":"#","url":"/docs/testing/integration-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#introduction","content":" Integration tests ensure that Flamingock operates correctly in a real environment by executing changes against live systems ‚Äî such as databases, cloud APIs, or internal services.  These tests involve spinning up the actual backend system and running Flamingock end-to-end:  Change unit executionAudit log persistenceDistributed lock acquisition  Integration tests should be used to validate that the full pipeline behaves as expected ‚Äî from execution to rollback.  ","version":"1.0.0","tagName":"h2"},{"title":"Example: Creating an S3 bucket‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#example-creating-an-s3-bucket","content":" Suppose you have a change unit that creates an Amazon S3 bucket:  @Change(id = &quot;create-bucket&quot;, author = &quot;dev-team&quot;) // order extracted from filename public class _20250923_01_CreateS3BucketChange { @Apply public void apply(S3Client s3Client) { s3Client.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } @Rollback public void rollback(S3Client s3Client) { s3Client.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Integration test with Testcontainers‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#integration-test-with-testcontainers","content":" To test this change end-to-end, we will:  Spin up a MongoDB container to be used as Flamingock‚Äôs audit backendInject a real S3 client (mocked, localstack, or real AWS)Configure Flamingock and execute it  class IntegrationTest { static final MongoDBContainer mongoContainer = new MongoDBContainer(&quot;mongo:6.0&quot;); @BeforeAll static void initMongo() { mongoContainer.start(); } @AfterAll static void tearDown() { mongoContainer.stop(); } @Test void shouldExecuteChangeAgainstS3AndAuditToMongo() { var s3Client = S3Client.builder() .region(Region.EU_WEST_1) .build(); var mongoClient = MongoClients.create(mongoContainer.getReplicaSetUrl()); Runner runner = Flamingock.builder() .addDependency(s3Client) .addDependency(mongoClient) .setProperty(&quot;mongodb.databaseName&quot;, &quot;test-db&quot;) .build(); runner.execute(); // ‚úÖ Verify the S3 bucket was created ListBucketsResponse buckets = s3Client.listBuckets(); boolean bucketExists = buckets.buckets().stream() .anyMatch(b -&gt; b.name().equals(&quot;flamingock-test-bucket&quot;)); assertTrue(bucketExists, &quot;Expected S3 bucket was not found&quot;); // ‚úÖ Verify the change was audited in MongoDB MongoDatabase db = mongoClient.getDatabase(&quot;test-db&quot;); MongoCollection&lt;Document&gt; auditCollection = db.getCollection(&quot;flamingockAuditLogs&quot;); var document = new Document(&quot;changeId&quot;, &quot;create-bucket&quot;) .append(&quot;state&quot;,&quot;EXECUTED&quot;); Document auditEntry = auditCollection.find(document).first(); assertNotNull(auditEntry, &quot;Flamingock audit log entry was not found in MongoDB&quot;); } }   ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#-best-practices","content":" Use Testcontainers to spin up a real audit backend (e.g., MongoDB) ‚Äî this avoids the need for manual test setupRun Flamingock fully using .build().execute() ‚Äî don‚Äôt call internal methods manuallyClean up the backend between tests or isolate data with unique test identifiersValidate changes by checking the actual target system or using custom assertionsUse integration tests sparingly ‚Äî unit tests are faster and should cover most logic ","version":"1.0.0","tagName":"h2"},{"title":"Unit Testing","type":0,"sectionRef":"#","url":"/docs/testing/unit-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#introduction","content":" Unit tests focus on verifying the internal logic of a single change unit, without relying on any external system. They are fast, isolated, and ideal for validating:  That the @Apply method performs the correct logicThat the @Rollback method compensates properly on failureThat injected dependencies are used as expected (using mocks or fakes)  Unit tests are most useful when your change unit contains business logic, computation, validation, or decisions.  ","version":"1.0.0","tagName":"h2"},{"title":"Example: Creating an S3 bucket‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#example-creating-an-s3-bucket","content":" Suppose you have a change unit that creates an Amazon S3 bucket:  @Change(id = &quot;create-bucket&quot;, author = &quot;dev-team&quot;) // order extracted from filename public class _20250923_01_CreateS3BucketChange { @Apply public void apply(S3Client s3Client) { s3Client.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } @Rollback public void rollback(S3Client s3Client) { s3Client.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Writing a unit test‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#writing-a-unit-test","content":" To unit test this class, we use JUnit and a mocking library (e.g., Mockito). We'll mock the S3Client and verify the correct calls were made.  class _20250923_01_CreateS3BucketChangeTest { private final S3Client s3Client = mock(S3Client.class); private final CreateS3BucketChange change = new CreateS3BucketChange(); @Test void shouldCallCreateBucketOnExecution() { var s3Client = mock(S3Client.class); new _20250923_01_CreateS3BucketChange().apply(s3Client); verify(s3Client).createBucket(argThat(req -&gt; req.bucket().equals(&quot;flamingock-test-bucket&quot;))); } @Test void shouldCallDeleteBucketOnRollback() { var s3Client = mock(S3Client.class); new _20250923_01_CreateS3BucketChange().rollback(s3Client); verify(s3Client).deleteBucket(argThat(req -&gt; req.bucket().equals(&quot;flamingock-test-bucket&quot;))); } }   ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#-best-practices","content":" Use mocks or fakes to isolate the dependencies used in your change unitFocus only on the logic inside the @Apply and @Rollback methodsKeep assertions specific and minimal ‚Äî check that the right dependencies are calledAvoid testing Flamingock itself (e.g., locking or audit behavior ‚Äî that‚Äôs handled in integration tests)Use descriptive test names like shouldCallCreateBucketOnExecution() for readability ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot Testing","type":0,"sectionRef":"#","url":"/docs/testing/springboot-integration-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#introduction","content":" This guide explains how to write integration tests for Flamingock when using Spring Boot with the @EnableFlamingock annotation.  With this setup:  Flamingock is auto-configured using Spring Boot propertiesDependencies like Kafka AdminClient or DynamoDbClient must be declared as Spring beansThe change units are executed end-to-end using real systems (e.g., DynamoDB Local, Kafka, S3)  This test style is ideal for verifying that Flamingock interacts correctly with both its audit backend and any external systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Example: Modifying a Kafka topic and auditing to DynamoDB‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#example-modifying-a-kafka-topic-and-auditing-to-dynamodb","content":" Suppose you have a change unit that modifies a Kafka topic configuration:  @Change(id = &quot;modify-topic-config&quot;, author = &quot;dev-team&quot;) // order extracted from filename public class _20250923_02_ModifyKafkaTopicConfig { @Apply public void apply(AdminClient adminClient) { Map&lt;ConfigResource, Config&gt; configs = Map.of( new ConfigResource(ConfigResource.Type.TOPIC, &quot;orders&quot;), new Config(List.of(new ConfigEntry(&quot;retention.ms&quot;, &quot;86400000&quot;))) ); adminClient.alterConfigs(configs).all().join(); } @Rollback public void rollback(AdminClient adminClient) { Map&lt;ConfigResource, Config&gt; configs = Map.of( new ConfigResource(ConfigResource.Type.TOPIC, &quot;orders&quot;), new Config(List.of(new ConfigEntry(&quot;retention.ms&quot;, &quot;604800000&quot;))) ); adminClient.alterConfigs(configs).all().join(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Writing the test‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#writing-the-test","content":" In this test, we‚Äôll:  Spin up Kafka and DynamoDB Local using TestcontainersProvide the required beans (AdminClient, DynamoDbClient) to Spring BootAssert that the Flamingock change unit executed and was audited to DynamoDB  info Flamingock requires DynamoDbClient and other injected services (like AdminClient) to be present in the Spring ApplicationContext. Spring Boot will auto-detect them if they are declared as @Beans.  @SpringBootTest @Testcontainers @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) public class FlamingockSpringbootTest { static final KafkaContainer kafka = new KafkaContainer(DockerImageName.parse(&quot;confluentinc/cp-kafka:7.2.1&quot;)); static final GenericContainer&lt;?&gt; dynamoDb = new GenericContainer&lt;&gt;(&quot;amazon/dynamodb-local&quot;) .withExposedPorts(8000); @BeforeAll static void startContainers() { kafka.start(); dynamoDb.start(); } @AfterAll static void stopContainers() { kafka.stop(); dynamoDb.stop(); } @Bean public DynamoDbClient dynamoDbClient() { return DynamoDbClient.builder() .region(Region.US_EAST_1) .endpointOverride(URI.create(&quot;http://&quot; + dynamoDb.getHost() + &quot;:&quot; + dynamoDb.getFirstMappedPort())) .build(); } @Bean public AdminClient kafkaAdminClient() { var config = new Properties(); config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()); return AdminClient.create(config); } @Test void shouldExecuteChangeAndWriteAuditToDynamoDB() { DynamoDbClient client = dynamoDbClient(); ScanResponse scan = client.scan(ScanRequest.builder() .tableName(&quot;flamingockAuditLogs&quot;) .build()); boolean changeExecuted = scan.items().stream() .anyMatch(item -&gt; &quot;modify-topic-config&quot;.equals(item.get(&quot;changeId&quot;).s()) &amp;&amp; &quot;EXECUTED&quot;.equals(item.get(&quot;state&quot;).s())); assertTrue(changeExecuted, &quot;Audit log entry for executed change not found in DynamoDB&quot;); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Advanced configuration‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#advanced-configuration","content":" Flamingock can be configured using Spring Boot properties, either in your application.yaml or dynamically via @DynamicPropertySource.  This is especially useful for setting values like:  @DynamicPropertySource static void overrideProperties(DynamicPropertyRegistry registry) { String endpoint = &quot;http://&quot; + dynamoDb.getHost() + &quot;:&quot; + dynamoDb.getFirstMappedPort(); registry.add(&quot;flamingock.dynamodb.readCapacityUnits&quot;, () -&gt; 5L); registry.add(&quot;flamingock.dynamodb.writeCapacityUnits&quot;, () -&gt; 5L); registry.add(&quot;flamingock.dynamodb.autoCreate&quot;, () -&gt; true); registry.add(&quot;flamingock.dynamodb.auditRepositoryName&quot;, () -&gt; &quot;flamingockAuditLogs&quot;); registry.add(&quot;flamingock.dynamodb.lockRepositoryName&quot;, () -&gt; &quot;flamingockLocks&quot;); }   These properties allow Flamingock to connect to the appropriate DynamoDB instance and create its internal metadata tables automatically.  ","version":"1.0.0","tagName":"h2"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#best-practices","content":" Declare all required dependencies (like DynamoDbClient, AdminClient, etc.) as Spring beansUse @DynamicPropertySource to inject dynamic config for local/test environmentsValidate both the external effect (Kafka, S3, etc.) and the audit record in the backendUse Testcontainers for isolation and reproducibility across environmentsKeep tests focused: use Spring Boot only when testing real integration scenarios (not just logic) ","version":"1.0.0","tagName":"h2"}],"options":{"languages":["en"],"id":"default"}}