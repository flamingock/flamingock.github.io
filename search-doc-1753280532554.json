{"searchDocs":[{"title":"Cloud Edition","type":0,"sectionRef":"#","url":"/docs/cloud-edition","content":"","keywords":"","version":"1.0.0"},{"title":"What the Cloud Edition will offer​","type":1,"pageTitle":"Cloud Edition","url":"/docs/cloud-edition#what-the-cloud-edition-will-offer","content":" Once released, the Cloud Edition will enable:  Centralized dashboards to track and visualize changes across services and environmentsBuilt-in user and team management with Role-Based Access Control (RBAC)Cross-environment visibility for staging, production, and everything in betweenAdvanced template and extension support for faster integration and reuseGovernance, auditability, and compliance built into every change lifecycleMulti-tenant and multi-service support, ready for real-world deployment complexity  note The Cloud Edition still relies on the Flamingock client library to run within your application.  ","version":"1.0.0","tagName":"h2"},{"title":"What's coming in this section​","type":1,"pageTitle":"Cloud Edition","url":"/docs/cloud-edition#whats-coming-in-this-section","content":" This section will guide you through:  How to set up your Cloud Edition environmentHow to configure the Flamingock client for Cloud EditionHow to use the dashboard, explore audits, and manage servicesBest practices for working with multi-environment and multi-team setups ","version":"1.0.0","tagName":"h2"},{"title":"CLI (Coming Soon)","type":0,"sectionRef":"#","url":"/docs/cli","content":"","keywords":"","version":"1.0.0"},{"title":"Why a CLI?​","type":1,"pageTitle":"CLI (Coming Soon)","url":"/docs/cli#why-a-cli","content":" Operational control Execute change units, perform dry-runs, or trigger rollbacks without launching the full application. Maintenance tasks Inspect or fix inconsistencies in the audit log, manage stale locks, and run integrity checks. Automation &amp; scripting Integrate Flamingock operations into CI/CD pipelines, cron jobs, or custom scripts.    ","version":"1.0.0","tagName":"h2"},{"title":"Planned Features​","type":1,"pageTitle":"CLI (Coming Soon)","url":"/docs/cli#planned-features","content":" When first released, the Flamingock CLI will support:  Run change units Execute any pending change units defined in your application’s code base. (Requires passing your application JAR so the CLI can load the @ChangeUnit classes, but only if a change unit depends on code inside that JAR.) Dry-run mode Preview which change units would run and in what order—without making any changes or writing to the audit store. Rollback / Undo Revert one or more change units that have already executed (by specifying change ID, date, or tag). (Requires the application JAR if the change unit’s logic depends on application-specific classes.) Audit inspection List executed change units from the audit store and filter by criteria such as author, date range, or status. (Does not require your application JAR, since it only reads from the audit backend.) Lock management View or clear distributed locks that may have been left behind by interrupted processes. Consistency checks Compare the change-unit definitions in your code against entries in the audit log to detect mismatches or missing entries.    ","version":"1.0.0","tagName":"h2"},{"title":"Example Usage​","type":1,"pageTitle":"CLI (Coming Soon)","url":"/docs/cli#example-usage","content":" Below are illustrative commands using the fcli (Flamingock CLI) binary. If a command needs to load your change-unit classes, it must be pointed at your application JAR. Other commands (like audit inspection) work without a JAR.  # 1. Run all pending change units in 'development' profile fcli run \\ --app-jar /path/to/your-app.jar \\ --config application.yaml \\ --profile development # 2. Preview pending changes (no JAR required) fcli dry-run \\ --config application.yaml \\ --profile development # 3. Roll back a specific change by ID (requires the JAR only if rollback logic uses application classes) fcli rollback \\ --app-jar /path/to/your-app.jar \\ --change-id 0005_add_users_table \\ --config application.yaml # 4. List audit log entries, filter by author (no JAR required) fcli audit-list \\ --config application.yaml \\ --filter author=dev-team # 5. Clear any stale locks (no JAR required) fcli clear-locks \\ --config application.yaml --app-jar: Path to your compiled application JAR containing @ChangeUnit classes. Required only for commands that execute or roll back change units whose logic depends on code inside your application. --config: Flamingock configuration file (e.g., application.yaml or flamingock.properties). --profile: Spring-style profile or environment name (the CLI will pass this to Flamingock to select the right changes).   ","version":"1.0.0","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"CLI (Coming Soon)","url":"/docs/cli#getting-started","content":" Install the CLI Download and install the platform-specific fcli binary for Linux, macOS, or Windows.  Prepare your application JAR Build your project so that all @ChangeUnit classes are packaged into a single runnable JAR.  Run CLI commands Use the commands shown above—supplying --app-jar only when running or rolling back change units that depend on application-specific classes.  ","version":"1.0.0","tagName":"h2"},{"title":"Feedback & contributions​","type":1,"pageTitle":"CLI (Coming Soon)","url":"/docs/cli#feedback--contributions","content":" We welcome your feedback on the CLI design. As the CLI nears release, feel free to open issues or submit pull requests to the Flamingock CLI repository. ","version":"1.0.0","tagName":"h2"},{"title":"Couchbase","type":0,"sectionRef":"#","url":"/docs/community-edition/ce-couchbase","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#introduction","content":" This section explains how to configure and use the Flamingock Community Edition for Couchbase in applications that interact directly with Couchbase using the official Couchbase Java SDK.  This edition is intended for scenarios where your application provides a Cluster instance and its associated connection. Flamingock will work directly on this connection to track and execute database changes. It does not rely on any framework abstraction or integration.  Flamingock persists a small set of metadata documents in Couchbase to support its execution model:  Audit logs – to track the execution history of each changeDistributed locks – to coordinate execution across multiple application nodes    ","version":"1.0.0","tagName":"h2"},{"title":"Edition​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#edition","content":" This edition supports Couchbase through a dedicated artifact:  Edition Name\tJava SDK\tCouchbase Compatibilityflamingock-ce-couchbase\tcom.couchbase.client:java-client\t&gt;= 3.4.3    ","version":"1.0.0","tagName":"h2"},{"title":"Get started​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#get-started","content":" To get started with the Flamingock Community Edition for Couchbase, follow these steps:  ","version":"1.0.0","tagName":"h2"},{"title":"1. Add the required dependencies​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#1-add-the-required-dependencies","content":" GradleMaven implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-couchbase&quot;) implementation(&quot;com.couchbase.client:java-client:3.x.x&quot;)     ","version":"1.0.0","tagName":"h3"},{"title":"2. Enable Flamingock runner​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#2-enable-flamingock-runner","content":" At minimum, you must provide a Cluster instance (as a dependency):  Cluster cluster = Cluster.connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;); Runner runner = Flamingock.builder() .addDependency(cluster) .build();   ","version":"1.0.0","tagName":"h3"},{"title":"3. Execute Flamingock​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#3-execute-flamingock","content":" Once the Flamingock runner is configured and built, you can trigger Flamingock’s execution:  runner.execute();     ","version":"1.0.0","tagName":"h3"},{"title":"Configuration overview​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#configuration-overview","content":" Flamingock’s Couchbase Community Edition requires both:  A Cluster dependencyA set of configuration properties  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#dependencies","content":" These must be registered using .addDependency(...)  Type\tRequired\tDescriptioncom.couchbase.client.java.Cluster\tYes\tRequired to connect and execute against Couchbase.  ","version":"1.0.0","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#properties","content":" These must be set using .setProperty(...)  Property\tType\tRequired\tDefault Value\tDescriptionautoCreate\tboolean\tNo\ttrue\tWhether Flamingock should auto-create required buckets and indexes.  warning In production environments, we strongly recommend keeping the default configuration values unless you fully understand the implications. These defaults ensure consistency, safety, and compatibility with Flamingock’s locking and audit mechanisms.    ","version":"1.0.0","tagName":"h3"},{"title":"Full configuration example​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#full-configuration-example","content":" The following example shows how to configure Flamingock with both required and optional properties. It demonstrates how to override autoCreate, which can be useful in lower environments or when managing schema manually.  Cluster cluster = Cluster.connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;); FlamingockBuilder builder = Flamingock.builder() // mandatory dependency .addDependency(cluster) // optional configuration .setProperty(&quot;autoCreate&quot;, true);   You can add additional dependencies and properties based on your custom setup (e.g., metrics, listeners, or cloud-specific settings).    ","version":"1.0.0","tagName":"h2"},{"title":"Transaction support​","type":1,"pageTitle":"Couchbase","url":"/docs/community-edition/ce-couchbase#transaction-support","content":" ⚠️ Couchbase transactions are not currently managed automatically by Flamingock. However, Flamingock guarantees safe, idempotent changes through internal locking, auditing, and execution guarantees.  You can find some practical examples in the official GitHub repository: 👉 Flamingock Couchbase example ","version":"1.0.0","tagName":"h2"},{"title":"DynamoDB","type":0,"sectionRef":"#","url":"/docs/community-edition/ce-dynamodb","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#introduction","content":" This section explains how to configure and use the Flamingock Community Edition for DynamoDB in applications that interact with Amazon DynamoDB using the official AWS SDK for Java.  This edition is designed for use cases where the application provides its own DynamoDB client via DynamoDbClient, and Flamingock operates directly over that connection to manage changes. It does not require any framework-level integration.  Flamingock persists a minimal set of metadata in your DynamoDB tables to support its execution model:  Audit records – to track which changes have been appliedDistributed locks – to coordinate executions across multiple instances    ","version":"1.0.0","tagName":"h2"},{"title":"Edition​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#edition","content":" This is a single edition for DynamoDB, provided as a standalone artifact.  Edition Name\tJava Client\tDynamoDB Compatibilityflamingock-ce-dynamodb\tsoftware.amazon.awssdk:dynamodb\t&gt;= 2.25.29    ","version":"1.0.0","tagName":"h2"},{"title":"Get started​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#get-started","content":" To get started with the Flamingock Community Edition for DynamoDB, follow these steps:    ","version":"1.0.0","tagName":"h2"},{"title":"1. Add the required dependencies​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#1-add-the-required-dependencies","content":" You must include both the Flamingock DynamoDB edition and the AWS SDK v2 for DynamoDB in your project.  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-dynamodb&quot;) implementation(&quot;software.amazon.awssdk:dynamodb-enhanced:2.x.x&quot;) implementation(&quot;software.amazon.awssdk:url-connection-client:2.x.x&quot;)     ","version":"1.0.0","tagName":"h3"},{"title":"2. Enable Flamingock runner​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#2-enable-flamingock-runner","content":" At minimum, you must provide a DynamoDbClient instance (as a dependency)  DynamoDbClient dynamoClient = DynamoDbClient.builder() .region(Region.US_EAST_1) .build(); Runner runner = Flamingock.builder() .addDependency(dynamoClient) .build();   ","version":"1.0.0","tagName":"h3"},{"title":"3. Execute Flamingock​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#3-execute-flamingock","content":" Once the Flamingock runner is configured and built, you can trigger Flamingock’s execution:  runner.execute();     ","version":"1.0.0","tagName":"h3"},{"title":"Configuration overview​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#configuration-overview","content":" Flamingock’s DynamoDB Community Edition requires both:  A DynamoDbClient dependencyA set of configuration properties  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#dependencies","content":" These must be registered using .addDependency(...)  Type\tRequired\tDescriptionsoftware.amazon.awssdk.services.dynamodb.DynamoDbClient\tYes\tRequired to access and modify DynamoDB tables.  ","version":"1.0.0","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#properties","content":" These must be set using .setProperty(...)  Property\tType\tRequired\tDefault Value\tDescriptiondynamodb. readCapacityUnits\tLong\tNo\t5L\tRead capacity units (for PROVISIONED billing mode only). dynamodb. writeCapacityUnits\tLong\tNo\t5L\tWrite capacity units (for PROVISIONED billing mode only). dynamodb.autoCreate\tBoolean\tNo\ttrue\tAutomatically creates the required tables if they do not exist. dynamodb. auditRepositoryName\tString\tNo\tflamingockAuditLogs\tTable used to store audit records. Most users should keep the default name. dynamodb. lockRepositoryName\tString\tNo\tflamingockLock\tTable used for distributed locking. Most users should keep the default name.  warning In production environments, we strongly recommend keeping the default configuration values unless you fully understand the implications. These defaults ensure consistency, safety, and compatibility with Flamingock’s locking and audit mechanisms.    ","version":"1.0.0","tagName":"h3"},{"title":"Full configuration example​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#full-configuration-example","content":" The following example shows how to configure Flamingock with both required and optional properties. It demonstrates how to override index creation, and read/write behaviour. This level of configuration is useful when you need to customise Flamingock's behaviour to match the consistency and durability requirements of your deployment.  DynamoDbClient dynamoClient = DynamoDbClient.builder() .region(Region.US_EAST_1) .build(); FlamingockBuilder builder = Flamingock.builder() .addDependency(dynamoClient) .setProperty(&quot;autoCreate&quot;, true) .setProperty(&quot;readCapacityUnits&quot;, 5L) .setProperty(&quot;writeCapacityUnits&quot;, 5L);     ","version":"1.0.0","tagName":"h2"},{"title":"Transaction support​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#transaction-support","content":" Flamingock supports transactional execution on DynamoDB using the enhanced client’s TransactWriteItemsEnhancedRequest.Builder.  If a change unit is marked as transactional (which is the default), Flamingock will:  Create a fresh transactional builder (TransactWriteItemsEnhancedRequest.Builder) for that changeInject it into the @Execution methodExecute the transaction only if the change completes successfully — including Flamingock’s internal audit write as part of the same transaction  This ensures atomicity: either all operations defined in the change unit — including the audit log — are applied together, or none are.  warning If you mark a change unit as transactional but do not add any operations to the builder, Flamingock will still execute the transaction — but it will contain only the audit log entry. Make sure your change unit populates the TransactWriteItemsEnhancedRequest.Builder appropriately.  See the Transactions page for general guidance and best practices around transactional vs non-transactional change units.  ","version":"1.0.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"DynamoDB","url":"/docs/community-edition/ce-dynamodb#example","content":" @Execution public void execute(@NonLockGuarded DynamoDbClient client, TransactWriteItemsEnhancedRequest.Builder builder) { DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder() .dynamoDbClient(client) .build(); DynamoDbTable&lt;UserEntity&gt; table = enhancedClient.table(&quot;users&quot;, TableSchema.fromBean(UserEntity.class)); builder.addPutItem(table, new UserEntity(&quot;Alice&quot;, &quot;Anderson&quot;)); builder.addPutItem(table, new UserEntity(&quot;Bob&quot;, &quot;Bennett&quot;)); }   tip You can add as many operations as needed to the builder: putItem, updateItem, deleteItem, etc. These operations will be executed in a single atomic transaction, together with Flamingock’s internal audit log update.  You can find more practical examples in the official GitHub repository: 👉 Flamingock DynamoDB example   ","version":"1.0.0","tagName":"h3"},{"title":"MongoDB (Java driver)","type":0,"sectionRef":"#","url":"/docs/community-edition/ce-mongodb-java-driver","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#introduction","content":" This section explains how to configure and use the Flamingock Community Edition for MongoDB in applications that interact directly with MongoDB using the official Java driver (mongodb-driver-sync).  This edition is designed for use cases where the application provides its own MongoDB connection via MongoClient, and Flamingock operates directly over that connection to manage changes. It does not rely on any external framework or abstraction layer.  Flamingock persists a minimal set of metadata in your MongoDB database to support its execution model:  Audit logs – to track which changes have been executedDistributed locks – to ensure safe and coordinated execution across multiple application instances  It is particularly suited to teams working in framework-agnostic or low-level environments, where integration is done directly at the driver level, and fine-grained control over MongoDB configuration is required.  Flamingock supports mongodb-driver-sync versions from 4.0.0 up to 5.x.x.    ","version":"1.0.0","tagName":"h2"},{"title":"Supported versions​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#supported-versions","content":" Flamingock Module\tMongoDB Driver\tMongoDB Compatibilityflamingock-ce-mongodb-sync\torg.mongodb:mongodb-driver-sync (4.0.0 - 5.x.x)\tMongoDB 3.x to 5.x    ","version":"1.0.0","tagName":"h2"},{"title":"Get started​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#get-started","content":" To get started with the Flamingock Community Edition for MongoDB, follow these basic steps:  ","version":"1.0.0","tagName":"h2"},{"title":"1. Add the required dependencies​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#1-add-the-required-dependencies","content":" You must include the Flamingock MongoDB sync edition and a compatible MongoDB Java driver in your project.  GradleMaven // MongoDB v4 implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-mongodb-sync&quot;) implementation(&quot;org.mongodb:mongodb-driver-sync:4.x.x&quot;)   ","version":"1.0.0","tagName":"h3"},{"title":"2. Enable Flamingock runner​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#2-enable-flamingock-runner","content":" At minimum, you must provide:  A MongoDatabase (as a dependency)A MongoClient instance (as a dependency)  MongoClient mongoClient = MongoClients.create(&quot;mongodb://localhost:27017&quot;); MongoDatabase mongoDatabase = mongoClient.getDatabase(&quot;YOUR_DATABASE&quot;); Runner runner = Flamingock.builder() .addDependency(mongoDatabase) .addDependency(mongoClient) // other optional configurations .build();   For production, we strongly recommend using the default MongoDB configuration values unless you fully understand the implications.  ","version":"1.0.0","tagName":"h3"},{"title":"3. Execute Flamingock​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#3-execute-flamingock","content":" Once the Flamingock runner is configured and built, you can trigger Flamingock’s execution:  runner.execute();     ","version":"1.0.0","tagName":"h3"},{"title":"Configuration overview​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#configuration-overview","content":" Flamingock requires both dependencies and configuration properties, set via the builder.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#dependencies","content":" Type\tRequired\tDescriptioncom.mongodb.client.MongoDatabase\tYes\tRequired to connect to your MongoDB database. com.mongodb.client.MongoClient\tYes\tRequired for transactional support.  ","version":"1.0.0","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#properties","content":" These must be set using .setProperty(...)  Property\tType\tDefault Value\tRequired\tDescriptionmongodb.autoCreate\tboolean\ttrue\tNo\tWhether Flamingock should automatically create required collections and indexes. mongodb.readConcern\tString\t&quot;MAJORITY&quot;\tNo\tControls the isolation level for read operations. mongodb. writeConcern.w\tString or int\t&quot;MAJORITY&quot;\tNo\tWrite acknowledgment level. Specifies how many MongoDB nodes must confirm the write for it to succeed. mongodb. writeConcern.journal\tboolean\ttrue\tNo\tWhether the write must be committed to the journal before acknowledgment. mongodb. writeConcern.wTimeout\tDuration\tDuration .ofSeconds(1)\tNo\tMaximum time to wait for the write concern to be fulfilled. mongodb. readPreference\tReadPreference Level\tReadPreferenceLevel .PRIMARY\tNo\tDefines which MongoDB node to read from. mongodb. auditRepositoryName\tString\t&quot;flamingockAuditLogs&quot;\tNo\tName of the collection for storing the audit log. Overrides the default. Most users should keep the default value. mongodb. lockRepositoryName\tString\t&quot;flamingockLock&quot;\tNo\tName of the collection used for distributed locking. Overrides the default. Most users should keep the default value.  warning We strongly recommend keeping the default configuration values in production environments. They are optimized for consistency, durability, and safety, ensuring Flamingock’s audit and rollback guarantees.  Overriding them is only appropriate in limited cases (e.g., testing or local development). If you choose to modify these settings, you assume full responsibility for maintaining the integrity and consistency of your system.  ","version":"1.0.0","tagName":"h3"},{"title":"Full configuration example​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#full-configuration-example","content":" The following example shows how to configure Flamingock with both required and optional properties. It demonstrates how to override index creation, and read/write behaviour. This level of configuration is useful when you need to customise Flamingock's behaviour to match the consistency and durability requirements of your deployment.  MongoClient mongoClient = MongoClients.create(&quot;mongodb://localhost:27017&quot;); MongoDatabase mongoDatabase = mongoClient.getDatabase(&quot;YOUR_DATABASE&quot;); FlamingockBuilder builder = Flamingock.builder() .addDependency(mongoDatabase) .addDependency(mongoClient) .setProperty(&quot;mongodb.autoCreate&quot;, true) .setProperty(&quot;mongodb.readConcern&quot;, &quot;MAJORITY&quot;) .setProperty(&quot;mongodb.writeConcern.w&quot;, &quot;MAJORITY&quot;) .setProperty(&quot;mongodb.writeConcern.journal&quot;, true) .setProperty(&quot;mongodb.writeConcern.wTimeout&quot;, Duration.ofSeconds(1)) .setProperty(&quot;mongodb.readPreference&quot;, ReadPreferenceLevel.PRIMARY&quot;);     ","version":"1.0.0","tagName":"h3"},{"title":"Transaction support​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#transaction-support","content":" Flamingock supports transactions via ClientSession when used with a compatible MongoDB deployment. Simply include it as a parameter in your change unit:  @Execution public void execute(ClientSession session, MongoDatabase db) { db.getCollection(&quot;clients&quot;) .insertOne(session, new Document(&quot;name&quot;, &quot;test&quot;)); }   The session lifecycle is managed automatically by Flamingock. If you omit the ClientSession parameter, the change will still execute, but it won't participate in a transaction.  See the Transactions page for guidance on when and how to disable transactions (e.g., transactional = false).    ","version":"1.0.0","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#examples","content":" You can find practical examples in the official GitHub repository: 👉 Flamingock MongoDB example    ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"MongoDB (Java driver)","url":"/docs/community-edition/ce-mongodb-java-driver#-best-practices","content":" Use Flamingock’s default consistency settings (writeConcern, readConcern, readPreference) in production These values guarantee strong consistency, durability, and fault tolerance. Overriding them is discouraged unless absolutely necessary. Use the default collection names (flamingockAuditLogs, flamingockLock) These help avoid collisions and simplify debugging. Enable automatic index creation unless your environment prohibits it This ensures that Flamingock can enforce audit and locking guarantees. If disabled, manage indexes manually. Ensure your MongoDB Java driver version is between 4.0.0 and 5.x.x This range is tested and supported by Flamingock. ","version":"1.0.0","tagName":"h2"},{"title":"Community Edition","type":0,"sectionRef":"#","url":"/docs/community-edition/Introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Available editions​","type":1,"pageTitle":"Community Edition","url":"/docs/community-edition/Introduction#available-editions","content":" Below is a summary of the available editions in the Flamingock Community Edition:  Edition\tDatabase\tSupported Versions\tTransactions\tLocking Support\tNotesMongoDB\tMongoDB\t&gt;=4.0\t✅ Yes\t✅ Yes\tFlamingock provides support for both low-level native drivers and high-level abstractions through Spring Data integration. DynamoDB\tAWS DynamoDB\t&gt;=2.25.29\t✅ Yes\t✅ Yes CosmosDB\tAzure Cosmos DB\tMongo API 3.6/4.0\t✅ Yes\t✅ Yes Couchbase\tCouchbase Server\t&gt;=3.4.3\t❌ No\t✅ Yes\t    ","version":"1.0.0","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Community Edition","url":"/docs/community-edition/Introduction#features","content":" Community editions support the core Flamingock feature set, including:  Ordered and versioned change executionSupport for concurrent, distributed deploymentsOptional transactional execution (if supported by the MongoDB server)  info It includes limited access to premium features, which are fully available in the Cloud and Self-Hosted editions.    Each edition has its own documentation page with setup instructions, configuration parameters, and usage examples. Use the sidebar or links below to navigate to a specific edition. ","version":"1.0.0","tagName":"h2"},{"title":"MongoDB (Spring Data)","type":0,"sectionRef":"#","url":"/docs/community-edition/ce-mongodb-springdata","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#introduction","content":" This section explains how to use the Flamingock Community Edition for MongoDB in applications that rely on Spring Data MongoDB.  This edition is designed for teams that already use Spring Data to manage their database access and want to include Flamingock as part of their change tracking and execution model. It integrates with Spring Boot and MongoTemplate, handling auditing, distributed locking, and transactional coordination.  Flamingock persists a minimal set of metadata in your MongoDB database:  Audit logs — track which changes have been appliedDistributed locks — prevent concurrent modifications in distributed deployments    ","version":"1.0.0","tagName":"h2"},{"title":"Editions​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#editions","content":" Flamingock provides two editions for Spring Data.  ","version":"1.0.0","tagName":"h2"},{"title":"Why are there two MongoDB Spring Data Community-Edition artifacts?​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#why-are-there-two-mongodb-spring-data-community-edition-artifacts","content":" The only difference is the Java version they target:  flamingock-ce-mongodb-springdata — built for the current Spring Data MongoDB 4.x line, which itself requires JDK 17 or newer.flamingock-ce-mongodb-springdata-v3-legacy — kept for teams still on Spring Data 3.x (Spring Boot 2) who must stay on JDK 8 – 11.  Choose the artifact that matches the JDK level of your application today; switching later is as simple as changing the dependency.  Edition Name\tSpring Data Versionflamingock-ce-mongodb-springdata-v3-legacy\t[3.1.4, 4.0.0) flamingock-ce-mongodb-springdata\t[4.0.0, 5.0.0)    ","version":"1.0.0","tagName":"h3"},{"title":"Get Started​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#get-started","content":" If you're using Spring Boot, the recommended approach is the automatic setup with @EnableFlamingock.  By annotating your main class with @EnableFlamingock, Flamingock will:  Automatically detect and inject Spring components (ApplicationContext, ApplicationEventPublisher, etc.)Pick up configuration from the native Spring Boot config fileCreate and register a runner bean (either ApplicationRunner or InitializingBean)Process the setup configuration from the annotation  ","version":"1.0.0","tagName":"h2"},{"title":"1. Add the required dependencies​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#1-add-the-required-dependencies","content":" GradleMaven implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-mongodb-springdata&quot;)   Legacy Support If your project uses Spring Data 3.x and Spring Boot 2.x, use the flamingock-ce-mongodb-springdata-v3-legacy edition instead.  ","version":"1.0.0","tagName":"h3"},{"title":"2. Configure setup and enable Flamingock runner​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#2-configure-setup-and-enable-flamingock-runner","content":" Choose one of the following options based on your preferred integration style:  Automatic setup (recommended): Annotate your main class with @EnableFlamingockManual builder-based setup: Use @EnableFlamingock with setup = SetupType.BUILDER and manually register the Flamingock runner bean  AutomaticBuilder @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @SpringBootApplication public class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } }     ","version":"1.0.0","tagName":"h3"},{"title":"Configuration overview​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#configuration-overview","content":" Flamingock’s MongoDB Spring Data edition requires two types of inputs:  Dependencies: These are required runtime components, such as MongoTemplateProperties: These configure Flamingock’s internal behavior and are typically declared in the Spring configuration file or via the builder.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#dependencies","content":" These must be available in the Spring context (when using automatic setup with @Flamingock) or registered via .addDependency(...) when using the builder setup.  Type\tRequired\tNotesorg.springframework.data.mongodb.core.MongoTemplate\tYes\tMust be declared as a Spring bean. org.springframework.context.ApplicationContext\tYes\tAuto-injected by Spring Boot. org.springframework.context.ApplicationEventPublisher\tYes\tAuto-injected by Spring Boot.  info Spring Boot will typically auto-configure MongoTemplate for you.  ","version":"1.0.0","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#properties","content":" Property\tType\tDefault Value\tRequired\tDescriptionmongodb.autoCreate\tboolean\ttrue\tNo\tWhether Flamingock should automatically create required collections and indexes. mongodb.readConcern\tString\t&quot;MAJORITY&quot;\tNo\tControls the level of isolation for read operations. mongodb. writeConcern.w\tString or int\t&quot;MAJORITY&quot;\tNo\tWrite acknowledgment. Specifies how many MongoDB nodes must confirm the write. mongodb. writeConcern.journal\tboolean\ttrue\tNo\tWhether the write must be written to the on-disk journal before acknowledgment. mongodb. writeConcern.wTimeout\tDuration\tDuration. ofSeconds(1)\tNo\tMaximum time to wait for the write concern to be fulfilled. mongodb. readPreference\tReadPreference Level\tReadPreferenceLevel. PRIMARY\tNo\tSpecifies which MongoDB node to read from. mongodb. auditRepositoryName\tString\t&quot;flamingockAuditLogs&quot;\tNo\tName of the collection used to store applied changes. Most users should keep the default value. mongodb. lockRepositoryName\tString\t&quot;flamingockLock&quot;\tNo\tName of the collection used for distributed locking. Most users should keep the default value.  warning It's strongly recommended keeping the default MongoDB configuration values provided by Flamingock — especially in production environments. These defaults are carefully chosen to guarantee maximum consistency, durability, and safety, which are fundamental to Flamingock’s audit and rollback guarantees.  Overriding them is only appropriate in limited cases (e.g., testing or local development). If you choose to modify these settings, you assume full responsibility for maintaining the integrity and consistency of your system.    ","version":"1.0.0","tagName":"h3"},{"title":"Full configuration example​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#full-configuration-example","content":" The following example shows how to configure Flamingock with both required and optional properties. It demonstrates how to override index creation, and read/write behaviour. This level of configuration is useful when you need to customise Flamingock's behaviour to match the consistency and durability requirements of your deployment.  AutomaticBuilder flamingock: mongodb: databaseName: flamingock-db autoCreate: true readConcern: MAJORITY writeConcern: w: MAJORITY journal: true wTimeout: 1s readPreference: PRIMARY     ","version":"1.0.0","tagName":"h3"},{"title":"Transaction support​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#transaction-support","content":" If your MongoDB deployment supports transactions, Flamingock can execute Spring Data operations within a transactional session — as long as the underlying MongoDB driver and Spring Data version allow it.  To benefit from transactional execution, simply declare your @Execution method to receive a MongoTemplate:  @Execution public void change(MongoTemplate mongoTemplate) { // This will run inside a transaction }   Internally, Flamingock will manage the transaction lifecycle and ensure all operations performed through MongoTemplate are part of a single, atomic transaction. If anything fails, the changes and the audit log will be rolled back.  There is no need to manually manage a ClientSession when using Spring Data. Flamingock integrates with Spring’s transaction management infrastructure to coordinate the session for you.  See the Transactions page for general behavior and when to use transactional = false.    ","version":"1.0.0","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#examples","content":" You can find practical examples in the official GitHub repository: 👉 github.com/flamingock/flamingock-examples/mongodb    ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"MongoDB (Spring Data)","url":"/docs/community-edition/ce-mongodb-springdata#-best-practices","content":" Use Flamingock’s default consistency settings (writeConcern, readConcern, readPreference) in production These defaults are strictly selected to guarantee strong consistency, durability, and fault-tolerance, which are fundamental to Flamingock’s execution guarantees. Overriding them is strongly discouraged in production environments, as it can compromise the integrity of audit logs and distributed coordination. Use the default repository names (flamingockAuditLogs, flamingockLock) unless you have a strong reason to change them The default names are chosen to avoid collisions and clearly identify Flamingock-managed collections. Overriding them is supported but rarely necessary. Keep indexCreation enabled unless your deployment restricts index creation at runtime This setting ensures that Flamingock creates and maintains the required indexes to enforce audit integrity and locking guarantees. Disable this only if your application does not have the necessary permissions to create indexes — and only if you manage the required indexes manually. Always match the edition to your Spring Data / MongoDB driver version ","version":"1.0.0","tagName":"h2"},{"title":"ChangeUnit dependency injection","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/changeunit-dependency-injection","content":"","keywords":"","version":"1.0.0"},{"title":"Registering dependencies​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#registering-dependencies","content":" Platform changeUnit dependencies are registered using the method addDependency(...) :  builder .addDependency(clientService);   Once registered, Flamingock can inject the requested dependency into your change unit methods or constructors.  @Execution public void execute(ClientService clientService) { // ChangeUnit's logic }   ","version":"1.0.0","tagName":"h2"},{"title":"Using name and explicit type​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#using-name-and-explicit-type","content":" Let’s say you have a base class PaymentProcessor, with two implementations: StripePaymentProcessor and PaypalPaymentProcessor.  Now imagine you're injecting both implementations like this:  addDependency(new StripePaymentProcessor()); addDependency(new PaypalPaymentProcessor());   If a change unit method requests either StripePaymentProcessor or PaypalPaymentProcessor specifically, Flamingock will inject the correct one.  But if the method requests the general type PaymentProcessor, Flamingock cannot guarantee which of the two will be used.  To solve this, Flamingock provides two mechanisms:  Named dependency​  You can register each implementation with a name:  builder .addDependency(&quot;stripe&quot;, new StripePaymentProcessor()) .addDependency(&quot;paypal&quot;, new PaypalPaymentProcessor());   Then use the javax.inject.@Named annotation in your method:  @Execution public void execute(@Named(&quot;stripe&quot;) PaymentProcessor processor) { processor.charge(...); }   Explicit typing the dependency​  Alternatively, you can register a specific instance for the general type, to ensure the right one is used by default:  builder.addDependency(PaymentProcessor.class, new StripePaymentProcessor());   Now, any method requesting a PaymentProcessor will receive the Stripe implementation — unless a named one is requested instead.    ","version":"1.0.0","tagName":"h3"},{"title":"Injection targets​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#injection-targets","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Method injection​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#method-injection","content":" You can declare dependencies as parameters of @Execution, @RollbackExecution, etc.  @Execution public void run(ClientService clientService) { clientService.doSomething(); }   ","version":"1.0.0","tagName":"h3"},{"title":"Constructor injection​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#constructor-injection","content":" You can inject dependencies through constructors:  public class CreateClientsTable { private final ClientService clientService; @FlamingockConstructor public CreateClientsTable(ClientService clientService) { this.clientService = clientService; } @Execution public void run() { clientService.doSomething(); } }   note If the class has only one constructor, the @FlamingockConstructor annotation is optional.    ","version":"1.0.0","tagName":"h3"},{"title":"What happens if a dependency isn’t found?​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#what-happens-if-a-dependency-isnt-found","content":" By default, Flamingock will throw a clear exception if it cannot resolve a dependency.  You can override this by marking the parameter as @Nullable:  import io.flamingock.core.api.annotations.Nullable; @Execution public void run(@Nullable OptionalLogger logger) { if (logger != null) { logger.log(&quot;Change started&quot;); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Skipping lock verification​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#skipping-lock-verification","content":" By default, injected dependencies are proxy-wrapped to check that the lock is still held before each call — this prevents unsafe execution if the lock expires.  If you're injecting something that doesn't perform critical side effects (like a local list or utility), you can opt out of this check:  @Execution public void run(@NonLockGuarded SomeHelper helper) { helper.doLocalStuff(); }     ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"ChangeUnit dependency injection","url":"/docs/flamingock-library-config/changeunit-dependency-injection#white_check_mark-best-practices","content":" Only inject what you need for the current change unitPrefer constructor injection when dependencies are shared across multiple methodsUse @NonLockGuarded only when you're certain no side effects are involvedDocument your dependencies to avoid confusion in large pipelines ","version":"1.0.0","tagName":"h2"},{"title":"ChangeUnits Deep Dive","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/changeunits-deep-dive","content":"","keywords":"","version":"1.0.0"},{"title":"Clarifying changeUnits​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#clarifying-changeunits","content":" A ChangeUnit is the atomic, versioned unit of change in Flamingock. It encapsulates logic to modify an external system (the target system) and provides metadata and rollback capability. ChangeUnits are discovered and executed in a defined order to ensure deterministic, auditable changes.  ","version":"1.0.0","tagName":"h2"},{"title":"What a changeUnit Is​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#what-a-changeunit-is","content":" Self-contained change Each ChangeUnit includes: A unique id (unique across the entire application)An order determining execution sequenceAn optional author and descriptionAn @Execution method (or template) with the change logicA @RollbackExecution method (or template) with compensating logicA transactional flag (default true) indicating if Flamingock will attempt to wrap execution and audit in a single transaction Versioned and Auditable ChangeUnits live in your source code or resources, and their execution is recorded in the audit store to: Prevent duplicate executionsTrack history (who ran which change and when)Drive rollbacks and “undo” operations  ","version":"1.0.0","tagName":"h3"},{"title":"What a changeUnit is not​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#what-a-changeunit-is-not","content":" Not a long-running job ChangeUnits should complete promptly. Flamingock needs to know the result (success or failure) before proceeding. Long-running or asynchronous operations can lead to unexpected behavior or retries.Not a general-purpose script While ChangeUnits run code, they are not intended for arbitrary scripting. Their role is to apply deterministic, idempotent changes that evolve your target systems in sync with your application.    ","version":"1.0.0","tagName":"h3"},{"title":"ChangeUnit properties​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#changeunit-properties","content":" Every ChangeUnit must define:  id (String): Unique across all ChangeUnits in the application.order (String or numeric): Defines execution order (evaluated lexicographically or numerically).author (String): Who is responsible for the change.description (String, optional): Brief explanation of the change.transactional (boolean, default true): Whether Flamingock will attempt to wrap the change and audit insert in one transaction (if the target system and audit store support transactions).    ","version":"1.0.0","tagName":"h2"},{"title":"Types of changeUnits​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#types-of-changeunits","content":" ChangeUnits can be defined based on two approaches: code-based and template-based  ","version":"1.0.0","tagName":"h2"},{"title":"Code-based changeUnits​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#code-based-changeunits","content":" Code-based ChangeUnits are written in Java (or Kotlin/Groovy) with annotations:  @ChangeUnit( id = &quot;create_s3_bucket&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;, transactional = false, description = &quot;Create my-app-bucket S3 bucket&quot;) public class _0001_CreateS3BucketChange { @Execution public void execute(S3Client s3Client) { s3Client.createBucket(&quot;my-app-bucket&quot;); } @RollbackExecution public void rollback(S3Client s3Client) { s3Client.deleteBucket(&quot;my-app-bucket&quot;); } }   Discoverability &amp; execution​  Location: Files must reside in a source package scanned by Flamingock (default: src/main/java).Naming: Class names should match _ORDER_name (e.g., _0001_CreateS3BucketChange) to simplify ordering and visibility.Dependencies: Flamingock injects dependencies (e.g., S3Client, MongoClient) via Spring or builder-based DI.  ","version":"1.0.0","tagName":"h3"},{"title":"Template-based changeUnits​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#template-based-changeunits","content":" Template-based ChangeUnits use YAML or JSON definitions. Example (SQL DDL):  # /src/main/resources/_0003_add_status_column.yml id: add_status_column order: 0003 author: &quot;db-team&quot; description: &quot;Add 'status' column to 'orders' table&quot; templateName: sql-template templateConfiguration: executionSql: | ALTER TABLE orders ADD COLUMN status VARCHAR(20); rollbackSql: | ALTER TABLE orders DROP COLUMN status;   Discoverability &amp; execution​  Location: While Flamingock will scan src/main/resources by default, we strongly recommend placing template files in the same code‐package/directory as your code‐based ChangeUnits. This ensures that both code‐based and template‐based ChangeUnits live side by side for visibility and immutability. Naming: File names should follow _ORDER_name.yml or _ORDER_name.json.Advantages: Easier immutability: The YAML/JSON file itself represents the change, avoiding modifications in code.Better for simple, repeatable tasks (e.g., SQL DDL).    ","version":"1.0.0","tagName":"h3"},{"title":"Considerations​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#considerations","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Transactional behavior​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#transactional-behavior","content":" Transactional changes (default): When the target system and audit store share a transactional context (e.g., MongoDB CE), Flamingock wraps both in a single transaction.Non-transactional changes: transactional = false. Flamingock executes @Execution and, upon success, writes to the audit store. If @Execution fails, Flamingock invokes @RollbackExecution. See transactions page  ","version":"1.0.0","tagName":"h3"},{"title":"Immutability​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#immutability","content":" Code-based: Once committed and possibly executed, avoid modifying the class. Instead, introduce a new ChangeUnit for evolution.Template-based: Treat the file as immutable. Modifying an existing template breaks history ordering — use new template files for new changes.  ","version":"1.0.0","tagName":"h3"},{"title":"Audit store constraints​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#audit-store-constraints","content":" Single audit store per application: All ChangeUnits in one application write to the same audit store.Audit store integrity: Do not manually modify audit records in the audit store; this can corrupt Flamingock’s state. Use CLI/UI for supported modifications.  ","version":"1.0.0","tagName":"h3"},{"title":"Idempotency​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#idempotency","content":" ChangeUnits should be idempotent or safe to re-run. Flamingock retries failed ChangeUnits on next startup. If a non-transactional ChangeUnit partially succeeded, ensure it can handle multiple executions or include appropriate guards.    ","version":"1.0.0","tagName":"h3"},{"title":"Best practices​","type":1,"pageTitle":"ChangeUnits Deep Dive","url":"/docs/flamingock-library-config/changeunits-deep-dive#best-practices","content":" Name and location conventions*  Place both code-based and template-based ChangeUnits in the same source package/directory for visibility and immutability. Use filenames or class names prefixed with the zero-padded order (e.g., _0001_create_s3_bucket.java or _0001_create_s3_bucket.yaml). Always provide rollback Even for transactional ChangeUnits, implement @RollbackExecution so CLI “undo” operations work smoothly. Template-based changeUnits for simplicity and immutability Favor templated ChangeUnits (YAML/JSON) for routine, repeatable tasks—such as SQL DDL, configuration toggles, or small API calls. Templates are inherently immutable (being a static file), making it easier to adhere to versioning best practices. Use Flamingock’s batching feature for long-running operations(coming soon) For ChangeUnits that process large workloads (e.g., migrating millions of rows), leverage Flamingock’s built-in batching mechanism. Define a single ChangeUnit that iterates through data in batches; Flamingock will mark it as complete only when all batches succeed, and will resume from the last processed batch on retry. Inject minimal dependencies Only inject what you need (e.g., clients, DAOs). Avoid injecting large application contexts within ChangeUnits. Write clear descriptions Use the description property to explain the purpose and impact of each ChangeUnit. Implement idempotency For non-transactional operations (e.g., deleting an S3 bucket), wrap calls in checks (e.g., “if exists”) to handle re-runs gracefully. Immutable operations Once a ChangeUnit is applied to any environment, treat its code or template as immutable. For corrections, create new ChangeUnits rather than editing old ones. Explicit ordering Declare a clear, numeric order for each ChangeUnit. Relying on implicit or alphabetical ordering can introduce hidden dependencies and make debugging deployment issues difficult. Audit store hygiene Never manually edit or delete records in the audit store. Direct modifications can corrupt Flamingock’s internal state and lead to unpredictable behavior or data loss. If you need to correct audit data, use Flamingock’s supported operations (CLI or UI) or follow documented recovery procedures. Documentation and metadata Use the author and description (if available) fields to document the intent of each ChangeUnit. This metadata helps teams understand why a change was made and by whom—critical for code reviews and compliance audits. ","version":"1.0.0","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/events","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#introduction","content":" Flamingock utilizes events to notify the main application about the current state of the Flamingock process, as well as the eventual outcome of its execution.  The event-handling approach differs significantly depending on the type of runner being used:  For Spring-based applications, Flamingock leverages the ApplicationEventPublisher, which is provided during the build process.For standalone applications, Flamingock requires an explicit event handler to be defined at build time.  Flamingock offers event handling capabilities for both Pipelines and Stages.  ","version":"1.0.0","tagName":"h2"},{"title":"Type of events​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#type-of-events","content":" Flamingock emits three types of events:  Start Event: Triggered just before the migration process begins, following successful validation.Success Event: Emitted upon successful completion of the migration. This indicates that no unhandled exceptions occurred, or that any errors were either properly handled or associated changeLogs were marked with 'Fail' as false.Failure Event: Emitted when a change log fails and the failure is not handled, as described above.  warning The Success and Failure events are mutually exclusive, only one of them will be raised for a given migration execution.  ","version":"1.0.0","tagName":"h2"},{"title":"Get started​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#get-started","content":" Each runner's documentation page provides the necessary information for using events in accordance with that runner's specific implementation.  ","version":"1.0.0","tagName":"h2"},{"title":"Standalone basic example​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#standalone-basic-example","content":" In the Flamingock builder, you must configure the events you intend to use and implement the corresponding listeners.  ","version":"1.0.0","tagName":"h2"},{"title":"Builder​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#builder","content":" JavaKotlin FlamingockStandalone.local() .setPipelineStartedListener(new PipelineStartedListener()) .setPipelineCompletedListener(new PipelineCompletedListener()) .setPipelineFailedListener(new PipelineFailedListener()) .setStageStartedListener(new StageStartedListener()) .setStageCompletedListener(new StageCompletedListener()) .setStageFailedListener(new StageFailedListener()) .build() .run();   ","version":"1.0.0","tagName":"h3"},{"title":"Listener​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#listener","content":" JavaKotlin public class StageCompletedListener implements Consumer&lt;IStageCompletedEvent&gt; { public static int executed = 0; @Override public void accept(IStageCompletedEvent iStageCompletedEvent) { executed++; } }   ","version":"1.0.0","tagName":"h3"},{"title":"Spring-based basic example​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#spring-based-basic-example","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Listeners​","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#listeners","content":" JavaKotlin @Bean public PipelineStartedListener startFlamingockListener() { return new PipelineStartedListener(); } @Bean public PipelineCompletedListener successFlamingockListener() { return new PipelineCompletedListener(); } @Bean public PipelineFailedListener sailedFlamingockListener() { return new PipelineFailedListener(); } @Bean public StageStartedListener stageStartedListener() {return new StageStartedListener();} @Bean public StageCompletedListener stageCompletedListener() {return new StageCompletedListener();} @Bean public StageFailedListener stageFailedListener() {return new StageFailedListener();}  ","version":"1.0.0","tagName":"h3"},{"title":"Additional Configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/extra-configuration","content":"","keywords":"","version":"1.0.0"},{"title":"Metadata​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#metadata","content":" Flamingock provides a Metadata object - which is a flexible Map&lt;String, Object&gt; that allows you to attach custom information to your Flamingock process.  The metadata is stored as part of the audit log, and can be used for labeling, traceability, and future reporting.  ","version":"1.0.0","tagName":"h2"},{"title":"Use Cases​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#use-cases","content":" You can use metadata to:  Tag executions by team, service, or regionInclude a deployment ID, build number, or triggering userAttach comments or labels for easier traceability  ","version":"1.0.0","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#example","content":" YAMLBuilder metadata: owner: platform-team triggeredBy: ci-cd-pipeline notes: initial deployment setup     ","version":"1.0.0","tagName":"h3"},{"title":"Default Author​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#default-author","content":" If a change unit does not specify an author, Flamingock will use this value as the fallback.  Applies to both code-based and template-based changesDefault value: &quot;default_author&quot;Ignored if the change itself defines an explicit author  ","version":"1.0.0","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#example-1","content":" YAMLBuilder defaultAuthor: antonio     ","version":"1.0.0","tagName":"h3"},{"title":"Disable flamingock process​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#disable-flamingock-process","content":" This global toggle allows you to enable or disable Flamingock.  If set to false, Flamingock will not runA log message will appear in the application logs, indicating that Flamingock is disabledNo changes will be applied and no audit entries will be created  note Useful in test environments, local runs, or cases where you want to conditionally skip changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Additional Configuration","url":"/docs/flamingock-library-config/extra-configuration#example-2","content":" YAMLBuilder enabled: false  ","version":"1.0.0","tagName":"h3"},{"title":"Distributed lock configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/lock-configuration","content":"","keywords":"","version":"1.0.0"},{"title":"Configurable properties​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#configurable-properties","content":" Property\tDefault\tDescriptionlockAcquiredForMillis\t60000 (1 min)\tTime the lock remains valid once acquired. Automatically released if not refreshed. lockQuitTryingAfterMillis\t180000 (3 min)\tHow long to retry acquiring the lock if another instance holds it. lockTryFrequencyMillis\t1000 (1 sec)\tInterval between attempts while waiting for the lock. throwExceptionIfCannotObtainLock\ttrue\tWhether Flamingock should fail if the lock can't be acquired. enableRefreshDaemon\ttrue\tWhether to run a background thread that periodically extends the lock.    ","version":"1.0.0","tagName":"h2"},{"title":"Why locking matters​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#why-locking-matters","content":" In distributed systems, multiple app instances may start simultaneously — but only one should apply pending changes. Flamingock uses locking to:  Prevent race conditionsEnsure consistent and safe state transitionsGuarantee single execution of each change  info If no pending changes exist, the lock is not acquired and startup proceeds normally.    ","version":"1.0.0","tagName":"h2"},{"title":"Refresh Daemon (safety net)​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#refresh-daemon-safety-net","content":" The refresh daemon is a background thread that extends the lock before it expires. It’s critical for long-running changes that might exceed the lock duration.  Without the daemon:  A long-running change (e.g., 90s) could outlive a default lock (e.g., 60s)Another instance might acquire the lock prematurely, causing conflict  note By default, Flamingock uses proxy-based injection guards. Before executing any injected dependency, Flamingock verifies that the lock is still valid.  If you're injecting non-critical components (e.g., a local list or stateless helper), you can annotate them with @NonLockGuarded to avoid the proxy overhead.    ","version":"1.0.0","tagName":"h2"},{"title":"Configuration Examples​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#configuration-examples","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Builder​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#builder","content":" FlamingockStandalone .setLockAcquiredForMillis(120000) .setLockQuitTryingAfterMillis(300000) .setLockTryFrequencyMillis(2000) .setThrowExceptionIfCannotObtainLock(true) .setEnableRefreshDaemon(true) ...     ","version":"1.0.0","tagName":"h3"},{"title":"When to tweak Lock settings​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#when-to-tweak-lock-settings","content":" Most projects can use the default configuration. You may need to adjust values if:  You expect long-running changes (increase lockAcquiredForMillis)You run many app instances and want to reduce startup wait (decrease lockTryFrequencyMillis)You want Flamingock to fail fast if it can't acquire a lock (keep throwExceptionIfCannotObtainLock as true)    ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best Practices​","type":1,"pageTitle":"Distributed lock configuration","url":"/docs/flamingock-library-config/lock-configuration#-best-practices","content":" Keep the refresh daemon enabled, especially for distributed or slow-processing environmentsAvoid setting lockAcquiredForMillis too short if any changes might run longerUse @NonLockGuarded sparingly — only when you're sure no side-effects will occur ","version":"1.0.0","tagName":"h2"},{"title":"Flamingock library configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"What you can configure​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#what-you-can-configure","content":" Area\tDescriptionSetup &amp; Stages\tOrganize changes into ordered stages ChangeUnits dependency injection\tDependency injection to changeUnits and environment Platform component injection\tPlatform-level components injection Lock\tDistributed locking and timing options Extra\tMetadata, default author, enable/disable Cloud Edition\tCloud-specific setup: token, env, service Community Edition\tDriver-specific config for MongoDB, DynamoDB...  Each of these topics is explained in its own section.    ","version":"1.0.0","tagName":"h2"},{"title":"Configuration scopes and layers​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#configuration-scopes-and-layers","content":" Flamingock configuration is organized in two main scopes:  ","version":"1.0.0","tagName":"h2"},{"title":"Core configuration (shared by all editions)​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#core-configuration-shared-by-all-editions","content":" Includes:  Setup and stages definitionLock settingsMetadataDefault authorEnable/disable flagDependency injection via addDependency(...) for ChangeUnits and framework componentsetc.  ","version":"1.0.0","tagName":"h3"},{"title":"Edition-specific configuration​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#edition-specific-configuration","content":" Based on the edition of Flamingock you import:  Cloud Edition: Related settings to configure Flamingock Cloud.Community Edition: MongoDB, DynamoDB, Couchbase drivers and related settings.  Each of these can be used in two runtime environments:  Standalone (default) — direct usage with builder (file-based config will be supported soon)Spring Boot — supports both setups; builder and integration with Spring’s lifecycle and properties (covered in a separate section)    ","version":"1.0.0","tagName":"h3"},{"title":"Setup and stages configuration​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#setup-and-stages-configuration","content":" Stages are configured using the @EnableFlamingock annotation on any class in your application:  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) public class FlamingockConfig { // Configuration class }   Alternatively, you can use a dedicated file by specifying pipelineFile in the annotation:  @EnableFlamingock(pipelineFile = &quot;config/pipeline.yaml&quot;) public class FlamingockConfig {}   The annotation should contain only the pipeline and stage definitions — no runtime configuration should be placed here.  info The @EnableFlamingock annotation is required for all runners and all environments.The pipeline definition should remain the same across environments.To conditionally include or exclude changes, Flamingock supports profiles.Profile support for stages is planned but not yet available.  See the Pipeline &amp; stages page for full details and examples.    ","version":"1.0.0","tagName":"h2"},{"title":"Applying runtime configuration​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#applying-runtime-configuration","content":" Runtime configuration (everything except the pipeline) can be applied in the following ways:  Runtime environment\tBuilder\tFileStandalone\t✅\t❌ (coming soon) Springboot\t✅\t✅(framework native)  info You can combine both approaches. If a property is defined in both, the builder value takes precedence.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#next-steps","content":" Explore the rest of the configuration section to tune Flamingock for your system:  ","version":"1.0.0","tagName":"h2"},{"title":"Shared configuration​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#shared-configuration","content":" Setup &amp; StagesLock ConfigurationExtra ConfigurationDependency wiring  ","version":"1.0.0","tagName":"h3"},{"title":"Pick an edition​","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#pick-an-edition","content":" ☁️ Cloud Edition(Fully-featured)🧪 Community Edition(feature-limited) ","version":"1.0.0","tagName":"h3"},{"title":"Platform component injection","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/platform-component-injection","content":"","keywords":"","version":"1.0.0"},{"title":"When is this needed?​","type":1,"pageTitle":"Platform component injection","url":"/docs/flamingock-library-config/platform-component-injection#when-is-this-needed","content":" You may need to register platform components when:  Framework integration is required For example, when integrating with Spring Boot, you must provide ApplicationContext and ApplicationEventPublisher so Flamingock can hook into the application lifecycle. Database access in Community Edition drivers Some drivers (like MongoDB or DynamoDB) require the database client to be explicitly provided. System integrations like logging or observability (coming soon) Future features like OpenTelemetry or event monitoring may rely on externally provided components. Custom modules or platform bridges If you're building your own Flamingock modules or integrating with external systems, you might need to provide platform services explicitly.  info Each integration (e.g., Spring Boot, database integration, etc.) will clearly document if and how platform components need to be registered. You don’t need to guess — check the relevant integration section for guidance.    ","version":"1.0.0","tagName":"h2"},{"title":"Registering platform dependencies​","type":1,"pageTitle":"Platform component injection","url":"/docs/flamingock-library-config/platform-component-injection#registering-platform-dependencies","content":" Platform components are registered using the same addDependency(...) API used for change unit dependencies:  builder .addDependency(applicationContext) .addDependency(applicationEventPublisher);   tip If a component is relevant for both Flamingock internal operations and for injection into change units, you only need to register it once.    ","version":"1.0.0","tagName":"h2"},{"title":"See also​","type":1,"pageTitle":"Platform component injection","url":"/docs/flamingock-library-config/platform-component-injection#see-also","content":" ChangeUnit dependency injection — for injecting services directly into change unitsSpring Boot integration — for automated platform wiring in Spring apps ","version":"1.0.0","tagName":"h2"},{"title":"Setup & Stages","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/setup-and-stages","content":"","keywords":"","version":"1.0.0"},{"title":"Setup configuration​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#setup-configuration","content":" Flamingock is configured using the @EnableFlamingock annotation on any class in your application. This annotation is required for all environments — whether you're using the standalone runner or Spring Boot integration.  The annotation is only used for defining the setup (stages and their sources). No runtime configuration should be placed here.    ","version":"1.0.0","tagName":"h2"},{"title":"Defining the setup​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#defining-the-setup","content":" Here's the default single-stage configuration:  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } ) public class FlamingockConfig { // Configuration class }   Alternatively, using a YAML file:  @EnableFlamingock(pipelineFile = &quot;config/setup.yaml&quot;) public class FlamingockConfig {}   Where config/setup.yaml contains:  pipeline: stages: - name: main location: com.yourcompany.changes   Advanced options: Multiple stages: For complex scenarios requiring independent change sets go to the stage section belowFile-based configuration: Use pipelineFile parameter for YAML configurationExplicit naming: Use @Stage(name = &quot;custom&quot;, location = &quot;com.yourcompany.changes&quot;)    ","version":"1.0.0","tagName":"h2"},{"title":"Stage Types​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#stage-types","content":" Flamingock supports two families of stages:  ","version":"1.0.0","tagName":"h2"},{"title":"Standard Stages (default)​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#standard-stages-default","content":" The default stage type where users place their changes. This is where you'll put all your application changes (Kafka, MongoDB, SQL, S3, etc.). Standard stages execute changeUnits in order and provide predictable, sequential execution.  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) // Standard stage (default type) } )   ","version":"1.0.0","tagName":"h3"},{"title":"Special Stages​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#special-stages","content":" For specific scenarios, Flamingock provides special stage types that require explicitly specifying a type parameter. Examples include SYSTEM and LEGACY stage types, which are used in particular contexts such as the Mongock upgrade process.  @EnableFlamingock( stages = { @Stage(type = SYSTEM, location = &quot;com.yourapp.system&quot;), @Stage(type = LEGACY, location = &quot;com.yourapp.mongock&quot;), @Stage(location = &quot;com.yourcompany.changes&quot;) // Standard stage (default type) } )   To see these special stages in action, refer to the Upgrade from Mongock guide which demonstrates their practical usage.    ","version":"1.0.0","tagName":"h3"},{"title":"Multiple Stages (Advanced)​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#multiple-stages-advanced","content":" Most applications will naturally fit into a single stage, which keeps things simple and ensures a clear, deterministic execution order. However, if you prefer to organize changes into multiple stages—for example, to separate concerns or enforce isolated execution flows—Flamingock fully supports that as well. We’ll explain how it works and what to consider when taking that approach.  Default approach: Most applications use a single stage: @Stage(location = &quot;com.yourcompany.changes&quot;). The name is auto-derived (&quot;changes&quot;) and this is the recommended default setup.  ","version":"1.0.0","tagName":"h2"},{"title":"When to Use Multiple Stages​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#when-to-use-multiple-stages","content":" Multiple stages are beneficial in specific scenarios:  Multi-module Applications​  In monolithic applications with well-defined module boundaries, you can give each module its own stage for full autonomy:  @EnableFlamingock( stages = { @Stage(name = &quot;user-module&quot;, location = &quot;com.yourapp.users.changes&quot;), @Stage(name = &quot;billing-module&quot;, location = &quot;com.yourapp.billing.changes&quot;), @Stage(name = &quot;notification-module&quot;, location = &quot;com.yourapp.notifications.changes&quot;) } )   This approach allows:  Independent change management across modulesDifferent release cycles for different modulesClear separation of concerns and responsibilities  Functional Separation​  You might want to separate changes by function or lifecycle:  @EnableFlamingock( stages = { @Stage(name = &quot;core-setup&quot;, location = &quot;com.yourapp.setup.changes&quot;), @Stage(name = &quot;business-logic&quot;, location = &quot;com.yourapp.business.changes&quot;), @Stage(name = &quot;monitoring-setup&quot;, location = &quot;com.yourapp.monitoring.changes&quot;) } )   ","version":"1.0.0","tagName":"h3"},{"title":"Restrictions and Important Considerations​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#restrictions-and-important-considerations","content":" No Execution Order Guarantees​  Critical limitation: Flamingock does not guarantee execution order between stages. This means:  Stage A might execute before, after, or concurrently with Stage BYou cannot rely on changes in one stage being applied before another stage startsEach stage should be completely independent from others  Why This Matters​  Consider this problematic scenario:  // ❌ PROBLEMATIC: Relies on execution order @EnableFlamingock( stages = { @Stage(name = &quot;create-tables&quot;, location = &quot;com.yourapp.schema&quot;), // Creates tables @Stage(name = &quot;seed-data&quot;, location = &quot;com.yourapp.data&quot;) // Inserts data - DEPENDS on tables existing! } )   The seed-data stage might execute before create-tables, causing failures.  Correct Approach​  Instead, group dependent changes in the same stage:  // ✅ CORRECT: All related changes in one stage @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) // Contains both table creation AND data seeding in order } )   ","version":"1.0.0","tagName":"h3"},{"title":"When NOT to Use Multiple Stages​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#when-not-to-use-multiple-stages","content":" Avoid multiple stages when:  You need execution order across different change types - Use a single stage insteadChanges are logically related - Keep them together for easier maintenanceSimple applications - The complexity isn't worth the overheadCross-cutting concerns - Changes that affect multiple areas should be in one stage  Future Enhancements Conditional stage execution based on dependencies or conditions is planned for future releases, which would allow: Running stages based on success/failure of other stagesDefining explicit dependencies between stagesMore sophisticated stage orchestration patterns    ","version":"1.0.0","tagName":"h3"},{"title":"Required fields​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#required-fields","content":" Each stage must define:  name (optional): A unique identifier - if not provided, it will be auto-derived from the locationlocation: The package or directory where changes are located    ","version":"1.0.0","tagName":"h2"},{"title":"Stage fields​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#stage-fields","content":" Field\tRequired\tDescriptionlocation\t✅\tPackage or directory scanned for both code-based and template-based changes name\t❌\tUnique identifier for the stage (auto-derived from location if not provided) description\t❌\tOptional text explaining the stage's purpose    ","version":"1.0.0","tagName":"h2"},{"title":"Where Changes are located​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#where-changes-are-located","content":" location refers to a source package (e.g., com.company.changes), a relative(e.g., my/path/changes) or absolute(e.g., /my/path/changes) resources directory. Template-based and code-based changes can co-exist if location is a source package.If location references a resource directory, it only accepts template-based changeUnits.Default source roots: src/main/java, src/main/kotlin, src/main/scala, src/main/groovy.Source root can be customized via the sources compiler option.Resource root can be customized via the resources compiler option. Customizing Source and Resource Root Paths  GradleMaven tasks.withType&lt;JavaCompile&gt; { options.compilerArgs.addAll(listOf( &quot;-Asources=custom/src&quot;, &quot;-Aresources=custom/resources&quot; )) }     ","version":"1.0.0","tagName":"h2"},{"title":"Example Pipeline​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#example-pipeline","content":" pipeline: stages: - name: user-setup description: User-related DB setup location: com.yourapp.flamingock.users   Folder view:  src/ main/ java/ com/ yourapp/ flamingock/ users/ _0001_CREATE_USERS_TABLE.java _0002_ADD_INDEX.yaml     ","version":"1.0.0","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Single Stage Execution (default and recommended)​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#single-stage-execution-default-and-recommended","content":" In most applications, changes that require a specific, deterministic execution order should be grouped into a single stage. This ensures they are applied sequentially and in the exact order they are defined.  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } )   Grouping related changes into a single stage:  Ensures predictable, sequential executionAvoids ambiguity from cross-stage execution timingEliminates the need to manage inter-stage dependenciesKeeps setup simple and easier to maintainSupports mixing all types of changes (Kafka, MongoDB, SQL, S3, etc.) in a well-defined order  Advanced scenarios If your application benefits from separating changes—for example, by module or lifecycle—you can define Multiple Stages (Advanced). Just remember: deterministic execution is guaranteed only within a stage, not across them.  ","version":"1.0.0","tagName":"h3"},{"title":"Placing your changes​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#placing-your-changes","content":" We strongly recommend placing all your changes — code-based and template-based — in a single location defined by the @Stage annotation.  Ensures changes are always scanned, regardless of typeAvoids needing two locations if one template-based change requires fallback to codeKeeps everything in one logical location    ","version":"1.0.0","tagName":"h3"},{"title":"Naming Convention for Changes​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#naming-convention-for-changes","content":" To ensure clarity and enforce ordering, we recommend naming changes using the following format:  _0001_CREATE_CLIENTS_TABLE.java _0002_ADD_INDEX_TO_EMAIL.yaml   XXXX: The execution order of the changeCHANGE_NAME: Descriptive name of what the change does  This convention:  Works across both code-based and template-based formatsMakes the execution order obvious at a glanceEnsures consistent naming and project hygiene  tip While Java typically avoids underscores and leading digits, change units are not traditional classes. Prioritizing readability and order is more valuable in this context.  ","version":"1.0.0","tagName":"h3"},{"title":"🛠 Troubleshooting​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#-troubleshooting","content":" ","version":"1.0.0","tagName":"h2"},{"title":"My stage isn't picked up​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#my-stage-isnt-picked-up","content":" Make sure the stage has a location field definedCheck the file path is correct and uses / as a separator, not . in YAMLIf using resource directory paths, make sure the file is placed under src/main/resources/your-dir  ","version":"1.0.0","tagName":"h3"},{"title":"No changes found in stage​","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#no-changes-found-in-stage","content":" Verify that the class or YAML file is located in the expected package/directoryFor code-based changes, ensure the class is annotated with @Change or @ChangeUnitFor template-based changes, check file names and YAML formatting   ","version":"1.0.0","tagName":"h3"},{"title":"Transactions","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/transactions","content":"","keywords":"","version":"1.0.0"},{"title":"What Flamingock considers transactional​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#what-flamingock-considers-transactional","content":" A change unit is considered transactional when:  The change targets a system that supports transactions (e.g., a modern database)The Flamingock Community Edition driver in use supports transactionsThe change unit is marked as transactional = true (default behavior)  If these conditions are met, Flamingock wraps the execution of:  The @Execution method of the change unitThe audit log record creation  ...within the same transaction. If anything fails, the entire operation is rolled back and not recorded as executed.    ","version":"1.0.0","tagName":"h2"},{"title":"When transactions don’t apply​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#when-transactions-dont-apply","content":" Transactions do not apply in the following scenarios:  The change targets a non-transactional system (e.g., Kafka, S3, external APIs)The change targets a different database than the one used for Flamingock’s audit logThe change performs operations that are not allowed in transactions (e.g., DDL operations in Mysql or MongoDB)The driver or underlying database doesn’t support transactions  tip In all these cases, mark the change unit with @ChangeUnit(transactional = false) to disable transaction wrapping.  warning If a change unit is marked as transactional (transactional = false not applied) but targets a system or operation that doesn’t support transactions, Flamingock assumes the database rolled back the change, and skips the @RollbackExecution method in case of failure. This can result in partial updates and loss of consistency.    ","version":"1.0.0","tagName":"h2"},{"title":"Disabling transactions​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#disabling-transactions","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Per change unit (recommended)​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#per-change-unit-recommended","content":" Transactions are enabled by default. You can disable them explicitly for a given change unit:  @ChangeUnit(id = &quot;provision-bucket&quot;, order = &quot;004&quot;, author = &quot;team-a&quot;, transactional = false) public class S3ProvisioningChange { @Execution public void execute(S3Client s3) { s3.createBucket(...); } @RollbackExecution public void rollback(S3Client s3) { s3.deleteBucket(...); } }   This tells Flamingock:  Not to use a transaction for the execution and auditTo call @RollbackExecution if something goes wrong  ","version":"1.0.0","tagName":"h3"},{"title":"Globally (less common)​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#globally-less-common","content":" You can also disable transactions across all change units in the builder:  Flamingock .builder() .disableTransaction() .build() .run();     ","version":"1.0.0","tagName":"h3"},{"title":"Manual rollback​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#manual-rollback","content":" When transactional = false, Flamingock cannot rely on the underlying system to roll back failed operations. Instead, it will attempt a manual rollback by calling your @RollbackExecution method if execution fails.  This fallback allows Flamingock to support non-transactional systems like:  Message brokers (e.g., Kafka, RabbitMQ)External APIsCloud infrastructure  info You are responsible for writing reliable rollback logic. Flamingock cannot guarantee full recovery unless your rollback method safely restores the previous state.    ","version":"1.0.0","tagName":"h2"},{"title":"When to use transactional = false​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#when-to-use-transactional--false","content":" Type of change\ttransactional = false?Operation allowed in transaction - same DB as audit log (transactional)\t❌ Operation not allowed inside transaction (e.g., DDL operations in Mysql or MongoDB)\t✅ ChangeUnit targets different DB than audit log\t✅ ChangeUnit targets non-database system or a non-transactional\t✅    ","version":"1.0.0","tagName":"h2"},{"title":"Flamingock Cloud Edition​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#flamingock-cloud-edition","content":" info Flamingock Cloud Edition will support transactions through its own internal coordination mechanism. Documentation will be added when this feature is released.    ","version":"1.0.0","tagName":"h2"},{"title":"Edition-specific transaction behavior​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#edition-specific-transaction-behavior","content":" The examples and recommendations on this page apply to Flamingock generally, but each Community Edition (CE) driver has its own transactional capabilities and constraints.  Refer to the relevant edition page for detailed behavior, including:  Whether transactions are supportedHow they are initiated and managedKnown limitations (e.g., unsupported operations)  Supported transactional CE editions:  flamingock-ce-mongodb-syncflamingock-ce-mongodb-springdataflamingock-ce-dynamodbflamingock-ce-couchbase  info Cloud Edition transactional support will be explained in its own section once released.    ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#white_check_mark-best-practices","content":" Use transactional = false for changes that cannot run in a transaction  Some database drivers (e.g., MongoDB Sync) don’t support all operations inside transactions (such as DDL or index creation). In those cases, explicitly set transactional = false to avoid runtime errors.  Always set transactional = false for non-database change units  If your change interacts with a message queue, API, file system, or another external system, it should not be marked as transactional. Flamingock will treat it as non-transactional and enable manual rollback instead.  Keep change unit scope narrow and isolated  Avoid combining transactional and non-transactional logic within the same change unit. If part of the logic targets a non-transactional system, isolate that logic in a dedicated change unit and mark it appropriately.  Prefer automatic rollback (via transaction) when available  Transactional change units offer stronger guarantees. Use them when the system supports them to ensure atomic execution and safe rollback on failure. ","version":"1.0.0","tagName":"h2"},{"title":"How does Flamingock work within a k8s ecosystem? (to-do)","type":0,"sectionRef":"#","url":"/docs/frameworks/kubernetes","content":"How does Flamingock work within a k8s ecosystem? (to-do)","keywords":"","version":"1.0.0"},{"title":"Builder-based (manual)","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/builder-based-setup","content":"","keywords":"","version":"1.0.0"},{"title":"Import the springboot integration library​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#import-the-springboot-integration-library","content":" Add the appropriate Flamingock Spring Boot integration dependency, depending on your version:  GradleMaven // For Spring Boot 3.x implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;) // For Spring Boot 2.x (legacy) implementation(&quot;io.flamingock:flamingock-springboot-integration-v2-legacy:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#version-compatibility","content":" Check Version Compatibility  ","version":"1.0.0","tagName":"h3"},{"title":"Configure setup and build Flamingock manually​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#configure-setup-and-build-flamingock-manually","content":" With the manual setup, you first need to configure Flamingock using @EnableFlamingock annotation with setup = SetupType.BUILDER, then manually configure and run Flamingock using the builder API.  ","version":"1.0.0","tagName":"h2"},{"title":"1. Configure the annotation​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#1-configure-the-annotation","content":" @EnableFlamingock( setup = SetupType.BUILDER, stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @Configuration public class FlamingockConfig { // Configuration class }   ","version":"1.0.0","tagName":"h3"},{"title":"2. Manual builder configuration​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#2-manual-builder-configuration","content":" With the manual setup, you are responsible for configuring and running Flamingock using the builder API. This includes:  Providing your configuration (e.g., lock settings, metadata) directly via the builderRegistering the required platform components using .addDependency(...)ApplicationContextApplicationEventPublisher  FlamingockBuilder builder = Flamingock .setLockAcquiredForMillis(120000) // example config .addDependency(applicationContext) .addDependency(applicationEventPublisher);   info Platform components are registered using the same .addDependency(...) method used for change unit dependencies. For details, see the Platform component injection page.    ","version":"1.0.0","tagName":"h3"},{"title":"Overriding Spring-provided dependencies​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#overriding-spring-provided-dependencies","content":" When using the builder-based setup, Flamingock will attempt to resolve dependencies using the Spring context.  However, if you manually register a dependency via .addDependency(...), that dependency will take precedence over anything resolved from the Spring context. This gives you fine-grained control when you want to:  Override a Spring-managed bean with a custom instanceInject mock or test-specific versions of servicesProvide external or non-Spring-managed components directly  builder .addDependency(customClientService) // Overrides Spring's bean of same type .addDependency(applicationContext); // Registers Spring context for base dependency injection   In a nutshell, Flamingock resolves dependencies using the following order:  Manually added dependencies via .addDependency(...)Beans from the Spring context (if ApplicationContext was registered)    ","version":"1.0.0","tagName":"h2"},{"title":"Running Flamingock​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#running-flamingock","content":" Once you've configured the builder, you can choose how to execute Flamingock:  ","version":"1.0.0","tagName":"h2"},{"title":"Option 1: Run manually​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#option-1-run-manually","content":" You can run Flamingock manually:  builder.build().run();   ","version":"1.0.0","tagName":"h3"},{"title":"Option 2: Expose as a Spring Bean​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#option-2-expose-as-a-spring-bean","content":" Alternatively, you can integrate Flamingock into the Spring Boot lifecycle by exposing it as an ApplicationRunner or InitializingBean:  @Bean public ApplicationRunner flamingockRunner() { return SpringbootUtil.toApplicationRunner(builder.build()); }   Or:  @Bean public InitializingBean flamingockRunner() { return SpringbootUtil.toInitializingBean(builder.build()); }   This ensures Flamingock executes automatically as part of the Spring Boot startup sequence.    ","version":"1.0.0","tagName":"h3"},{"title":"Next steps​","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#next-steps","content":" Want to avoid manual setup? Explore the Automatic Setup for automatic integration with minimal code. ","version":"1.0.0","tagName":"h2"},{"title":"GraalVM support","type":0,"sectionRef":"#","url":"/docs/frameworks/graalvm","content":"","keywords":"","version":"1.0.0"},{"title":"How it works​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#how-it-works","content":" When building your application, Flamingock's annotation processor:  Scans for all annotated code-based changes (@ChangeUnit)Discovers template-based changes from sourcesPackage and resourcesDirGenerates metadata files containing all required classes for reflection  At native image generation time, Flamingock’s GraalVM feature picks up these files and registers the required types with GraalVM, so they’re available at runtime.  tip Learn more about the basics of GraalVM native image compilation in the GraalVM Native Image basics guide.    ","version":"1.0.0","tagName":"h2"},{"title":"Step-by-step setup​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#step-by-step-setup","content":" ","version":"1.0.0","tagName":"h2"},{"title":"1. Add Flamingock GraalVM dependency​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#1-add-flamingock-graalvm-dependency","content":" GradleMaven implementation(&quot;io.flamingock:flamingock-graalvm:$flamingockVersion&quot;)     ","version":"1.0.0","tagName":"h3"},{"title":"2. Add plugin management (only for Gradle)​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#2-add-plugin-management-only-for-gradle","content":" If using Gradle, ensure your settings.gradle.kts includes:  pluginManagement { repositories { mavenLocal() gradlePluginPortal() mavenCentral() } }     ","version":"1.0.0","tagName":"h3"},{"title":"3. Add GraalVM resource config​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#3-add-graalvm-resource-config","content":" Create a file named resource-config.json in your project root:  { &quot;resources&quot;: { &quot;includes&quot;: [ { &quot;pattern&quot;: &quot;META-INF/flamingock/metadata.json&quot; } ] } }   info This file declares which resource files should be accessible to your native image. You can add other application-specific resources here as needed. See the GraalVM resource configuration documentation for more details.    ","version":"1.0.0","tagName":"h3"},{"title":"4. Build the application​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#4-build-the-application","content":" ./gradlew clean build   Expected build output​  During the build process, Flamingock will emit logs similar to the following — indicating successful annotation processing and metadata generation.  Click to see the expected logs GradleMaven &gt; Task :compileJava Note: [Flamingock] Starting Flamingock annotation processor initialization. Note: [Flamingock] 'resources' parameter NOT passed. Using default 'src/main/resources' Note: [Flamingock] 'sources' parameter NOT passed. Searching in: '[src/main/java, src/main/kotlin, src/main/scala, src/main/groovy]' Note: [Flamingock] Reading flamingock pipeline from file: 'src/main/resources/flamingock/pipeline.yaml' Note: [Flamingock] Initialization completed. Processed templated-based changes. Note: [Flamingock] Searching for code-based changes (Java classes annotated with @Change or legacy @ChangeUnit annotations) Note: [Flamingock] Reading flamingock pipeline from file: 'src/main/resources/flamingock/pipeline.yaml' Note: [Flamingock] Finished processing annotated classes and generating metadata. Note: [Flamingock] Final processing round detected - skipping execution.     ","version":"1.0.0","tagName":"h3"},{"title":"5. Create the native image​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#5-create-the-native-image","content":" native-image \\ --no-fallback \\ --features=io.flamingock.graalvm.RegistrationFeature \\ -H:ResourceConfigurationFiles=resource-config.json \\ -H:+ReportExceptionStackTraces \\ --initialize-at-build-time=org.slf4j.simple \\ -jar build/libs/your-app.jar   What these options do:​  --features=io.flamingock.graalvm.RegistrationFeature: Registers all Flamingock-related classes for reflection using metadata gathered during build time.-H:ResourceConfigurationFiles=resource-config.json: Informs GraalVM of required static resource files to include.--initialize-at-build-time: – Optional. Build‑time init for listed classes/packages (freeze static state; faster start; avoids early reflection/I/O). Flamingock does not require specific entries. Use only if a library benefits (e.g., logging). Example: --initialize-at-build-time=org.slf4j.impl,org.slf4j.simple. Omit if unsure.  Expected native image output​  When creating the native image, you should see log output from Flamingock's GraalVM RegistrationFeature, confirming that Flamingock successfully scanned and registered internal classes, templates, system modules, and user-defined change units.  The actual output may differ slightly depending on the modules you’ve included, but it should look similar to the following:  Click to see the expected logs - io.flamingock.graalvm.RegistrationFeature [Flamingock] Starting GraalVM classes registration [Flamingock] Starting registration of internal classes Registering class: io.flamingock.core.task.TaskDescriptor Registering class: io.flamingock.core.task.AbstractTaskDescriptor Registering class: io.flamingock.core.preview.PreviewPipeline Registering class: io.flamingock.core.preview.PreviewStage Registering class: io.flamingock.core.preview.CodePreviewChangeUnit Registering class: io.flamingock.core.preview.CodePreviewLegacyChangeUnit Registering class: io.flamingock.core.preview.PreviewMethod Registering class: io.flamingock.core.api.template.ChangeTemplateConfig Registering class: io.flamingock.core.preview.TemplatePreviewChangeUnit Registering class: io.flamingock.core.pipeline.Pipeline Registering class: io.flamingock.core.pipeline.LoadedStage Registering class: io.flamingock.core.task.loaded.AbstractLoadedTask Registering class: io.flamingock.core.task.loaded.AbstractReflectionLoadedTask Registering class: io.flamingock.core.task.loaded.AbstractLoadedChangeUnit Registering class: io.flamingock.core.task.loaded.CodeLoadedChangeUnit Registering class: io.flamingock.core.task.loaded.TemplateLoadedChangeUnit Registering class: java.nio.charset.CoderResult [Flamingock] Completed internal classes [Flamingock] Starting registration of templates Registering class: io.flamingock.core.api.template.TemplateFactory Registering class: io.flamingock.core.api.template.ChangeTemplate Registering class: io.flamingock.core.api.template.AbstractChangeTemplate Registering class: io.flamingock.template.mongodb.MongoChangeTemplate Registering class: io.flamingock.template.mongodb.model.MongoOperation Registering class: io.flamingock.template.mongodb.MongoChangeTemplateConfig [Flamingock] Completed templates [Flamingock] Starting registration of system modules Registering class: io.flamingock.core.engine.audit.importer.changeunit.MongockImporterChangeUnit Registering class: io.flamingock.core.engine.audit.importer.ImporterModule [Flamingock] Completed system modules [Flamingock] Starting registration of user classes Registering class: io.flamingock.changes._1_create_clients_collection_change Registering class: io.flamingock.changes._2_insertClientFederico_change Registering class: io.flamingock.changes._3_insert_client_jorge [Flamingock] Completed user classes [Flamingock] Completed GraalVM classes registration   tip For more information on image creation and options, refer to the GraalVM build overview documentation.    ","version":"1.0.0","tagName":"h3"},{"title":"6. Run the native image​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#6-run-the-native-image","content":" ./your-app     ","version":"1.0.0","tagName":"h3"},{"title":"Example project​","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#example-project","content":" We have built a complete example project for GraalVM that demonstrates:  A working Flamingock configuration with GraalVMSample change unitsProper resource configurationNative image generation process  You can use this example as a reference implementation while following the steps in this guide. ","version":"1.0.0","tagName":"h2"},{"title":"Automatic Setup","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup","content":"","keywords":"","version":"1.0.0"},{"title":"Import the springboot integration library​","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#import-the-springboot-integration-library","content":" Add the appropriate Flamingock Spring Boot integration dependency, depending on your version:  GradleMaven // For Spring Boot 3.x (Spring 6.x) implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;) // For Spring Boot 2.x (Spring 5.x, legacy) implementation(&quot;io.flamingock:flamingock-springboot-integration-v2-legacy:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility​","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#version-compatibility","content":" Check Version Compatibility  ","version":"1.0.0","tagName":"h3"},{"title":"Configure setup and activate integration​","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#configure-setup-and-activate-integration","content":" To activate the integration, add @EnableFlamingock to any class in your application (commonly on your main class or a configuration class):  import io.flamingock.core.api.annotations.EnableFlamingock; import io.flamingock.core.api.annotations.Stage; @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }   The @EnableFlamingock annotation enables automatic Spring Boot integration, which:  Detect and use Spring’s ApplicationContext and ApplicationEventPublisherLoads Flamingock configuration directly from your Spring Boot config fileAutomatically configures the runner (e.g., ApplicationRunner or InitializingBean)Processes the setup configuration from the annotation    ","version":"1.0.0","tagName":"h2"},{"title":"Providing configuration​","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#providing-configuration","content":" Runtime configuration is defined using standard Spring Boot configuration files. Use the flamingock section for all core and edition-specific options.  flamingock: lockAcquiredForMillis: 1200 runnerType: InitializingBean # other configuration...   info If the runnerType property is not provided, Flamingock defaults to using ApplicationRunner.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#next-steps","content":" Want full control over the builder? See Builder-based setupExplore Spring Boot profile supportLearn about Flamingock lifecycle events ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot integration","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Why integrate Flamingock with Spring Boot?​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#why-integrate-flamingock-with-spring-boot","content":" Using Flamingock with Spring Boot allows you to:  Inject Spring-managed beans directly into change unitsConfigure Flamingock via Spring Boot's native configuration filesUse Spring profiles to control when specific change units runReceive execution lifecycle events using ApplicationEventPublisherChoose between Spring Boot lifecycle hooks (ApplicationRunner or InitializingBean) to run Flamingock.    ","version":"1.0.0","tagName":"h2"},{"title":"Two setup approaches​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#two-setup-approaches","content":" Flamingock offers two ways to integrate with Spring Boot, depending on how much control you want over the configuration and lifecycle.  ","version":"1.0.0","tagName":"h2"},{"title":"Builder-based setup (manual)​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#builder-based-setup-manual","content":" This approach gives you full control and uses the standard Flamingock builder with @EnableFlamingock(setup = SetupType.BUILDER). You manually inject the required Spring Boot components(ApplicationContext and ApplicationEventPublisher) as well as any Flamingock core configuration.  In addition, you can register other dependencies manually — these will take precedence over beans from the Spring context when resolving what to inject into change units.  This is recommended for advanced users or highly customized environments.  See: Builder-based setup    ","version":"1.0.0","tagName":"h3"},{"title":"Automatic setup​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#automatic-setup","content":" This is the simplest way to enable Flamingock in Spring Boot. Just annotate any class with @EnableFlamingock (commonly your main application class), and Flamingock will:  Auto-detect the application context and event publisherRead configuration from Spring Boot config filesAutomatically wire the FlamingockRunner beanProcess the setup configuration from the annotation  Ideal for most users who prefer convention over configuration.  See: Automatic setup    ","version":"1.0.0","tagName":"h3"},{"title":"Runner strategy: ApplicationRunner vs InitializingBean​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#runner-strategy-applicationrunner-vs-initializingbean","content":" Flamingock supports two strategies for executing its process during Spring Boot startup. You can control this via the runnerType property in your Spring configuration (flamingock.runnerType), or programmatically if using the manual builder.  ","version":"1.0.0","tagName":"h2"},{"title":"Comparison​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#comparison","content":" \tApplicationRunner\tInitializingBeanPhase\tAfter all beans are initialized — just before the app is marked as started\tDuring bean initialization — before the app is considered started Context availability\t✅ Full — all Spring beans and profiles available\t⚠️ Limited — not all beans may be available Typical use case\tMost common — recommended for production environments\tFor lightweight internal logic or strict startup ordering Events fully supported?\t✅ Yes\t⚠️ Risky — context may not be fully ready Spring beans available in change units\t✅ Yes\t⚠️ May fail or be incomplete  ","version":"1.0.0","tagName":"h3"},{"title":"Startup failure behavior​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#startup-failure-behavior","content":" If Flamingock encounters an error during execution — whether using ApplicationRunner or InitializingBean — the Spring Boot application will fail to start.  This is intentional: Flamingock runs before the application is marked as ready. In deployment platforms such as Kubernetes, a failure at this stage will:  Prevent the container from reaching a Ready stateTrigger restart policies, health checks, or rollbacks as configuredEnsure that the system is never exposed in a partially initialized or inconsistent state  This behavior ensures your application only starts when all change units have been applied successfully.    ","version":"1.0.0","tagName":"h3"},{"title":"Dependency​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#dependency","content":" To use the Spring Boot integration, add the appropriate module for your version:  GradleMaven // For Spring Boot 3.x implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;) // For Spring Boot 2.x (legacy) implementation(&quot;io.flamingock:flamingock-springboot-integration-v2-legacy:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#version-compatibility","content":" Flamingock provides two editions for Spring Boot integration.  ","version":"1.0.0","tagName":"h3"},{"title":"Why are there two Spring Boot integration Community-Edition artifacts?​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#why-are-there-two-spring-boot-integration-community-edition-artifacts","content":" The only difference is the Java version they target:  flamingock-springboot-integration — requires JDK 17 or newer.flamingock-springboot-integration-v2-legacy — kept for teams still on Spring Boot 2 who must stay on JDK 8 – 11.  Choose the artifact that matches the JDK level of your application today; switching later is as simple as changing the dependency.  Package Name\tSpring Boot Versionflamingock-springboot-integration\t[3.0.0, 4.0.0) flamingock-springboot-integration-v2-legacy\t[2.0.0, 3.0.0)    ","version":"1.0.0","tagName":"h3"},{"title":"✅ Best practices​","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#white_check_mark-best-practices","content":" Consider the following recommendations to get the most out of Flamingock’s Spring Boot integration:  Prefer ApplicationRunner as your runner strategy It ensures Flamingock runs after the application context is fully initialized, giving it access to all beans, profiles, and configuration. It also integrates more safely with event publishing and external monitoring tools like Actuator or Prometheus. Use automatic setup (@EnableFlamingock) for simpler setups Unless you have advanced needs (such as injecting non-Spring-managed dependencies), the automatic setup provides a clean and reliable integration path. Use Spring profiles to scope change units Profiles let you control when specific change units execute, avoiding the need for environment-specific pipelines. Avoid manual execution unless absolutely necessary Letting Spring handle the execution via ApplicationRunner or InitializingBean ensures Flamingock runs at the appropriate time in your application lifecycle. Register custom platform components using .addDependency(...) only when required Most applications using automatic setup will not need to register components manually. ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot profiles","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/profiles","content":"","keywords":"","version":"1.0.0"},{"title":"What is a Spring profile?​","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#what-is-a-spring-profile","content":" Spring profiles provide a way to segregate parts of your application configuration and behavior based on the active environment.  You can define profiles like dev, test, staging, or prod, and activate one or more of them using any of the following methods:  Inside application.yml or application.properties: spring: profiles: active: dev,staging Using profile-specific configuration files like application-dev.yml or application-prod.yml As command-line arguments: --spring.profiles.active=dev,staging Through environment variables: SPRING_PROFILES_ACTIVE=dev,staging   When multiple profiles are active, Flamingock evaluates each change unit against all active profiles, and includes it if any match.    ","version":"1.0.0","tagName":"h2"},{"title":"How Flamingock uses profiles​","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#how-flamingock-uses-profiles","content":" Flamingock automatically retrieves the active profiles from Spring’s ApplicationContext. You don’t need to manually provide them.  You can then annotate any change unit with Spring’s native @Profile annotation to control whether it runs:  @ChangeUnit(id = &quot;add-test-data&quot;, order = &quot;001&quot;) @Profile(&quot;dev&quot;) public class AddTestDataChangeUnit { // will only run if &quot;dev&quot; profile is active }   Flamingock applies the same logic as Spring Boot when evaluating whether a change unit should run.    ","version":"1.0.0","tagName":"h2"},{"title":"Multiple profiles​","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#multiple-profiles","content":" You can declare multiple profiles in a single @Profile expression:  @Profile({&quot;dev&quot;, &quot;staging&quot;})   This change unit will run if any of the listed profiles is active.    ","version":"1.0.0","tagName":"h2"},{"title":"Excluding profiles​","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#excluding-profiles","content":" To exclude a change unit from a specific profile, you can use Spring Expression Language (SpEL):  @Profile(&quot;!prod&quot;)   This will run the change unit in all environments except prod.    ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#-best-practices","content":" Use profiles to isolate test data, preview features, or tenant-specific migrationsAvoid mixing profile-specific logic inside a single change unit — split them into separate classesKeep profile names consistent across your team and environments (e.g., use dev everywhere, not development, dev-env, etc.)Consider grouping related change units under a shared profile for easier activation ","version":"1.0.0","tagName":"h2"},{"title":"How it works?","type":0,"sectionRef":"#","url":"/docs/getting-started/how-it-works","content":"","keywords":"","version":"1.0.0"},{"title":"1. Define your changes as ChangeUnits​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#1-define-your-changes-as-changeunits","content":" Every change — whether it’s a database migration, a feature flag update, or a third-party API configuration — is encapsulated into a ChangeUnit.  Each ChangeUnit is uniquely identified, versioned, and optionally includes rollback logic.Changes can be defined in code (Java/Kotlin) or declaratively (YAML/JSON) via reusable templates templates.    ","version":"1.0.0","tagName":"h2"},{"title":"2. Organize changes into Workflows​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#2-organize-changes-into-workflows","content":" ChangeUnits are grouped into stages and structured into a Workflow pipeline to represent a coordinated sequence of changes.  Workflows allow you to define how changes should be applied: sequentially or (in future releases) in parallel or conditionally.This logical grouping simplifies the orchestration and order of changes across systems / services / components.    ","version":"1.0.0","tagName":"h2"},{"title":"3. Execute at startup (or on demand)​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#3-execute-at-startup-or-on-demand","content":" When your application starts, Flamingock automatically:  Scans for pending ChangeUnitsApplies them in the defined workflow orderEnsures idempotency so the same changes aren't applied twice  Flamingock can also run in standalone mode, ideal for setups that don't use an underlying framework (ie. Spring).    ","version":"1.0.0","tagName":"h2"},{"title":"4. Locking for safety in distributed environments​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#4-locking-for-safety-in-distributed-environments","content":" Using distributed locking, Flamingock ensures only one instance (or one node) applies changes at a time — preventing race conditions or duplicate executions.  Works across microservices and distributed system setupsSupports multiple store types: Flamingock Community Edition, with native driver compatibility with MongoDB, Couchbase, DynamoDBFlamingock SaaS or Flamingock self-hosted options to leverage Flamingock's provisioned storage.    ","version":"1.0.0","tagName":"h2"},{"title":"5. Audit everything, rollback when needed​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#5-audit-everything-rollback-when-needed","content":" Every change applied is fully audited:  When, by whom, and what was changedStatus of execution (success/failure)And a provisioned optional rollback strategy for non-transactional integrations.  In case of failure or rollback scenario, Flamingock uses defined compensating logic to revert changes and restore consistency.    ","version":"1.0.0","tagName":"h2"},{"title":"Example Use Cases​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#example-use-cases","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Example 1: Versioning made simple​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#example-1-versioning-made-simple","content":" Imagine a developer needs to introduce the following system changes as part of a release:  Add a new field to the user collection in MongoDBEnable a feature flag in a SaaS dashboard via REST APIUpdate an environment variable in a remote configuration store    Here’s how Flamingock helps:  The developer defines each change as an individual ChangeUnit, with rollback logic included.These ChangeUnits are grouped into stages and a embedded into a workflow, ensuring they run in the correct order.On the next application startup, Flamingock: Detects that these changes haven’t been applied yetAcquires a distributed lockExecutes all ChangeUnits safely and atomicallyLogs every detail in the audit system  Flamingock rolls back automatically in case of failure(if defined), ensuring the system doesn’t end up in a partial state.  The result? Faster deployments, consistent environments, and complete traceability.    ","version":"1.0.0","tagName":"h3"},{"title":"Example 2: Synchronizing Changes across domain services​","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#example-2-synchronizing-changes-across-domain-services","content":" In a Domain-Driven Design (DDD) environment, a change to a domain model often requires updates across several components:  Update to the Database and API specification (e.g., OpenAPI/Swagger)Modify the Kafka event schema and topic configurationAdjust the API Gateway routing and validation rules    Here’s how Flamingock makes this seamless:  The team creates ChangeUnits for: Updating the Database and API specificationReconfiguring Kafka topics and event schemaUpdating API Gateway specs All related ChangeUnits are grouped into a single workflow to ensure coordinated application.During deployment, Flamingock: Applies all changes atomically, respecting dependenciesAcquires a distributed lock to avoid concurrent modificationsAudits the entire process for traceability and compliance  This ensures that changes in the Database, messaging, and APIs exposed in the gateway are synchronized, reducing integration errors and deployment friction across microservices.   ","version":"1.0.0","tagName":"h3"},{"title":"Get started","type":0,"sectionRef":"#","url":"/docs/getting-started/get-started","content":"","keywords":"","version":"1.0.0"},{"title":"1. Add Flamingock client dependency​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#1-add-flamingock-client-dependency","content":" To begin, add the Flamingock client library to your project. You can use either:  Cloud Edition (compatible with all systems)Community Edition (you need to choose the specific storage: MongoDB, DynamoDB, etc.)  Flamingock supports BOM (Bill of Materials), which simplifies dependency management by allowing you to declare the version once and avoid mismatches across related modules. This is especially useful when working with multiple Flamingock artifacts.  Example for Cloud Edition:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-cloud-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-cloud&quot;)   Example for Community Edition using MongoDB Sync4:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-mongodb-sync&quot;)   All Community Editions:  flamingock-ce-mongodb-syncflamingock-ce-mongodb-springdataflamingock-ce-mongodb-springdata-v3-legacyflamingock-ce-dynamodbflamingock-ce-couchbase  note For configuration details specific to the Community Edition, see the community edition section    ","version":"1.0.0","tagName":"h2"},{"title":"2. Add Flamingock annotation processor​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#2-add-flamingock-annotation-processor","content":" Flamingock uses an annotation processor to scan and collect metadata from your changes—whether defined through code or templates.  This is required at build time and supports:  Code-based with@ChangeUnitTemplate-based (declarative YAML)  GradleMaven annotationProcessor(&quot;io.flamingock:flamingock-processor:$flamingockVersion&quot;)     ","version":"1.0.0","tagName":"h2"},{"title":"3. Define a ChangeUnit​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#3-define-a-changeunit","content":" A ChangeUnit is a unit of logic that Flamingock will execute during your application's startup.  Changes can be defined in a code-based or template-based style, depending on your preferred approach. For a deeper understanding of how changes work and when to choose one approach over the other, check out the Concepts → ChangeUnits section.  Code BasedTemplate Based @Change(id = &quot;create-table&quot;, order = &quot;1&quot;, author = &quot;antonio&quot;, transactional = false) public class CreateTableChange { @Execution public void execute(Connection connection) throws SQLException { connection.createStatement().executeUpdate(&quot;CREATE TABLE clients (id INT, name VARCHAR(255))&quot;); } @RollbackExecution public void rollback(Connection connection) throws SQLException { connection.createStatement().executeUpdate(&quot;DROP TABLE clients&quot;); } }   info You can combine both styles in the same project. See our Examples to see these in action.    ","version":"1.0.0","tagName":"h2"},{"title":"4. Configure the Setup​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#4-configure-the-setup","content":" Flamingock organizes and executes your changes using stages. By default, you'll use a single stage that groups all your changes and executes them sequentially.  Configure Flamingock using the @EnableFlamingock annotation on any class in your application:  Here’s a basic structure:  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } ) public class App { }   ","version":"1.0.0","tagName":"h2"},{"title":"Stage configuration:​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#stage-configuration","content":" location: Location where changes are found (mandatory) Package: &quot;com.yourcompany.changes&quot; - scans for code and templatesResource directory: &quot;flamingock/templates&quot; - scans for templates only(in the resources folder by default) name: (Optional) Stage name - auto-derived from location if not provided  Default approach: Most applications use a single stage: @Stage(location = &quot;com.yourcompany.changes&quot;). The name is auto-derived (&quot;changes&quot;) and this is the recommended default setup.  Advanced options: For advance options, visit our stage section    ","version":"1.0.0","tagName":"h3"},{"title":"5. Configure Flamingock​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#5-configure-flamingock","content":" Before running your application, make sure Flamingock is properly configured, depending on the edition and setup you are using:  Cloud Edition: Set your API token, service name, and environment.Community Edition: Provide connection details for your storage system (e.g., connection for MongoDB, DynamoDB, CouchBase, etc.).  This configuration is applied through the Flamingock builder.  public class App { public static void main(String[] args) { FlamingockStandalone .setApiToken(&quot;your-flamingock-api-token&quot;) .setEnvironment(&quot;dev&quot;) .setService(&quot;inventory-service&quot;) .build() .run(); } }   info If you're using some frameworks, like Spring Boot, Flamingock may run automatically on application startup (if properly configured).    ","version":"1.0.0","tagName":"h2"},{"title":"6. Compile the project​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#6-compile-the-project","content":" Now that you’ve defined your changes and configured Flamingock, it’s time to compile your project.  If everything is correctly set up, Flamingock’s annotation processor will kick in and you’ll see diagnostic messages during compilation:  Click to see the expected logs GradleMaven &gt; Task :compileJava Note: [Flamingock] Starting Flamingock annotation processor initialization. Note: [Flamingock] 'resources' parameter NOT passed. Using default 'src/main/resources' Note: [Flamingock] 'sources' parameter NOT passed. Searching in: '[src/main/java, src/main/kotlin, src/main/scala, src/main/groovy]' Note: [Flamingock] Reading flamingock setup from annotation configuration Note: [Flamingock] Initialization completed. Processed templated-based changes. Note: [Flamingock] Searching for code-based changes (Java classes annotated with @Change or legacy @ChangeUnit annotations) Note: [Flamingock] Reading flamingock setup from annotation configuration Note: [Flamingock] Finished processing annotated classes and generating metadata. Note: [Flamingock] Final processing round detected - skipping execution.   note The exact output may vary depending on your compiler settings, project layout, and whether you've customized the sources or resources paths using compiler options.  These logs confirm that:  Flamingock found your pipelineTemplate and code-based changes were processedMetadata was generated for execution  tip If you don’t see this output, ensure the annotation processor is correctly included in your dependencies and that your @Flamingock annotation is properly configured.    ","version":"1.0.0","tagName":"h2"},{"title":"7. Run your Application — Flamingock handles the changes!​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#7-run-your-application--flamingock-handles-the-changes","content":" Once your project is compiled and Flamingock is configured, you're ready to run the application.  When your application starts, Flamingock will be executed as part of the startup process:  Load the setup configuration (actually the metadata generated from the annotation configuration during the compilation)Evaluate pending changesExecute the changesAudit the execution status  ","version":"1.0.0","tagName":"h2"},{"title":"Example Output​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#example-output","content":" You should see logs like the following:  [main] INFO io.flamingock.core.runner.PipelineRunner - Starting Flamingock migration Stage: mysql_stage 1) id: create-table Started ✅ - OK Executed ✅ - OK Audited[execution] ✅ - OK [main] INFO io.flamingock.core.runner.PipelineRunner - Finished Flamingock process successfully     ","version":"1.0.0","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#next-steps","content":" Dive into Spring Boot IntegrationLearn more about Configuration OptionsUnderstand Rollback &amp; Auditing ","version":"1.0.0","tagName":"h2"},{"title":"Audit Store vs. Target System","type":0,"sectionRef":"#","url":"/docs/overview/audit-store-vs-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Audit Store​","type":1,"pageTitle":"Audit Store vs. Target System","url":"/docs/overview/audit-store-vs-target-system#audit-store","content":" The audit store is the dedicated persistence layer where Flamingock records metadata about each change unit’s execution. Its sole purpose is to capture, in an append-only log, exactly which change units ran, when they ran, who initiated them, and whether they succeeded or failed (along with any error details). This information is used to:  Prevent duplicate applications By checking the audit store before running a change unit, Flamingock guarantees each change is executed at most once. Track change history You can query the audit store to see all previously applied changes, filter by author or date range, and generate reports. Coordinate distributed execution In a clustered environment, Flamingock nodes consult the audit store to decide which change units still need to run—and to know which locks are held. Drive rollbacks and “undo” operations Since each audit entry captures rollback availability, Flamingock can navigate backward through the audit store to revert a series of changes in reverse order.  Depending on your setup, the audit store may be:  A user-provided database (for Community Edition). For example, if you run CE with MongoDB, Flamingock writes audit records into a MongoDB collection.Flamingock’s own cloud backend (for Cloud Edition). In that case, the audit store is a managed that you never host yourself.  In summary, the audit store exists solely to record what happened—and to ensure consistency and idempotency across deployments.  ","version":"1.0.0","tagName":"h2"},{"title":"Target System​","type":1,"pageTitle":"Audit Store vs. Target System","url":"/docs/overview/audit-store-vs-target-system#target-system","content":" A target system is any external resource or service upon which a change unit’s logic operates. When you write a change unit, you define @Execution and @RollbackExecution methods that perform actions against a target system—such as:  A cloud service (e.g., creating an S3 bucket or configuring a CloudFormation stack)A messaging backbone (e.g., creating a new Kafka topic, configuring permissions, or updating an existing schema)A configuration service (e.g., updating a feature-flag in Consul or Vault)A database schema (e.g., creating a new column in your relational database)A NoSQL data store (e.g., creating a new collection or index in MongoDB)Even another microservice’s REST API  The key point is that the target system is where changes must actually be applied—and those changes must occur exactly once (or be rolled back) to keep your application and its ecosystem in sync. Flamingock orchestrates these operations in a deterministic, ordered fashion, but the target system itself is whatever resource or service your change unit code touches.  ","version":"1.0.0","tagName":"h2"},{"title":"Why the distinction matters​","type":1,"pageTitle":"Audit Store vs. Target System","url":"/docs/overview/audit-store-vs-target-system#why-the-distinction-matters","content":" Because Flamingock originated from Mongock (which treated the database both as audit store and change target), it’s common to conflate these two roles. In practice:  In Cloud Edition with distributed transaction protocol (for a transactionally-capable target like an RDBMS): Flamingock writes a small “intent” or “flag” record in your own database before it writes the audit entry to the cloud store.After successfully committing your database change, Flamingock finalizes the audit record in the cloud. If anything fails at any step, Flamingock can roll everything back or clean up partial intent entries. This protocol ensures that, even though the audit store lives in the cloud, your RDBMS change and the audit record remain effectively atomic from Flamingock’s perspective. When a relational or NoSQL database serves as both audit store and change target (for example, CE running on MongoDB): Flamingock writes an audit-entry document into the same database where your data resides.For DML or DDL change units that modify that same database, Flamingock can wrap both the change and the audit insert in a single transaction—ensuring “all-or-nothing” consistency. When the change target is a different system (for example, creating S3 buckets or updating Kafka topics): The audit store remains your chosen audit database or Flamingock’s cloud backend.Flamingock cannot wrap, say, an S3 API call and the audit insert inside a single transaction, because those systems do not share a common transaction coordinator.Instead, Flamingock’s audit store logs the change unit as “executed” only after your @Execution method completes without error; if that @Execution code fails, Flamingock calls your @RollbackExecution. The audit store entry is only written once you confirm the change succeeded.    ","version":"1.0.0","tagName":"h2"},{"title":"Illustration​","type":1,"pageTitle":"Audit Store vs. Target System","url":"/docs/overview/audit-store-vs-target-system#illustration","content":" Transactional target with Cloud as audit store (Cloud Edition)​  📄 _0001_CreateUserTableChange  Targets: Transactional database (e.g., PostgreSQL)Audit store: Flamingock Cloud (Cloud Edition)Transactional behavior: Uses Flamingock’s distributed transaction protocol to guarantee atomicity between the RDBMS and the cloud audit store, achieving the same effect as a traditional transaction.  Target and audit store are the same transactional database​  📄 _0002_CreateUserTableChange  Targets: Transactional database (e.g., MongoDB)Audit store: Same MongoDB instance (Community Edition)Transactional behavior: Wrapped in a single DB transaction—so both the schema change (or data change) and the audit insert happen or fail together.  Non-transactional target with Cloud as audit store​  📄 _0003_ConfigureS3BucketChange  Targets: Amazon S3 (creating a bucket)Audit store: Flamingock Cloud (Cloud Edition)Transactional behavior: Flamingock calls S3’s createBucket.If that succeeds, Flamingock writes an audit entry to the cloud audit store.If the S3 call fails, Flamingock invokes your @RollbackExecution (deleting or cleaning up) and then writes an audit entry marking the change as “rolled back.”  note All change units within a single application must use the same audit store. You cannot mix multiple audit backends in the same application.  ","version":"1.0.0","tagName":"h3"},{"title":"Key Takeaways​","type":1,"pageTitle":"Audit Store vs. Target System","url":"/docs/overview/audit-store-vs-target-system#key-takeaways","content":" Audit Store Record of “what ran when and by whom”Used to prevent duplicates, drive rollbacks, and coordinate distributed executionHosted in Flamingock’s cloud backend (Cloud Edition) or your chosen database (CE) Target System The actual resource being modified (S3 buckets, Kafka topics, database tables, config services, and so on)Change units call external APIs or drivers against this systemMay or may not support transactions; if it does, Flamingock can co-ordinate with the audit store (via Cloud’s distributed protocol or CE’s DB transaction)  tip Distinguishing these two roles makes it clear that Flamingock’s core value lies in coordinating audit and execution—across arbitrary target systems—rather than assuming both duties are performed by the same database. This clarity ensures you can design your change units and architecture with the proper expectations around consistency, rollback, and idempotency. ","version":"1.0.0","tagName":"h2"},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/docs/overview/core-concepts","content":"","keywords":"","version":"1.0.0"},{"title":"📦 ChangeUnits​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-changeunits","content":" ChangeUnits are the fundamental structure that hold your change logic. They are executed atomically and versioned for traceability. They represent any kind of change applied to a system, such as configuration modifications, API calls, data migration, etc.  Each ChangeUnit includes:  Unique ID and metadataExecution logic (e.g., Java, YAML, or no-code template)Rollback capability  For a deeper dive around ChangeUnits, see the ChangeUnits deep dive section.  ","version":"1.0.0","tagName":"h3"},{"title":"📋 Auditing​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-auditing","content":" Flamingock includes built-in auditing for full traceability of executed changes.  Stores metadata about each executed ChangeUnit: timestamp, status, user, and systemUseful for compliance, debugging, and visibilityCan be extended to external observability platforms (e.g., ELK, Prometheus, Datadog)  ","version":"1.0.0","tagName":"h3"},{"title":"🗄️ Audit store vs. Target system​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#️-audit-store-vs-target-system","content":" Audit store: The dedicated location where Flamingock records metadata about change executions. Its sole purpose is to track which ChangeUnits ran, when, and with what outcome—ensuring idempotency, rollbacks, and distributed coordination. This might be a user-provided database (Community Edition) or Flamingock’s cloud backend (Cloud Edition). Target system: The external resource that ChangeUnits operate upon (e.g., a database schema, S3 bucket, Kafka topic, or configuration service). Flamingock’s ChangeUnits apply changes to these systems in an ordered, auditable fashion. When a database serves as both audit store and target system, Flamingock can wrap change and audit insert in one transaction; otherwise, auditing and execution occur separately.  tip To better understand the differences between Audit Store and Target System, see the Audit store vs target system section    ","version":"1.0.0","tagName":"h3"},{"title":"🏃 Runner​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-runner","content":" The Runner is the heart of Flamingock’s execution lifecycle. It’s responsible for:  Scanning, orchestrating, and executing ChangeUnits at application startup (or on-demand)Coordinating interactions with the Audit Store (via its Driver)  It can be embedded in your application or run as an independent service in distributed environments.  ","version":"1.0.0","tagName":"h3"},{"title":"🔌 Driver​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-driver","content":" A Driver acts as an adapter between Flamingock and the Audit Store. It manages all low-level interactions required for:  Writing audit-log entries when a ChangeUnit runsAcquiring and releasing distributed locksQuerying execution history to prevent duplicate runs  Depending on the edition, the Driver may connect to a user-provided database (CE) or Flamingock’s cloud backend (Cloud Edition). It does not perform any Target System changes—that responsibility lies fully with the ChangeUnit code.    ","version":"1.0.0","tagName":"h3"},{"title":"🔁 Transaction handling​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-transaction-handling","content":" Flamingock supports transactional consistency where possible:  When the target System is also a database supporting ACID transactions (like MongoDB), Flamingock ensures that a ChangeUnit’s operation on the target System and its audit-log insert into the Audit Store commit together as a single transaction.When the target System does not support transactions (e.g., HTTP APIs, file systems, or message brokers), Flamingock uses compensating actions (rollbacks) and auditing to maintain integrity.  For a deeper dive around Transactions, see the Transactions section.  ","version":"1.0.0","tagName":"h3"},{"title":"🔙 Rollbacks​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-rollbacks","content":" Each ChangeUnit can define rollback logic:  For safe reversion when operating against non-transactional systemsFor reverting to a previous version of the software (&quot;Undo&quot;), invoked via the CLI    ","version":"1.0.0","tagName":"h3"},{"title":"🧩 Templates​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-templates","content":" Flamingock introduces change templates for low-code use cases. These are YAML or JSON-based definitions that let teams describe changes declaratively—especially useful for configuration changes and SaaS integrations.  Templates are:  Extensible and version-controlledFriendly to non-developer users  For a deeper dive around Templates, see the Templates section.    ","version":"1.0.0","tagName":"h3"},{"title":"🔄 Workflows​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-workflows","content":" Workflows group and coordinate multiple ChangeUnits into stages. In future releases, they will support:  Sequential or parallel executionConditional branching (e.g., only run if a previous unit succeeded)  This will enable advanced orchestration logic during deployments or upgrades.  For a deeper dive around Workflows, see the Pipelines and stages section.    ","version":"1.0.0","tagName":"h3"},{"title":"🔒 Distributed Locking​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-distributed-locking","content":" To ensure safe execution in multi-instance deployments, Flamingock uses a distributed lock mechanism. This guarantees:  Avoidance of duplicate execution or race conditionsSynchronisation between multiple runnersCoordination across microservices in distributed environments  It supports multiple lock implementations (e.g., MongoDB, Redis, DynamoDB).  For a deeper dive around distributed locks, see the Distributed locking section.    ","version":"1.0.0","tagName":"h3"},{"title":"📣 Events​","type":1,"pageTitle":"Core Concepts","url":"/docs/overview/core-concepts#-events","content":" Flamingock is able to notify your Application around the execution status of changes via Events.  For a deeper dive around Events, see the Events section. ","version":"1.0.0","tagName":"h3"},{"title":"Flamingock editions","type":0,"sectionRef":"#","url":"/docs/overview/Editions","content":"","keywords":"","version":"1.0.0"},{"title":"🔹 Community Edition (Open Source):​","type":1,"pageTitle":"Flamingock editions","url":"/docs/overview/Editions#-community-edition-open-source","content":" The Community Edition is a free, open-source version of Flamingock that provides core functionality to execute changes in your self-provided database. The current compatible databases for this version are: MongoDB, DynamoDB, CosmosDB or Couchbase.  Key points around this edition:  Offers a similar functionality as our legacy Mongock version + expansion to control changes of any component.You provision your own database (compatible with MongoDB, DynamoDB, CosmosDB or Couchbase) - compatible to extension with additional drivers.Storage of local metadata for execution tracking (no centralised feature)Focuses on core functionality (does not include the advanced capabilities provided in the Cloud Edition).  Use this edition if you want a lightweight option you can run on your own infrastructure, and you don’t require cross-service auditability, advanced templates or features, or advanced observability (such as dashboards, metrics, environment and user management)  ","version":"1.0.0","tagName":"h2"},{"title":"☁️ Flamingock Cloud edition (Coming Soon!):​","type":1,"pageTitle":"Flamingock editions","url":"/docs/overview/Editions#️-flamingock-cloud-edition-coming-soon","content":" Flamingock's managed SaaS platform with a full-feaure offering for production-grade environments. In this edition, Flamingock offers:  All Comunity edition features, plusFull access to teamplates and extentions for accelerating integrationsCentralised auditing system to showcase Changes across all services and environmentsEnables RBAC and enterprise-ready governanceMultienvironment managementA centralised dashboard  Use this edition if you want a scalable, collaborative, and secure environment to manage change across multiple environments, services and teams - with full visibility and governance.  info Coming soon! Flamingock Cloud Edition is currently under development. If you'd like to participate in our user testing round, please contact support@flamingock.io  ","version":"1.0.0","tagName":"h2"},{"title":"💎 Flamingock self-hosted edition (Coming Soon!):​","type":1,"pageTitle":"Flamingock editions","url":"/docs/overview/Editions#-flamingock-self-hosted-edition-coming-soon","content":" Provides all the offered functionality in Flamingock Cloud, deployed in your infrastructure.  info Flamingock self-hosted edition is not released yet. Interested? If you require this edition to be available for your enterprise, please contact support@flamingock.io ","version":"1.0.0","tagName":"h2"},{"title":"Introducing Flamingock","type":0,"sectionRef":"#","url":"/docs/overview/Introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Why Flamingock?​","type":1,"pageTitle":"Introducing Flamingock","url":"/docs/overview/Introduction#why-flamingock","content":" Our objective is to reduce software release overhead by providing a tool that can be enable tracking configuration changes programatically (change-as-code), with the language of choice of the Application developer. This reduces the dependency on infrastructure engineers to maintain configuration changes that are led/introduced by the Application developer, simplifying the release process, reducing risk during deployments, and reducing time to market and skills required for developing and maintaining Configuration changes.  With multiple deployment model offerings, Flamingock provides helps teams by:  Centralising services, systems &amp; environment changesVersion and ship your system changes with your application and store them centrally. Flamingock allows operations to manage your changes (Execution, Rollback, Undo, Audit, etc.)  Reduce team &amp; skills dependenciesEmpower Developers to have full control over the Application, external configuration, and database changes. Allow to manage stateful and stateless changes in distributed systems in a safe and reliable manner.  Achieve Configuration automation of all SystemsSynchronise system dependency changes with your Application changes, as they ship together. The deployment of the Application will execute a System changes to the required state, achieving immutable deployments in any environment.  ","version":"1.0.0","tagName":"h2"},{"title":"Some example use cases​","type":1,"pageTitle":"Introducing Flamingock","url":"/docs/overview/Introduction#some-example-use-cases","content":" Some examples of these use cases (but not limited to) are:  Persistent storage managementManage deployment dependenciesConfiguration of external cloud SaaS providersDatabase migrations - supported by our legacy Mongock engine, but extended to any Database (NoSQL and SQL).API Gateway configurationsMessage broker configurations + many more!  Our tool offers managing configuration changes to any system/component in a safe and audited manner within the Application context.  What is Flamingock not suitable for?​  We are not an Infrastructure provider (neither intend to be). We believe that there are multiple good widely adopted solutions within the infrastrucuture space.  We provide Application developers the ability to configure Application domain-specific resources within those infrastructure components. This enables following a Domain-driven ownership for Application developers, provisioning them with self-serve capabilities and autonomy for configuring their resources within the boundaries of an existing infrastructure.  How Flamingock works?  ⚙️ Code It. Deploy It. Forget It.  With Flamingock, developers define any component changes (database, system changes, SaaS, etc. ) directly in application code using familiar programming constructs such as classes and annotations, or template-based formats like YAML. The Flamingock client library then:  Automatically executes changes during application startupGenerates audit trails for full transparency and complianceKeeps changes version-locked to your application releases  Benefits:  No more out-of-band scripts - Changes travel with your app codeCluster-safe execution - Designed for distributed systems from the ground upNative version control - Every change is code-reviewed alongside feature development  Built for the modern deployment pipeline where infrastructure should be as agile as your code.  👉 Dive deeper: | How it works? | Technical Overview | Quickstart Guide ","version":"1.0.0","tagName":"h2"},{"title":"Change-as-Code (CaC)","type":0,"sectionRef":"#","url":"/docs/overview/Change-as-Code","content":"","keywords":"","version":"1.0.0"},{"title":"Why CaC matters today​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#why-cac-matters-today","content":" Modern applications increasingly span dozens of external systems—ranging from relational and NoSQL databases to SaaS feature flags, message buses, and infrastructure APIs. Managing these changes manually or with ad-hoc scripts leads to:  Drift and “snowflake” environments When teams manually tweak production configurations, environments diverge, making rollbacks or audits nearly impossible. Lack of auditability Regulatory and security teams require a full record of “what changed, when, and who made it.” Spreadsheets and one-off commands don’t cut it. Inefficient collaboration Developers, operations, and security need a single source of truth: change definitions in code, reviewed and versioned via pull requests. Increased risk of human error Pasting commands into a console or clicking UI checkboxes invites typos, misconfigurations, and stress during deployment windows.  Flamingock’s CaC approach solves these problems by treating every external-system change as first-class code—complete with version control, automated execution, and a centralized audit trail.    ","version":"1.0.0","tagName":"h2"},{"title":"Four Pillars of Change-as-Code​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#four-pillars-of-change-as-code","content":" One-Hundred-Percent Versioned All ChangeUnits live in your Git repository (or other VCS). This means you can review, diff, and roll back changes just like application code. Automated Execution Flamingock scans and applies ChangeUnits at application startup or on-demand via the CLI. No manual intervention—just code running code. Auditable &amp; Traceable Every ChangeUnit outcome is recorded in an audit store (your database or Flamingock Cloud). Teams can query “who ran what change, and when,” ensuring full compliance. Cross-Component Support Whether it’s SQL/NoSQL DDL, S3 buckets, Kafka topics, feature-flag toggles, or REST API calls—Flamingock treats them all as code. Your entire system evolves in lockstep.    ","version":"1.0.0","tagName":"h2"},{"title":"“Hello, CaC” Code Snippet​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#hello-cac-code-snippet","content":" Imagine you need to toggle a feature flag in a downstream service (not a database). In Flamingock, you’d write:  @Change(id = &quot;enable-autosave&quot;, order = &quot;0005&quot;, author = &quot;ops-team&quot;) public class _0005_EnableAutoSaveFeature { @Execution public void enableAutoSave(FeatureFlagClient client) { client.setFlag(&quot;autosave_feature&quot;, true); } @RollbackExecution public void disableAutoSave(FeatureFlagClient client) { client.setFlag(&quot;autosave_feature&quot;, false); } }   Versioned: This code-based or template-based ChangeUnit lives in your VCS.Automated: Flamingock executes it in order (0005) at startup or via CLI.Auditable: Upon success, an audit entry is written to your audit store.Cross-Component: The same pattern works for a DynamoDB schema change, a Kafka topic creation, or any REST API call.    ","version":"1.0.0","tagName":"h2"},{"title":"Illustration: CaC vs. IaC​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#illustration-cac-vs-iac","content":"   Infrastructure as Code (IaC): Use Terraform, CloudFormation, Pulumi, etc., to provision VMs, networks, and databases (the “foundation”).Change as Code (CaC): Use Flamingock to version and apply everything that lives on that foundation—database schemas, feature flags, SaaS configurations, message topics, and more.    ","version":"1.0.0","tagName":"h2"},{"title":"Real-World Use Cases​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#real-world-use-cases","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Multi-tenant SaaS Onboarding​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#multi-tenant-saas-onboarding","content":" Problem: Over the lifetime of your application, you might need to create and then later modify external resources—such as an S3 bucket, Kafka topics, IAM roles, and initial database state—as part of each new release. Doing this manually or with ad-hoc scripts risks drift, missing audits, and inconsistent environments..  CaC Solution: Define a sequence of ChangeUnits that run in order on mutiple deployments, inserting audit entries and ensuring reproducible, versioned updates::  CodeTemplate @ChangeUnit(id = &quot;provision-bucket&quot;, order = &quot;0001&quot;, author = &quot;team-a&quot;, transactional = false) public class _0001_ProvisionBucketChange { @Execution public void execute(S3Client s3) { s3.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .build()); } @RollbackExecution public void rollback(S3Client s3) { s3.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .build()); } } @ChangeUnit(id = &quot;create-kafka-topics&quot;, order = &quot;0002&quot;, author = &quot;devops&quot;, transactional = false) public class _0002_CreateKafkaTopicsChange { @Execution public void exec(KafkaAdminClient admin) { NewTopic topic1 = new NewTopic(&quot;app-events&quot;, 3, (short) 1); NewTopic topic2 = new NewTopic(&quot;user-notifications&quot;, 2, (short) 1); admin.createTopics(Arrays.asList(topic1, topic2)); } @RollbackExecution public void rollback(KafkaAdminClient admin) { admin.deleteTopics(Arrays.asList(&quot;app-events&quot;, &quot;user-notifications&quot;)); } } @ChangeUnit(id = &quot;setup-iam-roles&quot;, order = &quot;0003&quot;, author = &quot;devops&quot;, transactional = false) public class _0003_SetupIamRolesChange { @Execution public void exec(IamClient iam) { CreateRoleResponse response = iam.createRole(CreateRoleRequest.builder() .roleName(&quot;flamingock-app-role&quot;) .assumeRolePolicyDocument(&quot;{...}&quot;) // truncated for brevity .build()); } @RollbackExecution public void rollback(IamClient iam) { iam.deleteRole(DeleteRoleRequest.builder() .roleName(&quot;flamingock-app-role&quot;) .build()); } } @ChangeUnit(id = &quot;seed-database&quot;, order = &quot;0004&quot;, author = &quot;devops&quot;, transactional = true) public class _0004_SeedTenantDataChange { @Execution public void exec(DataSource ds) { try (Connection conn = ds.getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate( &quot;INSERT INTO tenants (id, name, created_at) &quot; + &quot;VALUES (1, 'TenantA', NOW()), (2, 'TenantB', NOW())&quot; ); } catch (SQLException e) { throw new RuntimeException(e); } } @RollbackExecution public void rollback(DataSource ds) { try (Connection conn = ds.getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate(&quot;DELETE FROM tenants WHERE id IN (1, 2)&quot;); } catch (SQLException e) { throw new RuntimeException(e); } } } @ChangeUnit(id = &quot;update-bucket-settings&quot;, order = &quot;0005&quot;, author = &quot;team-a&quot;, transactional = false) public class _0005_UpdateBucketSettingsChange { @Execution public void execute(S3Client s3) { // Example: enable versioning on the bucket s3.putBucketVersioning(PutBucketVersioningRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .versioningConfiguration(VersioningConfiguration.builder() .status(&quot;Enabled&quot;) .build()) .build()); } @RollbackExecution public void rollback(S3Client s3) { // Example: disable versioning on the bucket s3.putBucketVersioning(PutBucketVersioningRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .versioningConfiguration(VersioningConfiguration.builder() .status(&quot;Suspended&quot;) .build()) .build()); } }   Flamingock ensures these four steps run in sequence—never twice—and logs them in your audit store for future reference.    ","version":"1.0.0","tagName":"h3"},{"title":"Change-as-Code Checklist​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#change-as-code-checklist","content":" ✅ Change lives in VCS: Every ChangeUnit class (or YAML template) is versioned.✅ Automated pipeline: Flamingock applies changes automatically at startup or via CLI.✅ Audit trail: Query your audit store for a complete history of applied changes.✅ Rollback logic: Each ChangeUnit provides @RollbackExecution to undo or compensate if needed.✅ Consistent ordering: All ChangeUnits follow a strict, declared ordering (via the order attribute).✅ Cross-component: You can target databases, SaaS APIs, feature flags, message systems—anything with a client API.    ","version":"1.0.0","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#next-steps","content":" Quickstart Guide → Learn how to create your first ChangeUnit and run Flamingock.Core concepts → Dive deeper into auditing, drivers, transactions, and distributed locking.Real use case examples → Explore real-world code samples: MongoDB, DynamoDB, Couchbase, Kafka, and more. ","version":"1.0.0","tagName":"h2"},{"title":"Key features","type":0,"sectionRef":"#","url":"/docs/overview/key-features","content":"Key features With Flamingock, you can take advantage of the following features: 🧱 Change management of any component: Manage configuration and data changes with your Application code for any component. NoSQL Databases are a first-class citizen, and we've expanded this capability for any type of component that requires configuration. info Currently supported languages: Java, Kotlin. 🔗 Extended integrations and custom use case support: Flamingock enables one-time or repeatable operational processes — such as fetching external data, initializing third-party services, or executing custom logic — ensuring they run safely, just once, and in the right context. It expands on Mongock's support to manage Database changes to all systems, databases, technologies and configurations (ie. Kafka, Twilio, Auth0, etc) or any user-defined scenario. 🧩 Flexible migration Templates: New mechanisms for defining changes, offering a no-code option to streamline and simplify change management. 🚀 Seamless deployment: Deploy your application and systems together, ensuring version compatibility and reducing deployment friction. ⚡ GraalVM support: Enables the compilation of Java applications into native executables for improved performance. 👥 Multi-Tenant support (coming soon!): Designed to handle multiple tenants within the same infrastructure. 🔒 Distributed Locking: Ensures synchronized deployment of multiple service instances, maintaining consistency and preventing conflicts in distributed environments. 🔄 Auditing &amp; Rollback: Comprehensive auditing capabilities with support for rollback of changes to ensure consistency and control. ☁️ Cloud offering (coming soon!): Offers a fully managed service by hosting Flamingock’s operational data on our servers, removing the need for users to set up and manage their own infrastructure whilst unlocking the full Flamingock suite of features. 💻 Management Operations via a Dashboard and CLI (coming soon!): Flamingock offers tools to simplify Operational management tasks. Some of these example are: List history of changes, execute Rollbacks, Undo deployment, Audit, etc. Additionally, offers a Dashboard with metrics and alerts. 🛠️ Advanced Workflow Management: Enables multiple streams of change units that can be organized to execute sequentially, in parallel, or as a combination, providing flexibility in managing complex processes. 🔀 Parallel Synchronised Execution: When workflows include parallel streams, they can be executed simultaneously by different service instances, maximizing efficiency in distributed deployments.","keywords":"","version":"1.0.0"},{"title":"Flamingock Technical Overview","type":0,"sectionRef":"#","url":"/docs/overview/technical-overview","content":"","keywords":"","version":"1.0.0"},{"title":"Architectural Overview​","type":1,"pageTitle":"Flamingock Technical Overview","url":"/docs/overview/technical-overview#architectural-overview","content":" In a nutshell, the Flamingock process takes all the pending changes and executes them in order during your Application startup process.  Application Startup → Initializes the Runner.Runner scans and loads all registered ChangeUnits.Drivers communicate with an underlying component that varies by edition. In Flamingock CE, this component is a simple storage layer (e.g., MongoDB, DynamoDB).In the Cloud and Self-Hosted editions, the driver connects to a more sophisticated Flamingock backend that includes orchestration, auditing, and support for advanced operational features. ChangeUnits execute in a coordinated workflow, optionally using templates.Distributed Locking ensures safe execution in distributed environments.All executions are audited and can be rolled backed.  Flamingock is designed to either apply all defined changes successfully or fail early. On the next run, it will resume from the last failed change.    ","version":"1.0.0","tagName":"h2"},{"title":"A more detailed process steps​","type":1,"pageTitle":"Flamingock Technical Overview","url":"/docs/overview/technical-overview#a-more-detailed-process-steps","content":" Flamingock process follows the next steps:  The runner/builder loads the pipeline of execution of changes.The runner loads the files storing the changes desired (changeUnits).The runner checks if there is pending change to execute.The runner acquires the distributed lock through the driver.The runner loops over the ChangeUnits (change files) in order.Takes the next ChangeUnit and executes it.  If the ChangeUnit is successfully executed, Flamingock persists an entry in the Flamingock change history with the state SUCCESS and start the step 5 again.If the ChangeUnit fails, the runner rolls back the change. If the driver supports transactions and transactions are enabled, the rollback is done natively. When the driver does not support transactions or transactions are disabled, the method @RollbackExecution is executed. In both cases the ChangeUnit failed, whereas in the latter option, and entry is added in the changelog that a change has been rolled back.If the runner acomplished to execute the entire migration with no failures, it's considered successful. It releases the lock and finishes the migration. On the other hand, if any ChangeUnit fails, the runner stops the migration at that point and throws an exception. When Flamingock is executed again, it will continue from the failure ChangeUnit(included). ","version":"1.0.0","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/docs/resources/examples","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#introduction","content":" The Flamingock Examples repository showcases a growing collection of real-world use cases demonstrating how to use Flamingock in different environments, integrations, and technologies. Each top-level folder represents a target technology and contains one or more self-contained example projects. Each project is designed to be cloned, explored, and run as a reference or foundation for your own implementation.  👉 GitHub Repository: github.com/flamingock/flamingock-examples    ","version":"1.0.0","tagName":"h2"},{"title":"What you’ll find​","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#what-youll-find","content":" Within each technology folder, you’ll find one or more example ​projects that demonstrate how to configure Flamingock and apply change units in various scenarios. Each folder contains its own README.md with setup instructions, and each project inside has its own documentation.  Technology Folder\tDescriptionmongodb\tFolder containing Flamingock CE projects using MongoDB as the audit‐log backend. Each project shows different integration scenarios (standalone Java, Spring Boot, etc.). dynamodb\tFolder containing Flamingock CE projects using Amazon DynamoDB for audit logging. Includes both standalone and Spring Boot examples. couchbase\tFolder containing Flamingock CE projects using Couchbase as the audit‐log backend.  More examples are planned — including PostgreSQL, Redis, LocalStack, Kafka, Spring Native, multi‐module projects, and custom runners.    ","version":"1.0.0","tagName":"h2"},{"title":"How to use the examples​","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#how-to-use-the-examples","content":" Each example folder and project includes its own README.md with detailed setup and run instructions. In general:  Clone the examples repository git clone https://github.com/flamingock/flamingock-examples.git This repository contains all the example folders for various technologies. Navigate to the technology folder of interest cd flamingock-examples/s3 Replace s3 with the folder name for the technology you are interested in (e.g., kafka, mongodb, dynamodb, etc.). Navigate to a specific example project cd s3 Each folder contains one or more projects. Move into the project folder that matches your use case or environment. Run the example For standalone Java applications: ./gradlew run For Spring Boot projects: ./gradlew bootRun Follow any additional instructions in the project’s README.md. Some examples may use Testcontainers or LocalStack; if so, ensure Docker is running on your machine.    ","version":"1.0.0","tagName":"h2"},{"title":"Who this is for​","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#who-this-is-for","content":" New users: Learn by example. Pick an example that matches your tech stack and explore how Flamingock integrates with your environment.Advanced users: Discover integration patterns with external systems like Kafka, AWS, or NoSQL databases.Contributors: Want to improve or submit a new example? Fork the repo, add your example folder, and create a pull request!    ","version":"1.0.0","tagName":"h2"},{"title":"Contributing​","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#contributing","content":" We welcome community contributions to expand this repository! Please consider:  Adding new example projects or folders (e.g., Wiremock, Kafka, PostgreSQL, Redis)Fixing or modernizing existing examplesImproving documentation and setup instructions  See the CONTRIBUTING.md for detailed guidelines. ","version":"1.0.0","tagName":"h2"},{"title":"Upgrade from Mongock to Flamingock","type":0,"sectionRef":"#","url":"/docs/resources/upgrade-from-mongock","content":"","keywords":"","version":"1.0.0"},{"title":"Upgrade steps (at a glance)​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#upgrade-steps-at-a-glance","content":" Update ChangeUnit imports – Replace Mongock annotations with Flamingock equivalents.Upgrade application code – Replace Mongock API usage with the Flamingock builder(or Spring annotation).Create system stage – Add a template-based ChangeUnit that imports legacy audit records.Configure pipeline – Point Flamingock to your legacy and new ChangeUnit packages.  That’s it! Once complete, Flamingock runs with your full history intact.  ","version":"1.0.0","tagName":"h2"},{"title":"Step1: Update artefacts​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step1-update-artefacts","content":" Replace the Mongock artefacts with Flamingock ones.  Mongock  implementation(platform(&quot;io.mongock:mongock-bom:5.5.0&quot;)) implementation(&quot;io.mongock:mongock-standalone&quot;) implementation(&quot;io.mongock:mongodb-sync-v4-driver&quot;)   Flamingock  implementation(platform(&quot;io.flamingock:flamingock-cloud-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-mongodb-sync&quot;) annotationProcessor(&quot;io.flamingock:flamingock-processor:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Step 1: Update ChangeUnit imports​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-1-update-changeunit-imports","content":" Update these imports in your existing ChangeUnits (keep them in their current packages):  Mongock import\tFlamingock importio.mongock.api.annotations.ChangeUnit\tio.flamingock.api.annotations.ChangeUnit io.mongock.api.annotations.Execution\tio.flamingock.api.annotations.Execution io.mongock.api.annotations.RollbackExecution\tio.flamingock.api.annotations.RollbackExecution  Legacy Support For existing change units: Keep them exactly as they are in their current packages - only update imports to maintain immutability.For new change units: Avoid using @BeforeExecution and @RollbackBeforeExecution. Instead, use dedicated @Execution and @RollbackExecution methods for better separation of concerns@BeforeExecution and @RollbackBeforeExecution from io.mongock.api are supported for backward compatibility  ","version":"1.0.0","tagName":"h2"},{"title":"Step 2: Upgrade application code​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-2-upgrade-application-code","content":" Flamingock(new)Mongock(legacy) Flamingock.builder() .addDependency(mongoClient) .addDependency(mongoDatabase) .build() .run();   ","version":"1.0.0","tagName":"h2"},{"title":"Key changes:​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#key-changes","content":" Replace MongockStandalone with Flamingock.builder()Remove explicit driver setup (Flamingock auto-configures it)Remove package scanning in favor of pipeline configInject dependencies via .addDependency()  For Spring Boot integration, see the Spring Boot guide.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 3: Create system stage​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-3-create-system-stage","content":" The system stage is a special stage handled by Flamingock for system-level operations. In this upgrade context, you'll create a template-based change unit in the system stage package to handle audit records migration.  Create a YAML file (e.g., _0001_upgrade_from_mongock.yaml) with the following structure:  id: upgrade-from-mongock order: 0001 template: MongoDbImporterChangeTemplate configuration: origin: mongockChangeLog failOnEmptyOrigin: true   Configuration parameters:  id: Choose how you want to identify this change unitorder: Should be the first one (0001) as this is typically the first system stage change unittemplate: Available templates: MongoDbImporterChangeTemplate, DynamoDbImporterChangeTemplate, CouchbaseImporterChangeTemplateorigin: The collection/table where Mongock's audit log is stored (typically mongockChangeLog)failOnEmptyOrigin: (Optional) Set to false to disable the security check that ensures the origin contains data. By default, Flamingock verifies the origin collection/table has content to prevent importing from the wrong source  ","version":"1.0.0","tagName":"h2"},{"title":"Step 4: Configure setup​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-4-configure-setup","content":" Configure Flamingock using the @EnableFlamingock annotation. Add this annotation to any class in your application:  @EnableFlamingock( stages = { @Stage(type = SYSTEM, location = &quot;com.yourapp.flamingock.system&quot;), @Stage(type = LEGACY, location = &quot;com.yourapp.mongock&quot;), @Stage(location = &quot;com.yourapp.flamingock.changes&quot;) } ) public class FlamingockConfig { // Configuration class }   ","version":"1.0.0","tagName":"h2"},{"title":"Configuration explained:​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#configuration-explained","content":" Stage types and usage:  System stage - A special stage for framework-level changeUnits handled by Flamingock itself. In this context, it contains the changeUnit(provided by flamingock team) that copies Mongock’s audit data into Flamingock’s storeLegacy stage - Designed specifically for the changeUnits that originally came from the legacy tool (here, Mongock). Flamingock treats it as read-only: it runs only the units that never executed under Mongock and skips those already recorded in the imported audit history. Do not add new ChangeUnits to this stage.Standard stage (default): For new Flamingock-native change units. This is where all your new application changes should be added going forward  For advanced stage configurations and multi-stage scenarios, see the setup &amp; stages guide  ","version":"1.0.0","tagName":"h3"},{"title":"Run and validate​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#run-and-validate","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Running the upgrade​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#running-the-upgrade","content":" ./gradlew run   ","version":"1.0.0","tagName":"h3"},{"title":"Expected output​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#expected-output","content":" After running Flamingock, you should see output similar to:  Stage: flamingock-system-stage 0001) id: upgrade-from-mongock Started ✅ - OK Executed ✅ - OK Audited[execution] ✅ - OK Stage: Application Changes 0001) id: create-users-collection-with-index Started ✅ - OK Executed ✅ - OK Audited[execution] ✅ - OK 0002) id: seed-users Started ✅ - OK Executed ✅ - OK Audited[execution] ✅ - OK   ","version":"1.0.0","tagName":"h3"},{"title":"Validation checklist​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#validation-checklist","content":" ✅ System stage executes the upgrade changeUnit successfully✅ Already-applied existing changeUnits from Mongock are not reapplied✅ Previously unapplied existing changeUnits from Mongock execute without errors✅ New Flamingock changeUnits execute as expected✅ All audit logs are properly created in Flamingock format✅ Database changes match the expected results    ","version":"1.0.0","tagName":"h3"},{"title":"Why upgrade instead of removing or starting fresh?​","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#why-upgrade-instead-of-removing-or-starting-fresh","content":" Preserve your audit trail – Every historical ChangeUnit and its execution log remains intact for compliance and debugging.Avoid unintended re-runs – Flamingock imports Mongock’s history, so previously-executed ChangeUnits are never applied twice.Keep change-as-code semantics – The act of migrating the audit store itself is handled as a versioned change, reinforcing the idea that history is part of your application.Future continuity – Teams and tools that rely on Mongock’s records can transition seamlessly; dashboards and reports will show an unbroken timeline.    Ready to upgrade? See the pipeline &amp; stages guide and ChangeUnit reference.  Complete example project: https://github.com/flamingock/flamingock-examples/tree/master/import-from-mongock ","version":"1.0.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/resources/faq","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#introduction","content":" This FAQ addresses frequent questions users may have when incorporating Flamingock into their applications.    ","version":"1.0.0","tagName":"h2"},{"title":"Getting started​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#getting-started","content":" Should I use a template-based or code-based ChangeUnit? Choose template-based ChangeUnits to eliminate boilerplate for common tools and integrations (SQL DDL, SaaS/API, etc) and for your custom ChangeUnits by defining changes declaratively in YAML or JSON. Use code-based ChangeUnits when you need custom or conditional logic in Java. See: Template introduction  Can I integrate Flamingock into a Spring Boot application? Yes, you can. You just need to import the Spring Boot integration module and annotate you main application with @EnableFlamingock. See: Spring Boot integration  Can I use Flamingock without Spring Boot? Yes. You can use Flamingock in any Java application by configuring it manually using the FlamingockBuilder. This approach is ideal for applications that do not rely on Spring Boot or that require finer control.  What Java version is required? Flamingock’s core engine runs on Java 8 and above. However, some optional integration modules (such as the Spring Boot support) target more recent ecosystems and require Java 17+. For those cases we publish two artifacts:  A modern module (e.g., flamingock-springboot-integration) built for Java 17+ and Spring Boot 3.xA legacy counterpart (e.g., flamingock-springboot-integration-v2-legacy) compatible with Java 8 and Spring Boot 2.x  Most users on Java 8 can stick with the core and legacy integrations; if you’re on Java 17 or newer, simply use the up-to-date modules.  Is it possible to use Flamingock in GraalVM native images? Yes, Flamingock provides a dedicated GraalVM integration guide. Ensure your dependencies and reflection requirements are correctly configured.    ","version":"1.0.0","tagName":"h3"},{"title":"Editions and compatibility​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#editions-and-compatibility","content":" What edition of Flamingock should I use? Flamingock is available in three flavors—pick the one that best fits your needs and operational model:  Cloud Edition (SaaS) A fully managed, enterprise-grade service hosted by Flamingock: Zero ops: no infrastructure to manage, no database to configureEnterprise features: cross-service dashboards, RBAC, team &amp; environment management, fully support for templates, batching, etc.24×7 support &amp; SLAs and seamless upgrades Perfect for teams that need scalability, governance, and out-of-the-box observability. Self-hosted Edition All the same features as our Cloud Edition—dashboards, governance, transaction protocols—but deployed into your own infrastructure (on-premises or in your VPC): Full feature parity with SaaS CloudData residency &amp; compliance: you control where audit records live Ideal for organizations that require enterprise capabilities but cannot—or prefer not to—consume a hosted SaaS. Community Edition Open-source, self-hosted library you run alongside your application: Lightweight &amp; free: you supply your own audit store (MongoDB, DynamoDB, Couchbase, etc.)Core capabilities: ChangeUnits, audit logging, distributed locking, and transactional consistency where supported Perfect for smaller teams or projects that need a robust, code-centric change framework.  Can I switch between editions? Yes. Flamingock provides an importer that allows you to migrate seamlessly from a Community Edition to the Cloud Edition, making it easy to adopt a fully managed backend for storing internal data.  If you are working with different Community Editions that use the same underlying store (such as MongoDB), and they share the same structure and collection for storing metadata, it is possible to switch between them with minimal adjustments. This enables flexible integration depending on your preferred access layer, such as switching from the MongoDB Java Driver edition to the Spring Data edition.    ","version":"1.0.0","tagName":"h3"},{"title":"Behaviour and execution​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#behaviour-and-execution","content":" Does Flamingock guarantee idempotent execution? Yes. Each ChangeUnit has a unique ID and Flamingock ensures it runs only once per system, even across multiple instances.  What happens if a ChangeUnit execution fails midway? When a ChangeUnit fails during execution, Flamingock handles the situation based on whether a transactional context is active: Flamingock always try to rollback the failed changes. In a transactional environment, Flamingock relies on the database transactional mechanism to rollback the changes(@Execution method) as well as the Flamingock metadata associated to the change.  In summary it would be like that change was never started. In a non-transactional environment, Flamingock manually tries to rollback the change by executing the @RollbackExecution method (if present) and marks the change entry as ROLLED_BACK in the database. Please notice that although Flamingock will try its best to achieve this, it's not guaranteed.  Once the rollback operation is performed, Flamingock will abort the execution and throw an exception. The next time Flamingock is executed will carry on from the failed ChangeUnit. It is important to note that if the ChangeUnit fails, the Application startup will exit as Flamingock will abort. This behaviour will repeat until the ChangeUnit has executed successfully.  How can I ensure changes are transactional? If your database supports transactions (e.g. MongoDB ≥ 4.0 in replica set), you can enable them using Flamingock’s transaction config.  Should I implement the @RollbackExecution method in transactional environments?  Yes, we highly recommend to implement the @RollbackExecution method. The main reason for this is that some other operations like undo, rely on this method to work. However it's a very good practice as it provides a robust system that is less affected when moving to non-transactional environments.  Can I react to the execution of Flamingock from my application? Yes. Flamingock provides an event system that allows your application to listen to key lifecycle moments, such as when a ChangeUnit starts or finishes execution. These events can be used to trigger logging, monitoring, or other side effects external to the change execution logic itself.  This enables loose coupling between Flamingock’s core execution and your application-level behaviour, without modifying the ChangeUnit directly.  For more details, see the Events guide.  Is Flamingock compatible with Spring Boot profiles? Yes. You can conditionally run ChangeUnits using @Profile, allowing changes to vary by environment.    ","version":"1.0.0","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#configuration","content":" Where do I set MongoDB connection options like write concern or read preference? You can define these directly in the config using dedicated properties (e.g. mongodb.writeConcern.w, readPreference, etc.). Refer to the extra configuration section for detailed examples.  Can I inject Spring beans or other services into my ChangeUnits? Yes. Flamingock supports full dependency injection in both Spring and non-Spring environments.  Can I define ChangeUnit dependencies and execution order? Yes. ChangeUnits can declare dependencies via annotations or configuration metadata. See ChangeUnit deep dive for more.    ","version":"1.0.0","tagName":"h3"},{"title":"Testing and development​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#testing-and-development","content":" How do I test Flamingock ChangeUnits? You can perform unit, integration, and Spring Boot integration tests using test runners and mocking utilities.  Can I use templates to generate ChangeUnits? Yes. Flamingock offers a templating mechanism for creating new ChangeUnits and defining reusable components.    ","version":"1.0.0","tagName":"h3"},{"title":"Migrating from Mongock​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#migrating-from-mongock","content":" What’s the relationship between Flamingock and Mongock? Flamingock is the direct evolution of Mongock. While it inherits the core idea of tracking and executing changes reliably, Flamingock is a complete architectural and conceptual redesign aimed at overcoming the limitations of Mongock.  Some of the key advancements introduced by Flamingock include:  Cloud-native capabilities: Support for cloud-managed storage and execution, enabling Flamingock to run in distributed, serverless, or ephemeral environments without additional setup.Execution stages and pipelines: A structured way to group and orchestrate ChangeUnits by context, environment, or lifecycle stage.Modular architecture: Clean separation of core, editions, templates, and integrations, enabling better extensibility and maintainability.Template-based ChangeUnits: An additional declarative mechanism to define reusable changes without writing Java code, accelerating development and standardisation.  While Flamingock retains conceptual compatibility with Mongock, it represents a significant leap forward in flexibility, scalability, and developer experience.  If you are currently using Mongock, we encourage you to review the migration guide and explore what Flamingock can offer in modern change management.    ","version":"1.0.0","tagName":"h3"},{"title":"Other​","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#other","content":" Is Flamingock open-source? Yes. The Flamingock client library — used across all editions, including Community, Self-managed, and Cloud — is fully open-source.  For the Cloud and Self-managed editions, additional enterprise components such as the server runtime, dashboards, and governance tools are provided under a commercial licence. These components build on top of the open-source core to deliver advanced features like observability, orchestration, and centralised management.  Is there a CLI available? A CLI is planned, but not yet available. Stay tuned.    If your question is not listed here, please check the corresponding edition’s guide or open an issue on our GitHub repository. ","version":"1.0.0","tagName":"h3"},{"title":"Template mapping","type":0,"sectionRef":"#","url":"/docs/templates/template-mapping-section","content":"","keywords":"","version":"1.0.0"},{"title":"How Execution and Rollback Mapping Works​","type":1,"pageTitle":"Template mapping","url":"/docs/templates/template-mapping-section#how-execution-and-rollback-mapping-works","content":" In a template-based change unit (declarative format), Flamingock uses the execution and rollback sections to determine which methods to invoke in your template class.  Execution​  The method annotated with @Execution is mandatory for the template developer.The execution section in the declarative change unit is mandatory for the user.If the execution section is missing, Flamingock throws an exception at startup.  Rollback​  The method annotated with @RollbackExecution is mandatory for the template developer.The rollback section in the declarative change unit is optional for the user.  The behavior of rollback varies depending on context:  Rollback during execution failure  If the system is transactional (e.g., MySQL), Flamingock relies on the system’s native transaction handling. It will not call the rollback method.If the system is non-transactional, Flamingock will: Attempt to call the @RollbackExecution method only if the user provides a rollback section in the declarative file.If no rollback config is provided, Flamingock skips the method call and logs the change as FAILED.  Rollback during Undo operations (manual reversion)  If a rollback section is present in the declarative file, Flamingock will call the @RollbackExecution method — even if the change was previously applied successfully.If no rollback is provided, Flamingock skips the rollback logic, but still marks the change as ROLLED_BACK in the audit.  note In undo operations, if rollback is not defined in the declarative file, the change is marked as reverted even though no actual rollback was executed. It’s up to the user to ensure reversibility when needed. ","version":"1.0.0","tagName":"h3"},{"title":"Create your own Flamingock template","type":0,"sectionRef":"#","url":"/docs/templates/create-your-own-template","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#introduction","content":" Flamingock Templates allow you to encapsulate common logic and reduce boilerplate when defining change units. This document explains how to create your own templates for reuse across projects or for contribution to the Flamingock community.    ","version":"1.0.0","tagName":"h2"},{"title":"Overview of the required components​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#overview-of-the-required-components","content":" To create a template, you need:  A Java class extending AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt;An @Execution method to perform the main change(Optionally) A @RollbackExecution method for undo supportA service loader registration file (META-INF/services)(Optional) Package and distribute your template    ","version":"1.0.0","tagName":"h2"},{"title":"1. Implement the Template class​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#1-implement-the-template-class","content":" Extend AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt; with three generics:  SHARED_CONFIG: Shared configuration that applies to both execution and rollback (e.g., database connection, common settings). Use Void if no shared config is needed.EXECUTION: The type representing the execution logic/dataROLLBACK: The type representing the rollback logic/data  Example:  public class MongoChangeTemplate extends AbstractChangeTemplate&lt;Void, MongoOperation, MongoOperation&gt; { public MongoChangeTemplate() { super(MongoOperation.class); } @Execution public void execute(MongoDatabase db, @Nullable ClientSession clientSession) { if (this.isTransactional &amp;&amp; clientSession == null) { throw new IllegalArgumentException(String.format(&quot;Transactional changeUnit[%s] requires transactional ecosystem with ClientSession&quot;, changeId)); } executeOp(db, execution, clientSession); } @RollbackExecution public void rollback(MongoDatabase db, @Nullable ClientSession clientSession) { if (this.isTransactional &amp;&amp; clientSession == null) { throw new IllegalArgumentException(String.format(&quot;Transactional changeUnit[%s] requires transactional ecosystem with ClientSession&quot;, changeId)); } executeOp(db, rollback, clientSession); } private void executeOp(MongoDatabase db, MongoOperation op, ClientSession clientSession) { op.getOperator(db).apply(clientSession); } }   Important notes​  Access your execution and rollback data directly via this.execution and this.rollback fields.Access shared configuration via this.configuration field (if using a non-Void shared config type).If your template references custom types, make sure to register them for reflection—especially for GraalVM native builds. When extending AbstractChangeTemplate, you can pass your custom types to the superclass constructor to ensure proper reflection support.  note See 2. Define Execution and Rollback methods section for how to implement the core logic inside your template class using the execution/rollback data and dependency injection    ","version":"1.0.0","tagName":"h2"},{"title":"2. Define Execution and Rollback methods​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#2-define-execution-and-rollback-methods","content":" Each template must include an @Execution method, and may optionally include a @RollbackExecution method. These methods define the core logic that will be executed when Flamingock runs the corresponding change.  Inside these methods, it’s expected that you use the data provided by the user in the template-based change unit through the following fields:  this.execution — the execution logic/data to apply during executionthis.rollback — the rollback logic/data to apply during rollback or undothis.configuration — shared configuration data (if using a non-Void shared config type)  An example of a template for Kafka topic management:  info This is an illustrative example to demonstrate the template structure. Real Kafka templates would use different parameters and configuration structures based on actual requirements.  public class KafkaTopicTemplate extends AbstractChangeTemplate&lt;Void, TopicConfig, String&gt; { public KafkaTopicTemplate() { super(TopicConfig.class); } @Execution public void execute(AdminClient adminClient) throws Exception { // Create topic using the execution configuration NewTopic newTopic = new NewTopic( this.execution.getName(), this.execution.getPartitions(), this.execution.getReplicationFactor() ); newTopic.configs(this.execution.getConfigs()); adminClient.createTopics(List.of(newTopic)).all().get(); } @RollbackExecution public void rollback(AdminClient adminClient) throws Exception { // Delete topic using the rollback topic name adminClient.deleteTopics(List.of(this.rollback)).all().get(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Example with Shared Configuration​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#example-with-shared-configuration","content":" When you need to share configuration between execution and rollback (such as connection details, common settings, etc.), you can use a non-Void shared configuration type:  info This is an illustrative example to demonstrate the shared configuration pattern. Real S3 templates would use different parameters and configuration structures based on actual AWS SDK requirements.  public class S3BucketTemplate extends AbstractChangeTemplate&lt;S3ConnectionConfig, BucketCreationRequest, String&gt; { public S3BucketTemplate() { super(S3ConnectionConfig.class, BucketCreationRequest.class); } @Execution public void execute() { // Access shared configuration for AWS connection AmazonS3 s3Client = AmazonS3ClientBuilder.standard() .withRegion(this.configuration.getRegion()) .withCredentials(this.configuration.getCredentialsProvider()) .build(); // Create bucket using execution configuration CreateBucketRequest request = new CreateBucketRequest(this.execution.getBucketName()) .withCannedAcl(this.execution.getAcl()); if (this.execution.getEncryption() != null) { // Apply encryption settings request.withObjectLockEnabledForBucket(this.execution.getEncryption().isEnabled()); } s3Client.createBucket(request); } @RollbackExecution public void rollback() { // Use the same shared configuration for rollback AmazonS3 s3Client = AmazonS3ClientBuilder.standard() .withRegion(this.configuration.getRegion()) .withCredentials(this.configuration.getCredentialsProvider()) .build(); // Delete bucket using rollback bucket name s3Client.deleteBucket(this.rollback); } }   This pattern is useful when:  Both execution and rollback need the same configuration data (AWS credentials, region, etc.)You want to avoid duplicating connection details or common settingsThe template needs different data for execution vs rollback operations  ","version":"1.0.0","tagName":"h3"},{"title":"Injecting dependencies into Template methods​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#injecting-dependencies-into-template-methods","content":" Template methods (such as those annotated with @Execution and @RollbackExecution) support method-level dependency injection using the same mechanism as change units.  Template classes do not support constructor injection. All dependencies must be injected as parameters in the @Execution and @RollbackExecution methods.  You can inject any registered dependency as a method parameter:  @Execution public void execute(MongoDatabase db, ClientService clientService) { clientService.doSomething(); }   info Flamingock will apply lock-safety guards unless you annotate the parameter with @NonLockGuarded.  ","version":"1.0.0","tagName":"h3"},{"title":"Mapping between template-base changeUnit file and template methods​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#mapping-between-template-base-changeunit-file-and-template-methods","content":" For details on how Flamingock maps the execution and rollback sections in your declarative change unit to the methods in your template class, refer to the Template mapping documentation.    ","version":"1.0.0","tagName":"h3"},{"title":"3. Register the Template with ServiceLoader​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#3-register-the-template-with-serviceloader","content":" Templates are discovered automatically at runtime using Java’s ServiceLoader system.  Steps:  Create a file at:  src/main/resources/META-INF/services/io.flamingock.core.api.template.ChangeTemplate   List the fully qualified class names of all templates in the file:  io.flamingock.template.kafka.CreateTopicTemplate io.flamingock.template.kafka.UpdateTopicConfigTemplate io.flamingock.template.kafka.DeleteTopicTemplate   tip Group templates by domain or technology for better maintainability.    ","version":"1.0.0","tagName":"h2"},{"title":"4. Package and distribute the Template​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#4-package-and-distribute-the-template","content":" Depending on your target:  ","version":"1.0.0","tagName":"h2"},{"title":"Internal Templates (Private)​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#internal-templates-private","content":" No special packaging needed.Keep your template class inside your application.  ","version":"1.0.0","tagName":"h3"},{"title":"Public Templates (Contributing to the Community)​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#public-templates-contributing-to-the-community","content":" Package your template as a JAR.Notify the Flamingock team via development@flamingock.io or GitHub.Submit your template for validation.  Validation Requirements:​  Clear and justified use caseName must align and not conflict with existing templatesTechnically correct and production-grade implementationPublic classes must be Javadoc-documentedSubmit a Pull Request adding the template's documentation to flamingock.github.io    ","version":"1.0.0","tagName":"h3"},{"title":"✅ Best Practices​","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#-best-practices","content":" Use AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt; with the appropriate generic types for your use case.Always provide an @RollbackExecution method if rollback or undo is expected.Use Void for generics when that type is not needed (e.g., &lt;Void, String, String&gt; for simple SQL templates).Use shared configuration (&lt;ConfigType, Void, Void&gt;) when both execution and rollback need the same configuration data.Document your template's purpose and generic types clearly for users.Ensure all custom types are registered for reflection by passing them to the superclass constructor, especially when targeting native builds.Group multiple templates by domain when packaging a library.   ","version":"1.0.0","tagName":"h2"},{"title":"How to use Flamingock Templates","type":0,"sectionRef":"#","url":"/docs/templates/templates-how-to-use","content":"","keywords":"","version":"1.0.0"},{"title":"Step 1: Add the Template dependency​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-1-add-the-template-dependency","content":" Ensure your Flamingock Template dependency is included in your project. Example of using sql-template:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-sql-template&quot;)   ","version":"1.0.0","tagName":"h3"},{"title":"Step 2: define a Template-based change​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-2-define-a-template-based-change","content":" In Flamingock, a ChangeUnit represents a single unit of work that needs to be applied to your system — for example, creating a table, updating a configuration, or setting up a cloud resource.  When using template-based changes, instead of implementing a code-based file to define the logic of the change, you describe the change in a declarative format (e.g., YAML file). The structure you use will depend on the template you’re leveraging.  Create a YAML file (e.g., _0001_create_persons_table.yaml) inside your application’s resources directory:  id: create-persons-table-from-template order: 1 templateName: sql-template templateConfiguration: executionSql: | CREATE TABLE Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) )   info Note that your application must provide a java.sql.Connection instance as a dependency to Flamingock.  🔍 Understanding the configuration attributes​  id: Unique identifier for the change, used for tracking (same as in code-based changes).order: Execution order relative to other changes (also shared with code-based).templateName: Indicates which template should be used to handle the change logic. This is required for all template-based changes.templateConfiguration: Section where you define the input parameters for the selected template. These parameters vary depending on the template. In this example, the template expects an executionSql field. Other fields: Some templates may define additional, custom configuration fields (e.g., rollbackSql for SQL template).  Template-based changes provide both structure and flexibility. They share the core concepts of change tracking with code-based ChangeUnits, but introduce a flexible configuration model where each template defines its own behavior through external parameters.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 3: Configure Flamingock to use the template file​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-3-configure-flamingock-to-use-the-template-file","content":" To configure Flamingock to use the YAML template file, you need to define a stage that includes the path to the template file using the @EnableFlamingock annotation:  @EnableFlamingock( stages = { @Stage(location = &quot;src/main/resources/templates&quot;) } ) public class MainApplication { // Configuration class }   If you prefer to use a pipeline YAML file for configuration, refer to the Setup &amp; Stages guide for more details.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 4: Run Flamingock​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-4-run-flamingock","content":" At application startup, Flamingock will automatically detect the YAML file and process it as a standard change, following the same execution flow as code-based changes.    ","version":"1.0.0","tagName":"h3"},{"title":"Use case: SQL database migration​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#use-case-sql-database-migration","content":" Let’s compare how an SQL migration is handled using a template-based ChangeUnit vs. a traditional code-based ChangeUnit.  ","version":"1.0.0","tagName":"h2"},{"title":"Approach 1: Using a Traditional Code-Based ChangeUnit​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#approach-1-using-a-traditional-code-based-changeunit","content":" import io.flamingock.api.annotations.ChangeUnit; import io.flamingock.api.annotations.Execution; import java.sql.Connection; import java.sql.SQLException; import java.sql.Statement; import javax.sql.DataSource; @ChangeUnit(id = &quot;create-persons-table&quot;, order = 1, author = &quot;developer&quot;) public class CreatePersonsTableChangeUnit { private final DataSource dataSource; public CreatePersonsTableChangeUnit(DataSource dataSource) { this.dataSource = dataSource; } @Execution public void execute() throws SQLException { try (Connection connection = dataSource.getConnection(); Statement statement = connection.createStatement()) { statement.executeUpdate(&quot;&quot;&quot; CREATE TABLE Persons ( PersonID int PRIMARY KEY, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) ) &quot;&quot;&quot;); } } }   ","version":"1.0.0","tagName":"h3"},{"title":"Approach 2: Using a Flamingock SQL Template​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#approach-2-using-a-flamingock-sql-template","content":" With the SQL Template, users define the same migration in YAML instead of Java:  id: create-persons-table-from-template order: 1 templateName: sql-template templateConfiguration: executionSql: | CREATE TABLE Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) )   ","version":"1.0.0","tagName":"h3"},{"title":"Key Benefits of Using a Template Instead of Code-Based ChangeUnits:​","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#key-benefits-of-using-a-template-instead-of-code-based-changeunits","content":" Less code maintenance: No need to write Java classes, inject DataSource, manage connections, or handle SQL execution manually.Faster onboarding: YAML is easier for non-Java developers.Standardised migrations: Ensures best practices and avoids custom implementation errors.Improved readability: Easier to review and version control. ","version":"1.0.0","tagName":"h3"},{"title":"Templates","type":0,"sectionRef":"#","url":"/docs/templates/templates-introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#introduction","content":" Flamingock Templates are pre-built modules designed to streamline the integration of common third-party services, databases, and configurations into the Flamingock change management system. These templates provide a structured way to define configuration changes in declarative format (such as YAML files), reducing the need for custom code-based ChangeUnits while ensuring seamless execution and versioning of changes.  ","version":"1.0.0","tagName":"h2"},{"title":"How It Works​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#how-it-works","content":" Flamingock Templates are designed to simplify change definitions by extracting reusable logic into modular building blocks. While Flamingock’s core approach relies on code-based ChangeUnits to manage database and system changes, Flamingock Templates provide a low-code alternative that simplifies the process for common integration scenarios. Instead of writing Java classes for each migration, users can leverage existing templates by defining changes in a declarative format(YAML, etc.).  ","version":"1.0.0","tagName":"h2"},{"title":"Who Provides Templates?​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#who-provides-templates","content":" Templates can be:  Provided by the Flamingock core team (e.g., SQL, Kafka, Redis)Offered by the communityCreated internally by teams to address common patterns in their own systems  This makes them highly adaptable: whether you're integrating a database, messaging system, or internal service, templates give you a low-code mechanism to structure your changes cleanly and consistently.  ","version":"1.0.0","tagName":"h3"},{"title":"Why Do Templates Exist?​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#why-do-templates-exist","content":" Templates exist to solve a common problem in traditional, code-based migrations: duplicated logic across ChangeUnits.  Instead of repeating the same boilerplate code over and over, templates let you externalize the logic into a reusable definition and parameterize what’s different.  ","version":"1.0.0","tagName":"h3"},{"title":"Key Features​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#key-features","content":" Pre-built, reusable modules: Each template provides a well-defined structure for managing migrations and configurations.Declarative ChangeUnits: Users define changes in YAML, avoiding Java boilerplate.Support for third-party integrations: Includes databases, messaging systems, and cloud configurations.Automatic execution and versioning: Templates are applied and tracked as part of Flamingock’s change management process.Built-in best practices: Ensures correctness and reliability for each integration.Extensible by the community: Developers can contribute new templates to expand Flamingock’s ecosystem.  ","version":"1.0.0","tagName":"h2"},{"title":"When to use Template-based ChangeUnits vs. code-based ChangeUnits​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#when-to-use-template-based-changeunits-vs-code-based-changeunits","content":" Use Case\tTemplate-Based ChangeUnit\tCode-Based ChangeUnitIntegration with third-party services (e.g., Kafka, Twilio)\t✅\t✅ Simple database migrations (e.g., SQL schema updates)\t✅\t✅ Custom logic and advanced migrations\t☑️*\t✅ Complex, dynamic change sequences\t☑️**\t✅ Low-code, configuration-driven changes\t✅\t❌  ☑️* Templates can handle custom logic if it can be abstracted and reused. Users can create custom templates to manage these scenarios.  ☑️** While templates may support complex change sequences, full control and dynamic logic might be easier to implement in code when the scenario is highly specific or non-repetitive.  ","version":"1.0.0","tagName":"h2"},{"title":"List of current Flamingock templates​","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#list-of-current-flamingock-templates","content":" Template Name\tDescriptionSQL Template\tEnables SQL-based migrations using YAML-defined ChangeUnits. Kafka Template (Upcoming)\tManages Kafka topics and configurations using YAML definitions. Twilio Template (Upcoming)\tSimplifies Twilio messaging configurations via YAML. Redis Template (Upcoming)\tAllows structured updates to Redis configurations.    Flamingock Templates unlock new possibilities for seamless application evolution. Whether you’re managing databases, configurations, or third-party services, templates simplify the process, ensuring faster, safer, and more standardised migrations.  tip Join the Flamingock community and start building your own templates today! 🚀 ","version":"1.0.0","tagName":"h2"},{"title":"Testing Flamingock","type":0,"sectionRef":"#","url":"/docs/testing/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#introduction","content":" This section provides guidance on how to test applications that use Flamingock, including strategies for validating your change logic, ensuring proper execution coordination, and maintaining audit and rollback guarantees.  Whether you are running Flamingock in a local development environment, as part of CI pipelines, or through framework integrations like Spring Boot, testing is a key part of ensuring consistency and reliability across deployments.  Flamingock is not limited to database systems — it supports a wide range of targets (e.g., message brokers, file systems, APIs). Your testing strategy should reflect the behavior of the underlying systems you integrate with.    ","version":"1.0.0","tagName":"h2"},{"title":"What to test​","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#what-to-test","content":" There are three primary levels at which Flamingock-related functionality can be tested:  ","version":"1.0.0","tagName":"h2"},{"title":"1. Unit test: Change logic​","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#1-unit-test-change-logic","content":" Isolate and test the logic inside your @Execution and @RollbackExecution methods without involving Flamingock’s runtime or audit mechanism.  Use mocks for dependencies (e.g., MongoTemplate, DynamoDbClient, S3Client)Focus on business correctness and expected side effectsNo audit logs or locking are involved  👉 See Unit testing your change units    ","version":"1.0.0","tagName":"h3"},{"title":"2. Integration test: Flamingock execution​","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#2-integration-test-flamingock-execution","content":" Run Flamingock end-to-end in a controlled environment to verify:  Execution of the @Execution methodAudit log persistenceRollback behavior on failure  This usually requires a real or containerized backend system (e.g., using Testcontainers).  👉 See Integration testing Flamingock    ","version":"1.0.0","tagName":"h3"},{"title":"3. Spring Boot integration​","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#3-spring-boot-integration","content":" For applications using Spring Boot, test how Flamingock integrates with your app lifecycle:  Use @SpringBootTest to validate full configurationConfirm that changes run on startupOptionally inject mocks to verify execution paths  👉 See Testing with Spring Boot ","version":"1.0.0","tagName":"h3"},{"title":"Integration Testing","type":0,"sectionRef":"#","url":"/docs/testing/integration-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#introduction","content":" Integration tests ensure that Flamingock operates correctly in a real environment by executing changes against live systems — such as databases, cloud APIs, or internal services.  These tests involve spinning up the actual backend system and running Flamingock end-to-end:  Change unit executionAudit log persistenceDistributed lock acquisition  Integration tests should be used to validate that the full pipeline behaves as expected — from execution to rollback.    ","version":"1.0.0","tagName":"h2"},{"title":"Example: Creating an S3 bucket​","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#example-creating-an-s3-bucket","content":" Suppose you have a change unit that creates an Amazon S3 bucket:  @Change(id = &quot;create-bucket&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;) public class _0001_CreateS3BucketChange { @Execution public void execute(S3Client s3Client) { s3Client.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } @RollbackExecution public void rollback(S3Client s3Client) { s3Client.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Integration test with Testcontainers​","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#integration-test-with-testcontainers","content":" To test this change end-to-end, we will:  Spin up a MongoDB container to be used as Flamingock’s audit backendInject a real S3 client (mocked, localstack, or real AWS)Configure Flamingock and execute it  class IntegrationTest { static final MongoDBContainer mongoContainer = new MongoDBContainer(&quot;mongo:6.0&quot;); @BeforeAll static void initMongo() { mongoContainer.start(); } @AfterAll static void tearDown() { mongoContainer.stop(); } @Test void shouldExecuteChangeAgainstS3AndAuditToMongo() { S3Client s3Client = S3Client.builder() .region(Region.EU_WEST_1) .build(); MongoClient mongoClient = MongoClients.create(mongoContainer.getReplicaSetUrl()); Runner runner = Flamingock.builder() .addDependency(s3Client) .addDependency(mongoClient) .setProperty(&quot;mongodb.databaseName&quot;, &quot;test-db&quot;) .build(); runner.execute(); // ✅ Verify the S3 bucket was created ListBucketsResponse buckets = s3Client.listBuckets(); boolean bucketExists = buckets.buckets().stream() .anyMatch(b -&gt; b.name().equals(&quot;flamingock-test-bucket&quot;)); assertTrue(bucketExists, &quot;Expected S3 bucket was not found&quot;); // ✅ Verify the change was audited in MongoDB MongoDatabase db = mongoClient.getDatabase(&quot;test-db&quot;); MongoCollection&lt;Document&gt; auditCollection = db.getCollection(&quot;flamingockAuditLogs&quot;); Document document = new Document(&quot;changeId&quot;, &quot;create-bucket&quot;) .append(&quot;state&quot;,&quot;EXECUTED&quot;); Document auditEntry = auditCollection.find(document).first(); assertNotNull(auditEntry, &quot;Flamingock audit log entry was not found in MongoDB&quot;); } }     ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#-best-practices","content":" Use Testcontainers to spin up a real audit backend (e.g., MongoDB) — this avoids the need for manual test setupRun Flamingock fully using .build().execute() — don’t call internal methods manuallyClean up the backend between tests or isolate data with unique test identifiersValidate changes by checking the actual target system or using custom assertionsUse integration tests sparingly — unit tests are faster and should cover most logic ","version":"1.0.0","tagName":"h2"},{"title":"Unit Testing","type":0,"sectionRef":"#","url":"/docs/testing/unit-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#introduction","content":" Unit tests focus on verifying the internal logic of a single change unit, without relying on any external system. They are fast, isolated, and ideal for validating:  That the @Execution method performs the correct logicThat the @RollbackExecution method compensates properly on failureThat injected dependencies are used as expected (using mocks or fakes)  Unit tests are most useful when your change unit contains business logic, computation, validation, or decisions.    ","version":"1.0.0","tagName":"h2"},{"title":"Example: Creating an S3 bucket​","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#example-creating-an-s3-bucket","content":" Suppose you have a change unit that creates an Amazon S3 bucket:  @Change(id = &quot;create-bucket&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;) public class _0001_CreateS3BucketChange { @Execution public void execute(S3Client s3Client) { s3Client.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } @RollbackExecution public void rollback(S3Client s3Client) { s3Client.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Writing a unit test​","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#writing-a-unit-test","content":" To unit test this class, we use JUnit and a mocking library (e.g., Mockito). We'll mock the S3Client and verify the correct calls were made.  class _0001_CreateS3BucketChangeTest { private final S3Client s3Client = mock(S3Client.class); private final CreateS3BucketChange change = new CreateS3BucketChange(); @Test void shouldCallCreateBucketOnExecution() { S3Client s3Client = mock(S3Client.class); new _0001_CreateS3BucketChange().execute(s3Client); verify(s3Client).createBucket(argThat(req -&gt; req.bucket().equals(&quot;flamingock-test-bucket&quot;))); } @Test void shouldCallDeleteBucketOnRollback() { S3Client s3Client = mock(S3Client.class); new _0001_CreateS3BucketChange().rollback(s3Client); verify(s3Client).deleteBucket(argThat(req -&gt; req.bucket().equals(&quot;flamingock-test-bucket&quot;))); } }     ","version":"1.0.0","tagName":"h2"},{"title":"✅ Best practices​","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#-best-practices","content":" Use mocks or fakes to isolate the dependencies used in your change unitFocus only on the logic inside the @Execution and @RollbackExecution methodsKeep assertions specific and minimal — check that the right dependencies are calledAvoid testing Flamingock itself (e.g., locking or audit behavior — that’s handled in integration tests)Use descriptive test names like shouldCallCreateBucketOnExecution() for readability ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot Testing","type":0,"sectionRef":"#","url":"/docs/testing/springboot-integration-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#introduction","content":" This guide explains how to write integration tests for Flamingock when using Spring Boot with the @EnableFlamingock annotation.  With this setup:  Flamingock is auto-configured using Spring Boot propertiesDependencies like Kafka AdminClient or DynamoDbClient must be declared as Spring beansThe change units are executed end-to-end using real systems (e.g., DynamoDB Local, Kafka, S3)  This test style is ideal for verifying that Flamingock interacts correctly with both its audit backend and any external systems.    ","version":"1.0.0","tagName":"h2"},{"title":"Example: Modifying a Kafka topic and auditing to DynamoDB​","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#example-modifying-a-kafka-topic-and-auditing-to-dynamodb","content":" Suppose you have a change unit that modifies a Kafka topic configuration:  @Change(id = &quot;modify-topic-config&quot;, order = &quot;0002&quot;, author = &quot;dev-team&quot;) public class _0002_ModifyKafkaTopicConfig { @Execution public void execute(AdminClient adminClient) { Map&lt;ConfigResource, Config&gt; configs = Map.of( new ConfigResource(ConfigResource.Type.TOPIC, &quot;orders&quot;), new Config(List.of(new ConfigEntry(&quot;retention.ms&quot;, &quot;86400000&quot;))) ); adminClient.alterConfigs(configs).all().join(); } @RollbackExecution public void rollback(AdminClient adminClient) { Map&lt;ConfigResource, Config&gt; configs = Map.of( new ConfigResource(ConfigResource.Type.TOPIC, &quot;orders&quot;), new Config(List.of(new ConfigEntry(&quot;retention.ms&quot;, &quot;604800000&quot;))) ); adminClient.alterConfigs(configs).all().join(); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Writing the test​","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#writing-the-test","content":" In this test, we’ll:  Spin up Kafka and DynamoDB Local using TestcontainersProvide the required beans (AdminClient, DynamoDbClient) to Spring BootAssert that the Flamingock change unit executed and was audited to DynamoDB  info Flamingock requires DynamoDbClient and other injected services (like AdminClient) to be present in the Spring ApplicationContext. Spring Boot will auto-detect them if they are declared as @Beans.  @SpringBootTest @Testcontainers @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) public class FlamingockSpringbootTest { static final KafkaContainer kafka = new KafkaContainer(DockerImageName.parse(&quot;confluentinc/cp-kafka:7.2.1&quot;)); static final GenericContainer&lt;?&gt; dynamoDb = new GenericContainer&lt;&gt;(&quot;amazon/dynamodb-local&quot;) .withExposedPorts(8000); @BeforeAll static void startContainers() { kafka.start(); dynamoDb.start(); } @AfterAll static void stopContainers() { kafka.stop(); dynamoDb.stop(); } @Bean public DynamoDbClient dynamoDbClient() { return DynamoDbClient.builder() .region(Region.US_EAST_1) .endpointOverride(URI.create(&quot;http://&quot; + dynamoDb.getHost() + &quot;:&quot; + dynamoDb.getFirstMappedPort())) .build(); } @Bean public AdminClient kafkaAdminClient() { Properties config = new Properties(); config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()); return AdminClient.create(config); } @Test void shouldExecuteChangeAndWriteAuditToDynamoDB() { DynamoDbClient client = dynamoDbClient(); ScanResponse scan = client.scan(ScanRequest.builder() .tableName(&quot;flamingockAuditLogs&quot;) .build()); boolean changeExecuted = scan.items().stream() .anyMatch(item -&gt; &quot;modify-topic-config&quot;.equals(item.get(&quot;changeId&quot;).s()) &amp;&amp; &quot;EXECUTED&quot;.equals(item.get(&quot;state&quot;).s())); assertTrue(changeExecuted, &quot;Audit log entry for executed change not found in DynamoDB&quot;); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Advanced configuration​","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#advanced-configuration","content":" Flamingock can be configured using Spring Boot properties, either in your application.yml or dynamically via @DynamicPropertySource.  This is especially useful for setting values like:  @DynamicPropertySource static void overrideProperties(DynamicPropertyRegistry registry) { String endpoint = &quot;http://&quot; + dynamoDb.getHost() + &quot;:&quot; + dynamoDb.getFirstMappedPort(); registry.add(&quot;flamingock.dynamodb.readCapacityUnits&quot;, () -&gt; 5L); registry.add(&quot;flamingock.dynamodb.writeCapacityUnits&quot;, () -&gt; 5L); registry.add(&quot;flamingock.dynamodb.autoCreate&quot;, () -&gt; true); registry.add(&quot;flamingock.dynamodb.auditRepositoryName&quot;, () -&gt; &quot;flamingockAuditLogs&quot;); registry.add(&quot;flamingock.dynamodb.lockRepositoryName&quot;, () -&gt; &quot;flamingockLock&quot;); }   These properties allow Flamingock to connect to the appropriate DynamoDB instance and create its internal metadata tables automatically.    ","version":"1.0.0","tagName":"h2"},{"title":"Best practices​","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#best-practices","content":" Declare all required dependencies (like DynamoDbClient, AdminClient, etc.) as Spring beansUse @DynamicPropertySource to inject dynamic config for local/test environmentsValidate both the external effect (Kafka, S3, etc.) and the audit record in the backendUse Testcontainers for isolation and reproducibility across environmentsKeep tests focused: use Spring Boot only when testing real integration scenarios (not just logic) ","version":"1.0.0","tagName":"h2"}],"options":{"languages":["en"],"id":"default"}}