"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[9011],{3941:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"safety-and-recovery/recovery-strategies","title":"Recovery strategies","description":"Recovery strategies determine how Flamingock handles ChangeUnit execution failures. They provide configurable behavior to balance safety with automation based on your specific requirements.","source":"@site/docs/safety-and-recovery/recovery-strategies.md","sourceDirName":"safety-and-recovery","slug":"/safety-and-recovery/recovery-strategies","permalink":"/docs/safety-and-recovery/recovery-strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/flamingock/flamingock-java/docs/safety-and-recovery/recovery-strategies.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Recovery strategies","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Issue Resolution","permalink":"/docs/safety-and-recovery/issue-resolution"},"next":{"title":"Introduction","permalink":"/docs/templates/templates-introduction"}}');var i=t(4848),a=t(8453);const s={title:"Recovery strategies",sidebar_position:2},o="Recovery strategies",l={},c=[{value:"Strategy types",id:"strategy-types",level:2},{value:"Manual intervention (default)",id:"manual-intervention-default",level:3},{value:"Always retry",id:"always-retry",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Code-based ChangeUnits",id:"code-based-changeunits",level:3},{value:"Template-based ChangeUnits",id:"template-based-changeunits",level:3},{value:"When failures occur",id:"when-failures-occur",level:2},{value:"Manual intervention workflow",id:"manual-intervention-workflow",level:3},{value:"Always retry workflow",id:"always-retry-workflow",level:3},{value:"Best practices",id:"best-practices",level:2},{value:"Choose manual intervention when:",id:"choose-manual-intervention-when",level:3},{value:"Choose always retry when:",id:"choose-always-retry-when",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"recovery-strategies",children:"Recovery strategies"})}),"\n",(0,i.jsx)(n.p,{children:"Recovery strategies determine how Flamingock handles ChangeUnit execution failures. They provide configurable behavior to balance safety with automation based on your specific requirements."}),"\n",(0,i.jsx)(n.h2,{id:"strategy-types",children:"Strategy types"}),"\n",(0,i.jsx)(n.h3,{id:"manual-intervention-default",children:"Manual intervention (default)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior"}),": Stops execution and requires human intervention when any failure occurs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use case"}),": When safety is prioritized over automation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Technical challenge"}),": Prevents silent failures and ensures human oversight for uncertain outcomes"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"always-retry",children:"Always retry"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior"}),": Automatically retries the change on subsequent executions until successful"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use case"}),": When changes are idempotent and safe to retry automatically"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Technical challenge"}),": Reduces operational overhead for recoverable failures"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"code-based-changeunits",children:"Code-based ChangeUnits"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"@Recovery"})," annotation to specify the strategy:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Default behavior (manual intervention)\n@ChangeUnit(id = "example-change", order = "001", author = "team")\npublic class ExampleChange {\n    @Execution\n    public void execute() {\n        // Change logic here\n    }\n}\n\n// Explicit always retry\n@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)\n@ChangeUnit(id = "retry-change", order = "002", author = "team")\npublic class RetryChange {\n    @Execution\n    public void execute() {\n        // Idempotent change logic here\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"template-based-changeunits",children:"Template-based ChangeUnits"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"recovery"})," field in your YAML configuration:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Default behavior (manual intervention)\nid: example-change\norder: "001"\nauthor: team\ntemplate: example-template\nexecution: |\n  # Change logic here\n\n---\n\n# Explicit always retry\nid: retry-change\norder: "002"\nauthor: team\nrecovery: ALWAYS_RETRY\ntemplate: example-template\nexecution: |\n  # Idempotent change logic here\n'})}),"\n",(0,i.jsx)(n.h2,{id:"when-failures-occur",children:"When failures occur"}),"\n",(0,i.jsx)(n.h3,{id:"manual-intervention-workflow",children:"Manual intervention workflow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Execution stops immediately on failure"}),"\n",(0,i.jsx)(n.li,{children:"Issue is logged in the audit store"}),"\n",(0,i.jsx)(n.li,{children:"Use CLI tools to investigate and resolve"}),"\n",(0,i.jsx)(n.li,{children:"Mark change as applied or rolled back manually"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"always-retry-workflow",children:"Always retry workflow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Execution fails but continues on next run"}),"\n",(0,i.jsx)(n.li,{children:"Change attempts retry automatically"}),"\n",(0,i.jsx)(n.li,{children:"Process continues until successful or manually intervened"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,i.jsx)(n.h3,{id:"choose-manual-intervention-when",children:"Choose manual intervention when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Changes modify critical system state"}),"\n",(0,i.jsx)(n.li,{children:"Failures require investigation before proceeding"}),"\n",(0,i.jsx)(n.li,{children:"Rollback logic is complex or requires validation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"choose-always-retry-when",children:"Choose always retry when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Operations are truly idempotent"}),"\n",(0,i.jsx)(n.li,{children:"Failures are typically transient (network, temporary unavailability)"}),"\n",(0,i.jsx)(n.li,{children:"Automatic recovery is acceptable"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For detailed information on ChangeUnit annotations and configuration, see ",(0,i.jsx)(n.a,{href:"/docs/change-units/anatomy-and-structure",children:"ChangeUnit anatomy"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For operational workflows when issues occur, see ",(0,i.jsx)(n.a,{href:"/docs/safety-and-recovery/issue-resolution",children:"Issue resolution"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);