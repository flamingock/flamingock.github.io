"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[3663],{8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var t=i(6540);const s={},a=t.createContext(s);function d(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(a.Provider,{value:n},e.children)}},9785:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"testing/flamingock-bdd-api","title":"Flamingock BDD API","description":"Introduction","source":"@site/docs/testing/flamingock-bdd-api.md","sourceDirName":"testing","slug":"/testing/flamingock-bdd-api","permalink":"/testing/flamingock-bdd-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2.5,"frontMatter":{"title":"Flamingock BDD API","sidebar_position":2.5},"sidebar":"tutorialSidebar","previous":{"title":"Unit Testing","permalink":"/testing/unit-testing"},"next":{"title":"Integration testing","permalink":"/testing/integration-testing"}}');var s=i(4848),a=i(8453);const d={title:"Flamingock BDD API",sidebar_position:2.5},l=void 0,c={},r=[{value:"Introduction",id:"introduction",level:2},{value:"AuditEntryDefinition",id:"auditentrydefinition",level:2},{value:"String-based (manual)",id:"string-based-manual",level:3},{value:"Class-based (recommended)",id:"class-based-recommended",level:3},{value:"Fluent builder",id:"fluent-builder",level:3},{value:"Selective field validation",id:"selective-field-validation",level:3},{value:"WhenStage",id:"whenstage",level:2},{value:"Validators",id:"validators",level:2},{value:"ExpectAuditFinalStateSequence",id:"expectauditfinalstatesequence",level:3},{value:"ExpectException",id:"expectexception",level:3},{value:"Final states",id:"final-states",level:2},{value:"Complete example",id:"complete-example",level:2}];function o(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Flamingock's test support framework provides a fluent BDD-style API for writing integration tests. This API is shared between standalone and Spring Boot tests \u2014 once you understand these concepts, you can apply them in either context."}),"\n",(0,s.jsxs)(n.p,{children:["The API follows a ",(0,s.jsx)(n.strong,{children:"Given-When-Then"})," pattern:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"FlamingockTestSupport\n    .givenBuilder(builder)                           // Given: configure the builder\n    .andExistingAudit(APPLIED(PreviousChange.class)) // Given: set up existing audit state\n    .whenRun()                                       // When: trigger execution\n    .thenExpectAuditFinalStateSequence(...)          // Then: define expectations\n    .verify();                                       // Execute and validate\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Lazy execution",type:"info",children:(0,s.jsxs)(n.p,{children:["All methods are ",(0,s.jsx)(n.strong,{children:"intermediate operations"})," \u2014 nothing executes until ",(0,s.jsx)(n.code,{children:"verify()"})," is called. This allows you to build complex test scenarios before running them."]})}),"\n",(0,s.jsx)(n.h2,{id:"auditentrydefinition",children:"AuditEntryDefinition"}),"\n",(0,s.jsx)(n.p,{children:"Factory methods to define expected audit entries. Import statically for cleaner tests:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import static io.flamingock.support.domain.AuditEntryDefinition.*;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"string-based-manual",children:"String-based (manual)"}),"\n",(0,s.jsx)(n.p,{children:"Specify the change ID directly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'APPLIED("change-id")\nFAILED("change-id")\nROLLED_BACK("change-id")\nROLLBACK_FAILED("change-id")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"class-based-recommended",children:"Class-based (recommended)"}),"\n",(0,s.jsx)(n.p,{children:"Pass the change class to auto-extract metadata from annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"APPLIED(MyChange.class)\nFAILED(MyChange.class)\nROLLED_BACK(MyChange.class)\nROLLBACK_FAILED(MyChange.class)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach automatically extracts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"changeId"})," from ",(0,s.jsx)(n.code,{children:"@Change"})," annotation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"author"})," from ",(0,s.jsx)(n.code,{children:"@Change"})," annotation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"className"})," and ",(0,s.jsx)(n.code,{children:"methodName"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"targetSystemId"})," from ",(0,s.jsx)(n.code,{children:"@TargetSystem"})," annotation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"order"})," and ",(0,s.jsx)(n.code,{children:"transactional"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"fluent-builder",children:"Fluent builder"}),"\n",(0,s.jsx)(n.p,{children:"Add or override specific fields:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'APPLIED(MyChange.class)\n    .withAuthor("custom-author")\n    .withTargetSystemId("mongodb-main")\n    .withErrorTrace("Expected error message")\n    .withTransactional(true)\n    .withOrder("001")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"selective-field-validation",children:"Selective field validation"}),"\n",(0,s.jsxs)(n.p,{children:["The validator only checks fields that are ",(0,s.jsx)(n.strong,{children:"set"})," in the definition:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Definition"}),(0,s.jsx)(n.th,{children:"Fields validated"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'APPLIED("my-change")'})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"changeId"}),", ",(0,s.jsx)(n.code,{children:"state"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"APPLIED(MyChange.class)"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"changeId"}),", ",(0,s.jsx)(n.code,{children:"state"}),", ",(0,s.jsx)(n.code,{children:"author"}),", ",(0,s.jsx)(n.code,{children:"className"}),", ",(0,s.jsx)(n.code,{children:"methodName"}),", ",(0,s.jsx)(n.code,{children:"order"}),", ",(0,s.jsx)(n.code,{children:"transactional"}),", ",(0,s.jsx)(n.code,{children:"targetSystemId"}),", ",(0,s.jsx)(n.code,{children:"recoveryStrategy"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'APPLIED("id").withAuthor("x")'})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"changeId"}),", ",(0,s.jsx)(n.code,{children:"state"}),", ",(0,s.jsx)(n.code,{children:"author"})]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"whenstage",children:"WhenStage"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"whenRun()"})," method marks the transition from setup to expectations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:".givenBuilder(builder)\n.andExistingAudit(APPLIED(PreviousChange.class))\n.whenRun()  // Transition point\n.thenExpect...\n"})}),"\n",(0,s.jsx)(n.h2,{id:"validators",children:"Validators"}),"\n",(0,s.jsx)(n.h3,{id:"expectauditfinalstatesequence",children:"ExpectAuditFinalStateSequence"}),"\n",(0,s.jsx)(n.p,{children:"Validates the final audit state after execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:".whenRun()\n.thenExpectAuditFinalStateSequence(\n    APPLIED(Change1.class),\n    APPLIED(Change2.class)\n)\n.verify();\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Validates only ",(0,s.jsx)(n.strong,{children:"final states"}),": ",(0,s.jsx)(n.code,{children:"APPLIED"}),", ",(0,s.jsx)(n.code,{children:"FAILED"}),", ",(0,s.jsx)(n.code,{children:"ROLLED_BACK"}),", ",(0,s.jsx)(n.code,{children:"ROLLBACK_FAILED"})]}),"\n",(0,s.jsxs)(n.li,{children:["Filters out intermediate states like ",(0,s.jsx)(n.code,{children:"STARTED"})]}),"\n",(0,s.jsxs)(n.li,{children:["Requires ",(0,s.jsx)(n.strong,{children:"exact count match"})," \u2014 if 3 changes executed, provide exactly 3 definitions"]}),"\n",(0,s.jsxs)(n.li,{children:["Preserves ",(0,s.jsx)(n.strong,{children:"order"})," \u2014 expected[0] must match actual[0], etc."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"expectexception",children:"ExpectException"}),"\n",(0,s.jsx)(n.p,{children:"Expects an exception to be thrown during execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'.whenRun()\n.thenExpectException(PipelineExecutionException.class, ex -> {\n    assertTrue(ex.getMessage().contains("Expected error"));\n})\n.verify();\n'})}),"\n",(0,s.jsx)(n.p,{children:"If you don't need to validate the exception details, use the single-parameter overload:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:".thenExpectException(PipelineExecutionException.class)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"final-states",children:"Final states"}),"\n",(0,s.jsxs)(n.p,{children:["The audit log may contain multiple entries per change (e.g., ",(0,s.jsx)(n.code,{children:"STARTED"})," then ",(0,s.jsx)(n.code,{children:"APPLIED"}),"). Validators filter out intermediate states and only consider final outcomes:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"APPLIED"})}),(0,s.jsx)(n.td,{children:"Change successfully applied"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FAILED"})}),(0,s.jsx)(n.td,{children:"Change execution failed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ROLLED_BACK"})}),(0,s.jsx)(n.td,{children:"Change was rolled back after failure"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ROLLBACK_FAILED"})}),(0,s.jsx)(n.td,{children:"Rollback itself failed"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'import static io.flamingock.support.domain.AuditEntryDefinition.*;\n\n@Test\nvoid shouldHandlePartialFailureWithRollback() {\n    FlamingockTestSupport\n        .givenBuilder(builder)\n        .andExistingAudit(\n            APPLIED(InitialSetupChange.class)  // Already applied in previous run\n        )\n        .whenRun()\n        .thenExpectException(PipelineExecutionException.class, ex -> {\n            assertThat(ex.getMessage()).contains("Intentional failure");\n        })\n        .andExpectAuditFinalStateSequence(\n            APPLIED(InitialSetupChange.class),  // Unchanged from precondition\n            APPLIED(SuccessfulChange.class),    // New change succeeded\n            FAILED(FailingChange.class),        // This change failed\n            ROLLED_BACK(FailingChange.class)    // And was rolled back\n        )\n        .verify();\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);