"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[398],{2613:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"overview/core-concepts","title":"Core Concepts","description":"\ud83d\udce6 ChangeUnits","source":"@site/docs/overview/core-concepts.md","sourceDirName":"overview","slug":"/overview/core-concepts","permalink":"/docs/1.0.0/overview/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/overview/core-concepts.md","tags":[],"version":"current","sidebarPosition":80,"frontMatter":{"sidebar_position":80},"sidebar":"tutorialSidebar","previous":{"title":"Flamingock editions","permalink":"/docs/1.0.0/overview/Editions"},"next":{"title":"Flamingock Technical Overview","permalink":"/docs/1.0.0/overview/technical-overview"}}');var t=i(4848),r=i(8453);const a={sidebar_position:80},o="Core Concepts",l={},c=[{value:"\ud83d\udce6 ChangeUnits",id:"-changeunits",level:3},{value:"\ud83d\udccb Auditing",id:"-auditing",level:3},{value:"\ud83d\uddc4\ufe0f Audit store vs. Target system",id:"\ufe0f-audit-store-vs-target-system",level:3},{value:"\ud83c\udfc3 Runner",id:"-runner",level:3},{value:"\ud83d\udd0c Driver",id:"-driver",level:3},{value:"\ud83d\udd01 Transaction handling",id:"-transaction-handling",level:3},{value:"\ud83d\udd19 Rollbacks",id:"-rollbacks",level:3},{value:"\ud83e\udde9 Templates",id:"-templates",level:3},{value:"\ud83d\udd04 Workflows",id:"-workflows",level:3},{value:"\ud83d\udd12 Distributed Locking",id:"-distributed-locking",level:3},{value:"\ud83d\udce3 Events",id:"-events",level:3}];function d(e){const n={a:"a",admonition:"admonition",em:"em",h1:"h1",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,t.jsx)(n.h3,{id:"-changeunits",children:"\ud83d\udce6 ChangeUnits"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ChangeUnits"})," are the fundamental structure that hold your change logic. They are executed atomically and versioned for traceability. They represent any kind of change applied to a system, such as configuration modifications, API calls, data migration, etc."]}),"\n",(0,t.jsx)(n.p,{children:"Each ChangeUnit includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Unique ID and metadata"}),"\n",(0,t.jsx)(n.li,{children:"Execution logic (e.g., Java, YAML, or no-code template)"}),"\n",(0,t.jsx)(n.li,{children:"Rollback capability"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For a deeper dive around ChangeUnits, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/flamingock-library-config/changeunits-deep-dive",children:"ChangeUnits deep dive"})," section."]}),"\n",(0,t.jsx)(n.h3,{id:"-auditing",children:"\ud83d\udccb Auditing"}),"\n",(0,t.jsxs)(n.p,{children:["Flamingock includes built-in ",(0,t.jsx)(n.strong,{children:"auditing"})," for full traceability of executed changes."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores metadata about each executed ChangeUnit: timestamp, status, user, and system"}),"\n",(0,t.jsx)(n.li,{children:"Useful for compliance, debugging, and visibility"}),"\n",(0,t.jsx)(n.li,{children:"Can be extended to external observability platforms (e.g., ELK, Prometheus, Datadog)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-audit-store-vs-target-system",children:"\ud83d\uddc4\ufe0f Audit store vs. Target system"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Audit store"}),": The dedicated location where Flamingock records metadata about change executions. Its sole purpose is to track which ChangeUnits ran, when, and with what outcome\u2014ensuring idempotency, rollbacks, and distributed coordination. This might be a user-provided database (Community Edition) or Flamingock\u2019s cloud backend (Cloud Edition)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Target system"}),": The external resource that ChangeUnits operate upon (e.g., a database schema, S3 bucket, Kafka topic, or configuration service). Flamingock\u2019s ChangeUnits apply changes to these systems in an ordered, auditable fashion. When a database serves as both audit store and target system, Flamingock can wrap change and audit insert in one transaction; otherwise, auditing and execution occur separately."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["To better understand the differences between Audit Store and Target System, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/overview/audit-store-vs-target-system",children:"Audit store vs target system section"})]})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-runner",children:"\ud83c\udfc3 Runner"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Runner"})," is the heart of Flamingock\u2019s execution lifecycle. It\u2019s responsible for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Scanning, orchestrating, and executing ChangeUnits at application startup (or on-demand)"}),"\n",(0,t.jsx)(n.li,{children:"Coordinating interactions with the Audit Store (via its Driver)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It can be embedded in your application or run as an independent service in distributed environments."}),"\n",(0,t.jsx)(n.h3,{id:"-driver",children:"\ud83d\udd0c Driver"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"Driver"})," acts as an adapter between Flamingock and the Audit Store. It manages all low-level interactions required for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Writing audit-log entries when a ChangeUnit runs"}),"\n",(0,t.jsx)(n.li,{children:"Acquiring and releasing distributed locks"}),"\n",(0,t.jsx)(n.li,{children:"Querying execution history to prevent duplicate runs"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Depending on the edition, the Driver may connect to a user-provided database (CE) or Flamingock\u2019s cloud backend (Cloud Edition). It does ",(0,t.jsx)(n.em,{children:"not"})," perform any Target System changes\u2014that responsibility lies fully with the ChangeUnit code."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-transaction-handling",children:"\ud83d\udd01 Transaction handling"}),"\n",(0,t.jsxs)(n.p,{children:["Flamingock supports ",(0,t.jsx)(n.strong,{children:"transactional consistency"})," where possible:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"When the target System is also a database supporting ACID transactions"})," (like MongoDB), Flamingock ensures that a ChangeUnit\u2019s operation on the target System and its audit-log insert into the Audit Store commit together as a single transaction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"When the target System does not support transactions"})," (e.g., HTTP APIs, file systems, or message brokers), Flamingock uses compensating actions (rollbacks) and auditing to maintain integrity."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For a deeper dive around Transactions, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/flamingock-library-config/transactions",children:"Transactions"})," section."]}),"\n",(0,t.jsx)(n.h3,{id:"-rollbacks",children:"\ud83d\udd19 Rollbacks"}),"\n",(0,t.jsx)(n.p,{children:"Each ChangeUnit can define rollback logic:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For safe reversion when operating against non-transactional systems"}),"\n",(0,t.jsx)(n.li,{children:'For reverting to a previous version of the software ("Undo"), invoked via the CLI'}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-templates",children:"\ud83e\udde9 Templates"}),"\n",(0,t.jsxs)(n.p,{children:["Flamingock introduces ",(0,t.jsx)(n.strong,{children:"change templates"})," for low-code use cases. These are YAML or JSON-based definitions that let teams describe changes declaratively\u2014especially useful for configuration changes and SaaS integrations."]}),"\n",(0,t.jsx)(n.p,{children:"Templates are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Extensible and version-controlled"}),"\n",(0,t.jsx)(n.li,{children:"Friendly to non-developer users"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For a deeper dive around Templates, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/templates/templates-introduction",children:"Templates"})," section."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-workflows",children:"\ud83d\udd04 Workflows"}),"\n",(0,t.jsx)(n.p,{children:"Workflows group and coordinate multiple ChangeUnits into stages. In future releases, they will support:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sequential"})," or ",(0,t.jsx)(n.strong,{children:"parallel"})," execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Conditional branching"})," (e.g., only run if a previous unit succeeded)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This will enable advanced orchestration logic during deployments or upgrades."}),"\n",(0,t.jsxs)(n.p,{children:["For a deeper dive around Workflows, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/flamingock-library-config/setup-and-stages",children:"Pipelines and stages"})," section."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-distributed-locking",children:"\ud83d\udd12 Distributed Locking"}),"\n",(0,t.jsx)(n.p,{children:"To ensure safe execution in multi-instance deployments, Flamingock uses a distributed lock mechanism. This guarantees:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Avoidance of duplicate execution or race conditions"}),"\n",(0,t.jsx)(n.li,{children:"Synchronisation between multiple runners"}),"\n",(0,t.jsx)(n.li,{children:"Coordination across microservices in distributed environments"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It supports multiple lock implementations (e.g., MongoDB, Redis, DynamoDB)."}),"\n",(0,t.jsxs)(n.p,{children:["For a deeper dive around distributed locks, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/flamingock-library-config/lock-configuration",children:"Distributed locking"})," section."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-events",children:"\ud83d\udce3 Events"}),"\n",(0,t.jsx)(n.p,{children:"Flamingock is able to notify your Application around the execution status of changes via Events."}),"\n",(0,t.jsxs)(n.p,{children:["For a deeper dive around Events, see the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/flamingock-library-config/events",children:"Events"})," section."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);