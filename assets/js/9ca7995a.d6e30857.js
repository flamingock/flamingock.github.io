"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[2987],{415:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"testing/integration-testing","title":"Integration testing","description":"Introduction","source":"@site/docs/testing/integration-testing.md","sourceDirName":"testing","slug":"/testing/integration-testing","permalink":"/testing/integration-testing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Integration testing","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Flamingock BDD API","permalink":"/testing/flamingock-bdd-api"},"next":{"title":"Spring Boot testing","permalink":"/testing/springboot-integration-testing"}}');var i=t(4848),r=t(8453),s=t(1470),o=t(9365);const l={title:"Integration testing",sidebar_position:3},c=void 0,u={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Setup",id:"setup",level:2},{value:"FlamingockTestSupport",id:"flamingocktestsupport",level:2},{value:"Alternative: in-memory testing",id:"alternative-in-memory-testing",level:2},{value:"InMemoryFlamingockBuilder",id:"inmemoryflamingockbuilder",level:3},{value:"InMemoryAuditStore",id:"inmemoryauditstore",level:3},{value:"Complete example with Testcontainers",id:"complete-example-with-testcontainers",level:2},{value:"Best practices",id:"best-practices",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["Integration tests verify that Flamingock executes changes correctly against real systems. The ",(0,i.jsx)(n.code,{children:"flamingock-test-support"})," module provides a BDD-style API for writing expressive, maintainable integration tests."]}),"\n",(0,i.jsxs)(n.p,{children:["The recommended approach is to use your ",(0,i.jsx)(n.strong,{children:"production Flamingock builder"})," with containerized backends (via Testcontainers), ensuring your tests match real-world behavior."]}),"\n",(0,i.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,i.jsxs)(s.A,{groupId:"gradle_maven",children:[(0,i.jsx)(o.A,{value:"gradle",label:"Gradle",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'testImplementation("io.flamingock:flamingock-test-support:$version")\n'})})}),(0,i.jsx)(o.A,{value:"maven",label:"Maven",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>io.flamingock</groupId>\n    <artifactId>flamingock-test-support</artifactId>\n    <version>${flamingock.version}</version>\n    <scope>test</scope>\n</dependency>\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"flamingocktestsupport",children:"FlamingockTestSupport"}),"\n",(0,i.jsxs)(n.p,{children:["The entry point for standalone integration tests. Use ",(0,i.jsx)(n.code,{children:"givenBuilder()"})," to pass your configured Flamingock builder:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"FlamingockTestSupport\n    .givenBuilder(builder)      // Your production builder\n    .andExistingAudit(...)      // Optional: set up existing audit state\n    .whenRun()                  // Trigger execution\n    .thenExpectAuditFinalStateSequence(...)  // Define expectations\n    .verify();                  // Execute and validate\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/testing/flamingock-bdd-api",children:"BDD test API"})," for details on ",(0,i.jsx)(n.code,{children:"andExistingAudit()"}),", validators, and ",(0,i.jsx)(n.code,{children:"AuditEntryDefinition"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"alternative-in-memory-testing",children:"Alternative: in-memory testing"}),"\n",(0,i.jsx)(n.p,{children:"For faster tests where audit store persistence doesn't matter, you can use the in-memory components:"}),"\n",(0,i.jsx)(n.h3,{id:"inmemoryflamingockbuilder",children:"InMemoryFlamingockBuilder"}),"\n",(0,i.jsx)(n.p,{children:"Creates a pre-configured builder with an in-memory audit store:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import io.flamingock.support.InMemoryFlamingockBuilder;\n\n@Test\nvoid fastTestWithInMemoryAudit() {\n    var builder = InMemoryFlamingockBuilder.create()\n            .addTargetSystem(new NonTransactionalTargetSystem("kafka").addDependency(kafkaClient))\n            .addStage(new Stage("kafka-changes").addCodePackage("com.myapp.changes.kafka"));\n\n    FlamingockTestSupport\n            .givenBuilder(builder)\n            .whenRun()\n            .thenExpectAuditFinalStateSequence(\n                    APPLIED(CreateTopicChange.class)\n            )\n            .verify();\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"inmemoryauditstore",children:"InMemoryAuditStore"}),"\n",(0,i.jsx)(n.p,{children:"You can also use your production builder configured with all target systems, stages, and dependencies, and just override the audit store. This lets you test with your exact production configuration without needing a real audit store backend:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import io.flamingock.support.InMemoryAuditStore;\n\n@Test\nvoid reuseProductionBuilderWithInMemoryAudit() {\n    // Retrieve your production builder (already configured with target systems, stages, etc.)\n    var builder = MyAppFlamingockConfig.createBuilder();\n\n    FlamingockTestSupport\n            .givenBuilder(builder)\n            .andOverrideAuditStore(InMemoryAuditStore.create())// Override only the audit store for testing\n            .whenRun()\n            .thenExpectAuditFinalStateSequence(APPLIED(MyChange.class))\n            .verify();\n}\n"})}),"\n",(0,i.jsxs)(n.admonition,{title:"When to use in-memory",type:"tip",children:[(0,i.jsx)(n.p,{children:"Use in-memory components when:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You want faster test execution"}),"\n",(0,i.jsx)(n.li,{children:"The audit store behavior is not relevant to the test"}),"\n",(0,i.jsx)(n.li,{children:"You're testing target system interactions only"}),"\n"]}),(0,i.jsx)(n.p,{children:"Use Testcontainers when:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You need to verify audit persistence behavior"}),"\n",(0,i.jsx)(n.li,{children:"You want tests that match production exactly"}),"\n",(0,i.jsx)(n.li,{children:"You're testing recovery or idempotency scenarios"}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"complete-example-with-testcontainers",children:"Complete example with Testcontainers"}),"\n",(0,i.jsx)(n.p,{children:"This example tests a change that creates an S3 bucket, using MongoDB as the audit store:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'//other imports\nimport io.flamingock.core.Flamingock;\nimport io.flamingock.support.FlamingockTestSupport;\nimport io.flamingock.targetsystem.nontransactional.NonTransactionalTargetSystem;\nimport static io.flamingock.support.domain.AuditEntryDefinition.*;\n\n@Testcontainers\nclass S3IntegrationTest {\n\n    @Container\n    static final MongoDBContainer mongoContainer = new MongoDBContainer("mongo:6.0");\n\n    @Container\n    static final LocalStackContainer localstack = new LocalStackContainer(\n            DockerImageName.parse("localstack/localstack:latest"))\n            .withServices(LocalStackContainer.Service.S3);\n\n    private S3Client s3Client;\n    private MongoClient mongoClient;\n\n    @BeforeAll\n    void setup() {\n        // Configure S3 client (target system)\n        s3Client = S3Client.builder()\n                .endpointOverride(localstack.getEndpointOverride(LocalStackContainer.Service.S3))\n                .credentialsProvider(StaticCredentialsProvider.create(\n                        AwsBasicCredentials.create(\n                                localstack.getAccessKey(),\n                                localstack.getSecretKey())))\n                .region(Region.US_EAST_1)\n                .build();\n\n        // Configure MongoDB client (audit store)\n        mongoClient = MongoClients.create(mongoContainer.getReplicaSetUrl());\n    }\n\n    @Test\n    void shouldExecuteS3BucketCreation() {\n        // Configure target system with S3 client as dependency\n        NonTransactionalTargetSystem s3TargetSystem = new NonTransactionalTargetSystem("aws-s3")\n                .addDependency(s3Client);\n\n        // Build Flamingock with production configuration\n        var builder = Flamingock.builder()\n                .setAuditStore(new MongoDBSyncAuditStore(mongoClient, "flamingock-test-db"))\n                .addTargetSystem(s3TargetSystem)\n                .addStage(new Stage("s3-changes").addCodePackage("com.myapp.changes.s3"));\n\n        // Test using BDD API\n        FlamingockTestSupport\n                .givenBuilder(builder)\n                .whenRun()\n                .thenExpectAuditFinalStateSequence(\n                        APPLIED(CreateS3BucketChange.class)\n                )\n                .verify();\n\n        // Optionally verify the actual target system state\n        boolean bucketExists = s3Client.listBuckets().buckets().stream()\n                .anyMatch(b -> b.name().equals("flamingock-test-bucket"));\n        assertTrue(bucketExists, "S3 bucket was not created");\n    }\n\n    @Test\n    void shouldSkipAlreadyAppliedChanges() {\n        var builder = Flamingock.builder()\n                .setAuditStore(new MongoDBSyncAuditStore(mongoClient, "flamingock-test-db"))\n                .addTargetSystem(new NonTransactionalTargetSystem("aws-s3").addDependency(s3Client))\n                .addStage(new Stage("s3-changes").addCodePackage("com.myapp.changes.s3"));\n\n        FlamingockTestSupport\n                .givenBuilder(builder)\n                .andExistingAudit(\n                        APPLIED(CreateS3BucketChange.class)  // Simulate already applied\n                )\n                .whenRun()\n                .thenExpectAuditFinalStateSequence(\n                        APPLIED(CreateS3BucketChange.class)  // Should remain unchanged\n                )\n                .verify();\n    }\n\n    @Test\n    void shouldHandleFailureWithRollback() {\n        var builder = Flamingock.builder()\n                .setAuditStore(new MongoDBSyncAuditStore(mongoClient, "flamingock-test-db"))\n                .addTargetSystem(new NonTransactionalTargetSystem("aws-s3").addDependency(s3Client))\n                .addStage(new Stage("failing-changes").addCodePackage("com.myapp.changes.failing"));\n\n        FlamingockTestSupport\n                .givenBuilder(builder)\n                .whenRun()\n                .thenExpectException(PipelineExecutionException.class, ex -> {\n                    assertTrue(ex.getMessage().contains("Intentional failure"));\n                })\n                .andExpectAuditFinalStateSequence(\n                        FAILED(FailingChange.class),\n                        ROLLED_BACK(FailingChange.class)\n                )\n                .verify();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use your production builder"})," \u2014 configure Flamingock the same way you do in production, but point to containerized backends"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Testcontainers"})," \u2014 provides realistic, isolated test environments for both target systems and audit stores"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test failure scenarios"})," \u2014 verify that rollback behavior works correctly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test idempotency"})," \u2014 use ",(0,i.jsx)(n.code,{children:"andExistingAudit()"})," to simulate re-runs and verify changes are skipped appropriately"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Verify target system state"})," \u2014 optionally check that the actual target system received the expected changes"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}},1470:(e,n,t)=>{t.d(n,{A:()=>j});var a=t(6540),i=t(4164),r=t(7559),s=t(3104),o=t(6347),l=t(205),c=t(7485),u=t(1682),d=t(679);function g(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return g(e).map(({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a}))}(t);return function(e){const n=(0,u.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function h({queryString:e=!1,groupId:n}){const t=(0,o.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(i),(0,a.useCallback)(e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})},[i,t])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,r=p(e),[s,o]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r})),[c,u]=h({queryString:t,groupId:i}),[g,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,d.Dv)(n);return[t,(0,a.useCallback)(e=>{n&&i.set(e)},[n,i])]}({groupId:i}),v=(()=>{const e=c??g;return m({value:e,tabValues:r})?e:null})();(0,l.A)(()=>{v&&o(v)},[v]);return{selectedValue:s,selectValue:(0,a.useCallback)(e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),f(e)},[u,f,r]),tabValues:r}}var v=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(4848);function x({className:e,block:n,selectedValue:t,selectValue:a,tabValues:r}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),c=e=>{const n=e.currentTarget,i=o.indexOf(n),s=r[i].value;s!==t&&(l(n),a(s))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},e),children:r.map(({value:e,label:n,attributes:a})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:u,onClick:c,...a,className:(0,i.A)("tabs__item",y.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function k({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function S(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,i.A)(r.G.tabs.container,"tabs-container",y.tabList),children:[(0,b.jsx)(x,{...n,...e}),(0,b.jsx)(k,{...n,...e})]})}function j(e){const n=(0,v.A)();return(0,b.jsx)(S,{...e,children:g(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var a=t(4164);const i={tabItem:"tabItem_Ymn6"};var r=t(4848);function s({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)(i.tabItem,t),hidden:n,children:e})}}}]);