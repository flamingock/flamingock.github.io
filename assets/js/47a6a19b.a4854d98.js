"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[7686],{417:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"changes/domain-coupling","title":"Domain Coupling","description":"Why this matters","source":"@site/docs/changes/domain-coupling.md","sourceDirName":"changes","slug":"/changes/domain-coupling","permalink":"/docs/changes/domain-coupling","draft":false,"unlisted":false,"editUrl":"https://github.com/flamingock/flamingock-java/docs/changes/domain-coupling.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Domain Coupling","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Best Practices","permalink":"/docs/changes/best-practices"},"next":{"title":"Introduction","permalink":"/docs/target-systems/introduction"}}');var t=n(4848),r=n(8453);const a={title:"Domain Coupling",sidebar_position:7},l="Domain Coupling and Historical Immutability",o={},c=[{value:"Why this matters",id:"why-this-matters",level:2},{value:"The coupling problem",id:"the-coupling-problem",level:2},{value:"A practical example",id:"a-practical-example",level:3},{value:"The solution: Generic structures",id:"the-solution-generic-structures",level:2},{value:"When you need reusable logic",id:"when-you-need-reusable-logic",level:2},{value:"Utility classes for Changes",id:"utility-classes-for-changes",level:3},{value:"SQL files or scripts",id:"sql-files-or-scripts",level:3},{value:"Best practices summary",id:"best-practices-summary",level:2},{value:"The balance",id:"the-balance",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"domain-coupling-and-historical-immutability",children:"Domain Coupling and Historical Immutability"})}),"\n",(0,t.jsx)(s.h2,{id:"why-this-matters",children:"Why this matters"}),"\n",(0,t.jsx)(s.p,{children:"Here's something that might surprise you: Changes that ran successfully in the past can break your build today. This happens when Changes depend on domain classes that evolve over time. Let's understand why this matters and how to keep your Changes stable."}),"\n",(0,t.jsx)(s.h2,{id:"the-coupling-problem",children:"The coupling problem"}),"\n",(0,t.jsxs)(s.p,{children:["Changes in Flamingock are meant to be ",(0,t.jsx)(s.strong,{children:"historically immutable"})," - they represent past changes that have been applied and audited. Their code should remain untouched over time to ensure:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Repeatability"}),": The same Change produces the same result"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Auditability"}),": Historical changes can be verified"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reliability"}),": Past Changes continue to work in new environments"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"However, when a Change depends on a domain class and that class evolves (fields removed, renamed, or restructured), your older Changes will no longer compile or run correctly."}),"\n",(0,t.jsx)(s.h3,{id:"a-practical-example",children:"A practical example"}),"\n",(0,t.jsxs)(s.p,{children:["Consider a PostgreSQL database with a ",(0,t.jsx)(s.code,{children:"customers"})," table. Initially, your domain model includes:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:"public class Customer {\n    private Long id;\n    private String firstName;\n    private String middleName;  // Will be removed later\n    private String lastName;\n    private String email;\n    // getters/setters...\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"You create a Change that uses this domain class:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:'@Change(id = "add-premium-customers", order = "20250923_01", author = "team")\npublic class _20250923_01_AddPremiumCustomers {\n\n    @Apply\n    public void apply(CustomerRepository repository) {\n        Customer customer = new Customer();\n        customer.setFirstName("John");\n        customer.setMiddleName("William");  // Uses the field\n        customer.setLastName("Smith");\n        customer.setEmail("john.smith@example.com");\n        repository.save(customer);\n    }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Six months later, your team decides ",(0,t.jsx)(s.code,{children:"middleName"})," is unnecessary and removes it from the ",(0,t.jsx)(s.code,{children:"Customer"})," class. Now:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"\u2705 Your application works fine with the updated model"}),"\n",(0,t.jsxs)(s.li,{children:["\u274c The Change ",(0,t.jsx)(s.code,{children:"_20250923_01_AddPremiumCustomers"})," no longer compiles"]}),"\n",(0,t.jsx)(s.li,{children:"\u274c You can't run Flamingock in new environments"}),"\n",(0,t.jsx)(s.li,{children:"\u274c CI/CD pipelines break"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"This breaks the principle of historical immutability and undermines Flamingock's reliability."}),"\n",(0,t.jsx)(s.h2,{id:"the-solution-generic-structures",children:"The solution: Generic structures"}),"\n",(0,t.jsx)(s.p,{children:"To ensure stability, avoid injecting domain classes or anything tightly coupled to your evolving business model. Instead, use schema-free or generic structures."}),"\n",(0,t.jsx)(s.p,{children:"Here's how the same Change looks using generic structures:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:'@Change(id = "add-premium-customers", order = "20250923_01", author = "team")\npublic class _20250923_01_AddPremiumCustomers {\n\n    @Apply\n    public void apply(RestTemplate restTemplate) {\n        // Using a Map instead of the Customer domain class\n        Map<String, Object> customerData = new HashMap<>();\n        customerData.put("firstName", "John");\n        customerData.put("middleName", "William");\n        customerData.put("lastName", "Smith");\n        customerData.put("email", "john.smith@example.com");\n        customerData.put("status", "PREMIUM");\n\n        // Send to customer service API\n        restTemplate.postForObject(\n            "/api/customers",\n            customerData,\n            Map.class\n        );\n    }\n\n    @Rollback\n    public void rollback(RestTemplate restTemplate) {\n        // Remove the customer using email as identifier\n        restTemplate.delete("/api/customers/john.smith@example.com");\n    }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["This Change remains stable even if the ",(0,t.jsx)(s.code,{children:"Customer"})," domain class evolves or the ",(0,t.jsx)(s.code,{children:"middleName"})," field is removed. The Map structure is decoupled from your domain model."]}),"\n",(0,t.jsx)(s.h2,{id:"when-you-need-reusable-logic",children:"When you need reusable logic"}),"\n",(0,t.jsx)(s.p,{children:"If you have complex logic that needs to be shared across Changes, consider these approaches:"}),"\n",(0,t.jsx)(s.h3,{id:"utility-classes-for-changes",children:"Utility classes for Changes"}),"\n",(0,t.jsx)(s.p,{children:"Create utilities specifically for your Changes that are isolated from your domain:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:'public class ChangeUtils {\n    public static Map<String, Object> createCustomerData(\n        String firstName, String lastName, String email) {\n        return Map.of(\n            "firstName", firstName,\n            "lastName", lastName,\n            "email", email,\n            "createdAt", Instant.now().toString()\n        );\n    }\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"sql-files-or-scripts",children:"SQL files or scripts"}),"\n",(0,t.jsx)(s.p,{children:"For complex SQL operations, consider external scripts:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:'@Apply\npublic void apply(JdbcTemplate jdbc) throws IOException {\n    String sql = Files.readString(\n        Paths.get("changes/sql/001_create_premium_customers.sql")\n    );\n    jdbc.execute(sql);\n}\n'})}),"\n",(0,t.jsx)(s.h2,{id:"best-practices-summary",children:"Best practices summary"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Treat Changes as historical artifacts"})," - They are versioned records of the past, not part of your live business logic"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Use generic structures"})," - Maps, Documents, ResultSets, or direct queries instead of domain objects"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Keep Changes self-contained"})," - Minimize dependencies on external classes that might change"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Test with evolution in mind"})," - Ensure your Changes compile and run even as your domain evolves"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Document data structures"})," - When using generic structures, add comments explaining the expected schema"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"the-balance",children:"The balance"}),"\n",(0,t.jsx)(s.p,{children:"We're not suggesting you should never use any classes in your Changes. The key is understanding the trade-off:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Domain classes"}),": Type safety now, brittleness over time"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Generic structures"}),": Less type safety, long-term stability"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Choose based on your context, but be aware of the implications. For most production systems where Changes need to remain stable for years, generic structures are the safer choice."}),"\n",(0,t.jsx)(s.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Review existing Changes for domain coupling"}),"\n",(0,t.jsx)(s.li,{children:"Establish team conventions for Change implementations"}),"\n",(0,t.jsxs)(s.li,{children:["Consider using ",(0,t.jsx)(s.a,{href:"/docs/templates/templates-introduction",children:"Templates"})," for standardized, decoupled change patterns"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var i=n(6540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);