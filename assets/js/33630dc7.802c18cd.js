"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[4310],{486:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/Diagrams-TargetAndAuditStore.drawio-eda74901cbbf1c08dbbe3d4cccd64511.png"},5076:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"overview/audit-store-vs-target-system","title":"Audit store vs. target system","description":"In Flamingock, it is important to distinguish between two very different roles that external systems can play:","source":"@site/docs/overview/audit-store-vs-target-system.md","sourceDirName":"overview","slug":"/overview/audit-store-vs-target-system","permalink":"/docs/1.0.0/overview/audit-store-vs-target-system","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/overview/audit-store-vs-target-system.md","tags":[],"version":"current","sidebarPosition":100,"frontMatter":{"title":"Audit store vs. target system","sidebar_position":100},"sidebar":"tutorialSidebar","previous":{"title":"Flamingock Technical Overview","permalink":"/docs/1.0.0/overview/technical-overview"},"next":{"title":"Library Introduction","permalink":"/docs/1.0.0/flamingock-library-config/introduction"}}');var a=n(4848),s=n(8453);const r={title:"Audit store vs. target system",sidebar_position:100},o="Audit Store vs. Target System",c={},l=[{value:"Audit Store",id:"audit-store",level:2},{value:"Target System",id:"target-system",level:2},{value:"Why the distinction matters",id:"why-the-distinction-matters",level:2},{value:"Illustration",id:"illustration",level:3},{value:"Transactional target with Cloud as audit store (Cloud Edition)",id:"transactional-target-with-cloud-as-audit-store-cloud-edition",level:4},{value:"Target and audit store are the same transactional database",id:"target-and-audit-store-are-the-same-transactional-database",level:4},{value:"Non-transactional target with Cloud as audit store",id:"non-transactional-target-with-cloud-as-audit-store",level:4},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const t={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"audit-store-vs-target-system",children:"Audit Store vs. Target System"})}),"\n",(0,a.jsx)(t.p,{children:"In Flamingock, it is important to distinguish between two very different roles that external systems can play:"}),"\n",(0,a.jsx)(t.h2,{id:"audit-store",children:"Audit Store"}),"\n",(0,a.jsx)(t.p,{children:"The audit store is the dedicated persistence layer where Flamingock records metadata about each change unit\u2019s execution. Its sole purpose is to capture, in an append-only log, exactly which change units ran, when they ran, who initiated them, and whether they succeeded or failed (along with any error details). This information is used to:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Prevent duplicate applications"}),(0,a.jsx)(t.br,{}),"\n","By checking the audit store before running a change unit, Flamingock guarantees each change is executed at most once."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Track change history"}),(0,a.jsx)(t.br,{}),"\n","You can query the audit store to see all previously applied changes, filter by author or date range, and generate reports."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Coordinate distributed execution"}),(0,a.jsx)(t.br,{}),"\n","In a clustered environment, Flamingock nodes consult the audit store to decide which change units still need to run\u2014and to know which locks are held."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Drive rollbacks and \u201cundo\u201d operations"}),(0,a.jsx)(t.br,{}),"\n","Since each audit entry captures rollback availability, Flamingock can navigate backward through the audit store to revert a series of changes in reverse order."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Depending on your setup, the audit store may be:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"A user-provided database (for Community Edition). For example, if you run CE with MongoDB, Flamingock writes audit records into a MongoDB collection."}),"\n",(0,a.jsx)(t.li,{children:"Flamingock\u2019s own cloud backend (for Cloud Edition). In that case, the audit store is a managed that you never host yourself."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In summary, the audit store exists solely to record what happened\u2014and to ensure consistency and idempotency across deployments."}),"\n",(0,a.jsx)(t.h2,{id:"target-system",children:"Target System"}),"\n",(0,a.jsxs)(t.p,{children:["A target system is any external resource or service upon which a change unit\u2019s logic operates. When you write a change unit, you define ",(0,a.jsx)(t.code,{children:"@Execution"})," and ",(0,a.jsx)(t.code,{children:"@RollbackExecution"})," methods that perform actions against a target system\u2014such as:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"A cloud service (e.g., creating an S3 bucket or configuring a CloudFormation stack)"}),"\n",(0,a.jsx)(t.li,{children:"A messaging backbone (e.g., creating a new Kafka topic, configuring permissions, or updating an existing schema)"}),"\n",(0,a.jsx)(t.li,{children:"A configuration service (e.g., updating a feature-flag in Consul or Vault)"}),"\n",(0,a.jsx)(t.li,{children:"A database schema (e.g., creating a new column in your relational database)"}),"\n",(0,a.jsx)(t.li,{children:"A NoSQL data store (e.g., creating a new collection or index in MongoDB)"}),"\n",(0,a.jsx)(t.li,{children:"Even another microservice\u2019s REST API"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The key point is that the target system is where changes must actually be applied\u2014and those changes must occur exactly once (or be rolled back) to keep your application and its ecosystem in sync. Flamingock orchestrates these operations in a deterministic, ordered fashion, but the target system itself is whatever resource or service your change unit code touches."}),"\n",(0,a.jsx)(t.h2,{id:"why-the-distinction-matters",children:"Why the distinction matters"}),"\n",(0,a.jsx)(t.p,{children:"Because Flamingock originated from Mongock (which treated the database both as audit store and change target), it\u2019s common to conflate these two roles. In practice:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"In Cloud Edition with distributed transaction protocol (for a transactionally-capable target like an RDBMS)"}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Flamingock writes a small \u201cintent\u201d or \u201cflag\u201d record in your own database before it writes the audit entry to the cloud store."}),"\n",(0,a.jsx)(t.li,{children:"After successfully committing your database change, Flamingock finalizes the audit record in the cloud. If anything fails at any step, Flamingock can roll everything back or clean up partial intent entries. This protocol ensures that, even though the audit store lives in the cloud, your RDBMS change and the audit record remain effectively atomic from Flamingock\u2019s perspective."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"When a relational or NoSQL database serves as both audit store and change target"})," (for example, CE running on MongoDB):"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Flamingock writes an audit-entry document into the same database where your data resides."}),"\n",(0,a.jsx)(t.li,{children:"For DML or DDL change units that modify that same database, Flamingock can wrap both the change and the audit insert in a single transaction\u2014ensuring \u201call-or-nothing\u201d consistency."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"When the change target is a different system"})," (for example, creating S3 buckets or updating Kafka topics):"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The audit store remains your chosen audit database or Flamingock\u2019s cloud backend."}),"\n",(0,a.jsx)(t.li,{children:"Flamingock cannot wrap, say, an S3 API call and the audit insert inside a single transaction, because those systems do not share a common transaction coordinator."}),"\n",(0,a.jsxs)(t.li,{children:["Instead, Flamingock\u2019s audit store logs the change unit as \u201cexecuted\u201d only after your ",(0,a.jsx)(t.code,{children:"@Execution"})," method completes without error; if that ",(0,a.jsx)(t.code,{children:"@Execution"})," code fails, Flamingock calls your ",(0,a.jsx)(t.code,{children:"@RollbackExecution"}),". The audit store entry is only written once you confirm the change succeeded."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Audit store",src:n(486).A+"",width:"725",height:"326"})}),"\n",(0,a.jsx)(t.h3,{id:"illustration",children:"Illustration"}),"\n",(0,a.jsx)(t.h4,{id:"transactional-target-with-cloud-as-audit-store-cloud-edition",children:"Transactional target with Cloud as audit store (Cloud Edition)"}),"\n",(0,a.jsxs)(t.p,{children:["\ud83d\udcc4 ",(0,a.jsx)(t.strong,{children:"_0001_CreateUserTableChange"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Targets:"})," Transactional database (e.g., PostgreSQL)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Audit store:"})," Flamingock Cloud (Cloud Edition)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Transactional behavior:"})," Uses Flamingock\u2019s distributed transaction protocol to guarantee atomicity between the RDBMS and the cloud audit store, achieving the same effect as a traditional transaction."]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"target-and-audit-store-are-the-same-transactional-database",children:"Target and audit store are the same transactional database"}),"\n",(0,a.jsxs)(t.p,{children:["\ud83d\udcc4 ",(0,a.jsx)(t.strong,{children:"_0002_CreateUserTableChange"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Targets:"})," Transactional database (e.g., MongoDB)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Audit store:"})," Same MongoDB instance (Community Edition)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Transactional behavior:"})," Wrapped in a single DB transaction\u2014so both the schema change (or data change) and the audit insert happen or fail together."]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"non-transactional-target-with-cloud-as-audit-store",children:"Non-transactional target with Cloud as audit store"}),"\n",(0,a.jsxs)(t.p,{children:["\ud83d\udcc4 ",(0,a.jsx)(t.strong,{children:"_0003_ConfigureS3BucketChange"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Targets:"})," Amazon S3 (creating a bucket)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Audit store:"})," Flamingock Cloud (Cloud Edition)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Transactional behavior:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Flamingock calls S3\u2019s ",(0,a.jsx)(t.code,{children:"createBucket"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["If that succeeds, Flamingock writes an audit entry to the ",(0,a.jsx)(t.strong,{children:"cloud"})," audit store."]}),"\n",(0,a.jsxs)(t.li,{children:["If the S3 call fails, Flamingock invokes your ",(0,a.jsx)(t.code,{children:"@RollbackExecution"})," (deleting or cleaning up) and then writes an audit entry marking the change as \u201crolled back.\u201d"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"All change units within a single application must use the same audit store. You cannot mix multiple audit backends in the same application."})}),"\n",(0,a.jsx)(t.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Audit Store"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Record of \u201cwhat ran when and by whom\u201d"}),"\n",(0,a.jsx)(t.li,{children:"Used to prevent duplicates, drive rollbacks, and coordinate distributed execution"}),"\n",(0,a.jsx)(t.li,{children:"Hosted in Flamingock\u2019s cloud backend (Cloud Edition) or your chosen database (CE)"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Target System"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The actual resource being modified (S3 buckets, Kafka topics, database tables, config services, and so on)"}),"\n",(0,a.jsx)(t.li,{children:"Change units call external APIs or drivers against this system"}),"\n",(0,a.jsx)(t.li,{children:"May or may not support transactions; if it does, Flamingock can co-ordinate with the audit store (via Cloud\u2019s distributed protocol or CE\u2019s DB transaction)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:"Distinguishing these two roles makes it clear that Flamingock\u2019s core value lies in coordinating audit and execution\u2014across arbitrary target systems\u2014rather than assuming both duties are performed by the same database. This clarity ensures you can design your change units and architecture with the proper expectations around consistency, rollback, and idempotency."})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);