"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[5525],{2907:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"flamingock-library-config/changeunit-dependency-injection","title":"ChangeUnit dependency injection","description":"Flamingock allows you to inject dependencies into your change units so they can use services, clients, or utilities during execution. This is especially useful for standalone applications, where no dependency injection framework (like Spring) is present.","source":"@site/docs/flamingock-library-config/changeunit-dependency-injection.md","sourceDirName":"flamingock-library-config","slug":"/flamingock-library-config/changeunit-dependency-injection","permalink":"/docs/1.0.0/flamingock-library-config/changeunit-dependency-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/flamingock-library-config/changeunit-dependency-injection.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"ChangeUnit dependency injection","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"ChangeUnits Deep Dive","permalink":"/docs/1.0.0/flamingock-library-config/changeunits-deep-dive"},"next":{"title":"Platform component injection","permalink":"/docs/1.0.0/flamingock-library-config/platform-component-injection"}}');var c=i(4848),r=i(8453);const s={title:"ChangeUnit dependency injection",sidebar_position:4},o=void 0,l={},d=[{value:"Registering dependencies",id:"registering-dependencies",level:2},{value:"Using name and explicit type",id:"using-name-and-explicit-type",level:3},{value:"Named dependency",id:"named-dependency",level:4},{value:"Explicit typing the dependency",id:"explicit-typing-the-dependency",level:4},{value:"Injection targets",id:"injection-targets",level:2},{value:"Method injection",id:"method-injection",level:3},{value:"Constructor injection",id:"constructor-injection",level:3},{value:"What happens if a dependency isn\u2019t found?",id:"what-happens-if-a-dependency-isnt-found",level:2},{value:"Skipping lock verification",id:"skipping-lock-verification",level:2},{value:"\u2705 Best practices",id:"white_check_mark-best-practices",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.p,{children:["Flamingock allows you to inject dependencies into your change units so they can use services, clients, or utilities during execution. This is especially useful for ",(0,c.jsx)(n.strong,{children:"standalone applications"}),", where no dependency injection framework (like Spring) is present."]}),"\n",(0,c.jsxs)(n.p,{children:["If you're using ",(0,c.jsx)(n.strong,{children:"Spring Boot"}),", Flamingock can integrate with the Spring context to resolve dependencies automatically \u2014 Please refer to the ",(0,c.jsx)(n.a,{href:"/docs/1.0.0/frameworks/springboot-integration/introduction",children:"Spring Boot Integration"})," section for details."]}),"\n",(0,c.jsxs)(n.p,{children:["This injection is handled via the ",(0,c.jsx)(n.strong,{children:"Flamingock builder"})," \u2014 not via YAML \u2014 and supports:"]}),"\n",(0,c.jsxs)(n.table,{children:[(0,c.jsx)(n.thead,{children:(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.th,{children:"Feature"}),(0,c.jsx)(n.th,{style:{textAlign:"center"},children:"Supported?"})]})}),(0,c.jsxs)(n.tbody,{children:[(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Injection by type"}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Injection by name"}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Constructor-level injection"}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsxs)(n.td,{children:["Method-level injection(",(0,c.jsx)(n.code,{children:"@Execution"}),", ",(0,c.jsx)(n.code,{children:"@RollbackExecution"}),")"]}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Nullable parameters"}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Lock-safe proxying"}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsxs)(n.td,{children:["Opt-out via ",(0,c.jsx)(n.code,{children:"@NonLockGuarded"})," for non-critical components"]}),(0,c.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]})]})]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"registering-dependencies",children:"Registering dependencies"}),"\n",(0,c.jsxs)(n.p,{children:["Platform changeUnit dependencies  are registered using the method ",(0,c.jsx)(n.code,{children:"addDependency(...)"})," :"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"builder\n  .addDependency(clientService);                         \n"})}),"\n",(0,c.jsx)(n.p,{children:"Once registered, Flamingock can inject the requested dependency into your change unit methods or constructors."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"@Execution\npublic void execute(ClientService clientService) {\n    // ChangeUnit's logic\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"using-name-and-explicit-type",children:"Using name and explicit type"}),"\n",(0,c.jsxs)(n.p,{children:["Let\u2019s say you have a base class ",(0,c.jsx)(n.code,{children:"PaymentProcessor"}),", with two implementations: ",(0,c.jsx)(n.code,{children:"StripePaymentProcessor"})," and ",(0,c.jsx)(n.code,{children:"PaypalPaymentProcessor"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"Now imagine you're injecting both implementations like this:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"addDependency(new StripePaymentProcessor());\naddDependency(new PaypalPaymentProcessor());\n"})}),"\n",(0,c.jsxs)(n.p,{children:["If a change unit method requests either ",(0,c.jsx)(n.code,{children:"StripePaymentProcessor"})," or ",(0,c.jsx)(n.code,{children:"PaypalPaymentProcessor"})," specifically, Flamingock will inject the correct one."]}),"\n",(0,c.jsxs)(n.p,{children:["But if the method requests the general type ",(0,c.jsx)(n.code,{children:"PaymentProcessor"}),", Flamingock cannot guarantee which of the two will be used."]}),"\n",(0,c.jsx)(n.p,{children:"To solve this, Flamingock provides two mechanisms:"}),"\n",(0,c.jsx)(n.h4,{id:"named-dependency",children:"Named dependency"}),"\n",(0,c.jsx)(n.p,{children:"You can register each implementation with a name:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:'builder\n  .addDependency("stripe", new StripePaymentProcessor())\n  .addDependency("paypal", new PaypalPaymentProcessor());\n'})}),"\n",(0,c.jsxs)(n.p,{children:["Then use the ",(0,c.jsx)(n.code,{children:"javax.inject.@Named"})," annotation in your method:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:'@Execution\npublic void execute(@Named("stripe") PaymentProcessor processor) {\n  processor.charge(...);\n}\n'})}),"\n",(0,c.jsx)(n.h4,{id:"explicit-typing-the-dependency",children:"Explicit typing the dependency"}),"\n",(0,c.jsx)(n.p,{children:"Alternatively, you can register a specific instance for the general type, to ensure the right one is used by default:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"builder.addDependency(PaymentProcessor.class, new StripePaymentProcessor());\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Now, any method requesting a ",(0,c.jsx)(n.code,{children:"PaymentProcessor"})," will receive the Stripe implementation \u2014 unless a named one is requested instead."]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"injection-targets",children:"Injection targets"}),"\n",(0,c.jsx)(n.h3,{id:"method-injection",children:"Method injection"}),"\n",(0,c.jsxs)(n.p,{children:["You can declare dependencies as parameters of ",(0,c.jsx)(n.code,{children:"@Execution"}),", ",(0,c.jsx)(n.code,{children:"@RollbackExecution"}),", etc."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"@Execution\npublic void run(ClientService clientService) {\n  clientService.doSomething();\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"constructor-injection",children:"Constructor injection"}),"\n",(0,c.jsx)(n.p,{children:"You can inject dependencies through constructors:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"public class CreateClientsTable {\n\n  private final ClientService clientService;\n\n  @FlamingockConstructor\n  public CreateClientsTable(ClientService clientService) {\n    this.clientService = clientService;\n  }\n\n  @Execution\n  public void run() {\n    clientService.doSomething();\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.admonition,{type:"note",children:[(0,c.jsx)(n.mdxAdmonitionTitle,{}),(0,c.jsxs)(n.p,{children:["If the class has only one constructor, the ",(0,c.jsx)(n.code,{children:"@FlamingockConstructor"})," annotation is optional."]})]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"what-happens-if-a-dependency-isnt-found",children:"What happens if a dependency isn\u2019t found?"}),"\n",(0,c.jsx)(n.p,{children:"By default, Flamingock will throw a clear exception if it cannot resolve a dependency."}),"\n",(0,c.jsxs)(n.p,{children:["You can override this by marking the parameter as ",(0,c.jsx)(n.code,{children:"@Nullable"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:'import io.flamingock.core.api.annotations.Nullable;\n\n@Execution\npublic void run(@Nullable OptionalLogger logger) {\n  if (logger != null) {\n    logger.log("Change started");\n  }\n}\n'})}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"skipping-lock-verification",children:"Skipping lock verification"}),"\n",(0,c.jsxs)(n.p,{children:["By default, injected dependencies are ",(0,c.jsx)(n.strong,{children:"proxy-wrapped"})," to check that the lock is still held before each call \u2014 this prevents unsafe execution if the lock expires."]}),"\n",(0,c.jsx)(n.p,{children:"If you're injecting something that doesn't perform critical side effects (like a local list or utility), you can opt out of this check:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-java",children:"@Execution\npublic void run(@NonLockGuarded SomeHelper helper) {\n  helper.doLocalStuff();\n}\n"})}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h2,{id:"white_check_mark-best-practices",children:["\u2705"," Best practices"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Only inject what you need for the current change unit"}),"\n",(0,c.jsx)(n.li,{children:"Prefer constructor injection when dependencies are shared across multiple methods"}),"\n",(0,c.jsxs)(n.li,{children:["Use ",(0,c.jsx)(n.code,{children:"@NonLockGuarded"})," only when you're certain no side effects are involved"]}),"\n",(0,c.jsx)(n.li,{children:"Document your dependencies to avoid confusion in large pipelines"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const c={},r=t.createContext(c);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);