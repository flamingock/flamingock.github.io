"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[6548],{3258:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"flamingock-library-config/target-system-configuration","title":"Target System Configuration","description":"Target systems are the real-world systems where your business changes are applied.","source":"@site/docs/flamingock-library-config/target-system-configuration.md","sourceDirName":"flamingock-library-config","slug":"/flamingock-library-config/target-system-configuration","permalink":"/docs/flamingock-library-config/target-system-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/flamingock-library-config/target-system-configuration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Target System Configuration","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Platform component injection","permalink":"/docs/flamingock-library-config/platform-component-injection"},"next":{"title":"Audit Store Configuration","permalink":"/docs/flamingock-library-config/audit-store-configuration"}}');var i=t(4848),a=t(8453);const r={title:"Target System Configuration",sidebar_position:4},o="Target System Configuration",l={},c=[{value:"Why target systems matter",id:"why-target-systems-matter",level:2},{value:"Explicit ownership",id:"explicit-ownership",level:3},{value:"Transactionality awareness",id:"transactionality-awareness",level:3},{value:"Dependency injection",id:"dependency-injection",level:3},{value:"Registering target systems",id:"registering-target-systems",level:2},{value:"Spring Boot Integration",id:"spring-boot-integration",level:3},{value:"Linking ChangeUnits to target systems",id:"linking-changeunits-to-target-systems",level:2},{value:"Cloud Edition visibility",id:"cloud-edition-visibility",level:2},{value:"Best practices",id:"best-practices",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"target-system-configuration",children:"Target System Configuration"})}),"\n",(0,i.jsxs)(n.p,{children:["Target systems are the real-world systems where your business changes are applied.",(0,i.jsx)(n.br,{}),"\n","They can be databases, message queues, storage buckets, APIs, or any external service your application depends on."]}),"\n",(0,i.jsx)(n.p,{children:"A ChangeUnit always declares which target system it belongs to. This ensures Flamingock can:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Track and audit changes per system"}),"\n",(0,i.jsx)(n.li,{children:"Guarantee safe execution across heterogeneous environments"}),"\n",(0,i.jsx)(n.li,{children:"Provide clear visibility (and, in the Cloud Edition, dashboards and filters per target system)"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Conceptual Overview"}),": For architectural understanding of target systems vs audit store, see ",(0,i.jsx)(n.a,{href:"/docs/overview/audit-store-vs-target-system",children:"Target Systems vs Audit Store"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"why-target-systems-matter",children:"Why target systems matter"}),"\n",(0,i.jsx)(n.h3,{id:"explicit-ownership",children:"Explicit ownership"}),"\n",(0,i.jsx)(n.p,{children:"Every change is tied to a named target system, avoiding ambiguity and enabling clear governance."}),"\n",(0,i.jsx)(n.h3,{id:"transactionality-awareness",children:"Transactionality awareness"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transactional target systems"})," (like PostgreSQL, MySQL, or MongoDB with transactions) allow Flamingock to use native rollback and guarantees."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-transactional systems"})," (like S3, Kafka, or REST APIs) are still safe, but Flamingock relies on rollback methods you provide."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This distinction is built into the target system definition."}),"\n",(0,i.jsx)(n.h3,{id:"dependency-injection",children:"Dependency injection"}),"\n",(0,i.jsxs)(n.p,{children:["Each target system can expose the dependencies required by its ChangeUnits.",(0,i.jsx)(n.br,{}),"\n","For example:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A MongoDB target system provides a ",(0,i.jsx)(n.code,{children:"MongoDatabase"})]}),"\n",(0,i.jsxs)(n.li,{children:["A Kafka target system provides a ",(0,i.jsx)(n.code,{children:"KafkaTemplate"})]}),"\n",(0,i.jsxs)(n.li,{children:["A SQL target system provides a ",(0,i.jsx)(n.code,{children:"Connection"})," or ",(0,i.jsx)(n.code,{children:"DataSource"})]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"ChangeUnits are not limited to target system dependencies. They can also request shared or application-level dependencies. Flamingock resolves them automatically, starting from the target system context and falling back to the general context."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"registering-target-systems",children:"Registering target systems"}),"\n",(0,i.jsxs)(n.p,{children:["Target systems are registered at runtime with the Flamingock builder.",(0,i.jsx)(n.br,{}),"\n","You can define and register as many as you need:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class App {\n  public static void main(String[] args) {\n    SqlTargetSystem mysql = new SqlTargetSystem("mysql-inventory")\n        .withDatasource(ds);\n\n    DefaultTargetSystem s3 = new DefaultTargetSystem("aws-s3");\n\n    DefaultTargetSystem kafka = new DefaultTargetSystem("kafka-stock");\n\n    FlamingockStandalone\n      .setAuditStore(new MongoSyncAuditStore(mongoClient, mongoDatabase))\n      .addTargetSystems(mysql, s3, kafka)\n      .build()\n      .run();\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"At startup, Flamingock automatically injects the right dependencies from the corresponding target system into each ChangeUnit."}),"\n",(0,i.jsx)(n.h3,{id:"spring-boot-integration",children:"Spring Boot Integration"}),"\n",(0,i.jsx)(n.p,{children:"For Spring Boot applications, target systems are configured as beans:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Bean\npublic SqlTargetSystem sqlTargetSystem(DataSource dataSource) {\n    return new SqlTargetSystem("mysql-inventory")\n        .withDatasource(dataSource);\n}\n\n@Bean  \npublic DefaultTargetSystem kafkaTargetSystem() {\n    return new DefaultTargetSystem("kafka-stock");\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Spring Boot's auto-configuration will automatically register these target systems with Flamingock."}),"\n",(0,i.jsxs)(n.p,{children:["For more details, see ",(0,i.jsx)(n.a,{href:"/docs/frameworks/springboot-integration/introduction",children:"Spring Boot Integration"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"linking-changeunits-to-target-systems",children:"Linking ChangeUnits to target systems"}),"\n",(0,i.jsxs)(n.p,{children:["When defining ChangeUnits, you specify which target system they belong to using the ",(0,i.jsx)(n.code,{children:"@TargetSystem"})," annotation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@TargetSystem("mysql-inventory")\n@ChangeUnit(id = "add-category", order = "001", author = "team")\npublic class _001_AddCategory {\n    //...\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"cloud-edition-visibility",children:"Cloud Edition visibility"}),"\n",(0,i.jsx)(n.p,{children:"In the Cloud Edition, target systems become a first-class part of the dashboard:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"See all changes grouped by target system"}),"\n",(0,i.jsx)(n.li,{children:"Filter execution history by system"}),"\n",(0,i.jsx)(n.li,{children:"Track failures and recoveries per system"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This makes it easier to govern and audit distributed environments at scale."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use descriptive names (",(0,i.jsx)(n.code,{children:"mysql-inventory"}),", ",(0,i.jsx)(n.code,{children:"aws-s3"}),", ",(0,i.jsx)(n.code,{children:"kafka-stock"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Be consistent across related ChangeUnits"}),"\n",(0,i.jsx)(n.li,{children:'Avoid generic names like "database" or "api"'}),"\n",(0,i.jsx)(n.li,{children:"Provide rollback logic for non-transactional systems"}),"\n",(0,i.jsx)(n.li,{children:"Keep dependencies scoped to the system they belong to \u2014 don\u2019t overload the general context when they are system-specific"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Takeaway"}),": Target systems provide the foundation for safe, auditable changes across your entire technology stack. By explicitly declaring and configuring them, you enable Flamingock to orchestrate complex distributed system evolution with confidence."]})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);