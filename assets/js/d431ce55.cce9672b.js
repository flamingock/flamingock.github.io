"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[817],{8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},9023:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"recovery-and-safety/recovery-strategies","title":"Recovery Strategies","description":"Intelligent failure handling for enterprise distributed systems","source":"@site/docs/recovery-and-safety/recovery-strategies.md","sourceDirName":"recovery-and-safety","slug":"/recovery-and-safety/recovery-strategies","permalink":"/docs/recovery-and-safety/recovery-strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/recovery-and-safety/recovery-strategies.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Recovery Strategies","sidebar_position":1}}');var r=i(4848),t=i(8453);const a={title:"Recovery Strategies",sidebar_position:1},o="Recovery Strategies",l={},c=[{value:"The Safety-First Philosophy",id:"the-safety-first-philosophy",level:2},{value:"Recovery Strategy Types",id:"recovery-strategy-types",level:2},{value:"MANUAL_INTERVENTION (Default)",id:"manual_intervention-default",level:3},{value:"ALWAYS_RETRY",id:"always_retry",level:3},{value:"Decision Framework",id:"decision-framework",level:2},{value:"Is Your Operation Idempotent?",id:"is-your-operation-idempotent",level:3},{value:"Risk Assessment Matrix",id:"risk-assessment-matrix",level:3},{value:"Practical Implementation Patterns",id:"practical-implementation-patterns",level:2},{value:"Pattern 1: Financial Operations",id:"pattern-1-financial-operations",level:3},{value:"Pattern 2: Infrastructure Setup",id:"pattern-2-infrastructure-setup",level:3},{value:"Pattern 3: Conditional Logic Based on Environment",id:"pattern-3-conditional-logic-based-on-environment",level:3},{value:"Cloud Edition Enhanced Recovery",id:"cloud-edition-enhanced-recovery",level:2},{value:"Enhanced MANUAL_INTERVENTION",id:"enhanced-manual_intervention",level:3},{value:"Enhanced ALWAYS_RETRY",id:"enhanced-always_retry",level:3},{value:"Marker Mechanism (Cloud Edition)",id:"marker-mechanism-cloud-edition",level:3},{value:"Operational Workflows",id:"operational-workflows",level:2},{value:"Issue Resolution Process",id:"issue-resolution-process",level:3},{value:"Monitoring and Alerting",id:"monitoring-and-alerting",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"<strong>Start Conservative, Optimize Gradually</strong>",id:"start-conservative-optimize-gradually",level:3},{value:"<strong>Design for Idempotency When Possible</strong>",id:"design-for-idempotency-when-possible",level:3},{value:"<strong>Document Recovery Strategy Decisions</strong>",id:"document-recovery-strategy-decisions",level:3},{value:"<strong>Test Both Strategies in Development</strong>",id:"test-both-strategies-in-development",level:3},{value:"<strong>Enterprise Governance</strong>",id:"enterprise-governance",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"recovery-strategies",children:"Recovery Strategies"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Intelligent failure handling for enterprise distributed systems"})}),"\n",(0,r.jsx)(n.p,{children:"Flamingock's recovery strategies are a key differentiator from traditional tools. While others retry blindly or fail silently, Flamingock provides intelligent, configurable recovery based on operation characteristics."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"the-safety-first-philosophy",children:"The Safety-First Philosophy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Core Principle"}),': "When in doubt, stop and alert rather than corrupt data."']}),"\n",(0,r.jsx)(n.p,{children:'Traditional tools assume the "happy path" - they retry operations blindly or fail without context. This approach leads to:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Silent data corruption"}),"\n",(0,r.jsx)(n.li,{children:"Inconsistent system states"}),"\n",(0,r.jsx)(n.li,{children:"Difficult troubleshooting"}),"\n",(0,r.jsx)(n.li,{children:"Compliance gaps"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Flamingock's Approach"}),": Configurable recovery strategies that match your operation's risk profile."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"recovery-strategy-types",children:"Recovery Strategy Types"}),"\n",(0,r.jsx)(n.h3,{id:"manual_intervention-default",children:"MANUAL_INTERVENTION (Default)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy"}),': "Safety first - human judgment for uncertain situations."']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@TargetSystem("financial-database")\n@ChangeUnit(id = "process-payments", order = "001", author = "finance-team")\n// No @Recovery annotation = MANUAL_INTERVENTION default\npublic class ProcessPayments {\n    \n    @Execution\n    public void execute(MongoDatabase financialDb) {\n        // Critical financial operations\n        // Any failure requires manual review to ensure data integrity\n        financialDb.getCollection("payments")\n                  .updateMany(eq("status", "pending"), \n                             combine(set("status", "processed"),\n                                   set("processedAt", new Date())));\n    }\n    \n    @RollbackExecution\n    public void rollback(MongoDatabase financialDb) {\n        // Financial rollback requires careful manual oversight\n        financialDb.getCollection("payments")\n                  .updateMany(eq("status", "processed"),\n                             combine(set("status", "pending"),\n                                   unset("processedAt")));\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When It Activates"}),": Any failure where system state is uncertain\n",(0,r.jsx)(n.strong,{children:"What Happens"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Execution stops immediately"}),"\n",(0,r.jsx)(n.li,{children:"Issue logged with detailed context"}),"\n",(0,r.jsx)(n.li,{children:"Human review required via CLI"}),"\n",(0,r.jsx)(n.li,{children:"Complete audit trail maintained"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best For"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Financial transactions"}),"\n",(0,r.jsx)(n.li,{children:"User data modifications"}),"\n",(0,r.jsx)(n.li,{children:"Critical business logic"}),"\n",(0,r.jsx)(n.li,{children:"Non-idempotent operations"}),"\n",(0,r.jsx)(n.li,{children:"Compliance-sensitive changes"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"always_retry",children:"ALWAYS_RETRY"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy"}),': "Keep trying until successful - for operations we know are safe."']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@TargetSystem("user-cache")\n@ChangeUnit(id = "warm-user-cache", order = "002", author = "platform-team")\n@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)\npublic class WarmUserCache {\n    \n    @Execution\n    public void execute(RedisTemplate redis, UserService userService) {\n        // Idempotent cache warming - safe to repeat\n        List<User> activeUsers = userService.findActiveUsers();\n        for (User user : activeUsers) {\n            String cacheKey = "user:" + user.getId();\n            UserProfile profile = userService.getUserProfile(user.getId());\n            redis.opsForValue().set(cacheKey, profile, Duration.ofHours(24));\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(RedisTemplate redis) {\n        // Clear cache - used for CLI undo operations\n        redis.delete("user:*");\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When It Activates"}),": Any failure, regardless of cause\n",(0,r.jsx)(n.strong,{children:"What Happens"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Failure is logged"}),"\n",(0,r.jsx)(n.li,{children:"Automatic retry on next execution"}),"\n",(0,r.jsx)(n.li,{children:"Continues until successful"}),"\n",(0,r.jsx)(n.li,{children:"No manual intervention required"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best For"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cache warming operations"}),"\n",(0,r.jsx)(n.li,{children:"Idempotent API calls"}),"\n",(0,r.jsx)(n.li,{children:"Event publishing (with consistent keys)"}),"\n",(0,r.jsx)(n.li,{children:"Configuration updates"}),"\n",(0,r.jsx)(n.li,{children:"Index creation"}),"\n",(0,r.jsx)(n.li,{children:"File operations with overwrite"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"decision-framework",children:"Decision Framework"}),"\n",(0,r.jsx)(n.h3,{id:"is-your-operation-idempotent",children:"Is Your Operation Idempotent?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Idempotent"}),": Running multiple times produces same result as running once"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Cache SET operations"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Database UPSERT operations"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 File overwrites"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 CREATE IF NOT EXISTS operations"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Increment/decrement operations"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Append operations"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Time-sensitive operations"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"risk-assessment-matrix",children:"Risk Assessment Matrix"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation Risk"}),(0,r.jsx)(n.th,{children:"Data Criticality"}),(0,r.jsx)(n.th,{children:"Recovery Strategy"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"High"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"High"})}),(0,r.jsx)(n.td,{children:"MANUAL_INTERVENTION"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"High"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Low"})}),(0,r.jsx)(n.td,{children:"MANUAL_INTERVENTION"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Low"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"High"})}),(0,r.jsx)(n.td,{children:"MANUAL_INTERVENTION"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Low"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Low"})}),(0,r.jsx)(n.td,{children:"ALWAYS_RETRY (if idempotent)"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High Risk + High Criticality"}),": Financial transactions, user authentication data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High Risk + Low Criticality"}),": Complex multi-step processes, dependency changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low Risk + High Criticality"}),": Simple user data updates, critical configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low Risk + Low Criticality"}),": Cache operations, metrics collection"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"practical-implementation-patterns",children:"Practical Implementation Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-1-financial-operations",children:"Pattern 1: Financial Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@TargetSystem("payment-system")\n@ChangeUnit(id = "process-refunds", order = "010", author = "finance-team")\n// MANUAL_INTERVENTION default - no annotation needed\npublic class ProcessRefunds {\n    \n    @Execution\n    public void execute(PaymentService paymentService) {\n        // Critical financial operation - requires human oversight on failure\n        List<RefundRequest> pendingRefunds = paymentService.getPendingRefunds();\n        for (RefundRequest refund : pendingRefunds) {\n            paymentService.processRefund(refund);\n            auditService.logRefund(refund);\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(PaymentService paymentService) {\n        // Financial rollbacks require manual verification\n        // This method used for CLI undo operations\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-2-infrastructure-setup",children:"Pattern 2: Infrastructure Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@TargetSystem("messaging-infrastructure")\n@ChangeUnit(id = "create-kafka-topics", order = "020", author = "platform-team",\n           transactional = false)\n@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)\npublic class CreateKafkaTopics {\n    \n    @Execution\n    public void execute(KafkaAdminClient kafkaAdmin) {\n        // Topic creation is idempotent - safe to retry\n        List<NewTopic> topics = Arrays.asList(\n            new NewTopic("user-events", 10, (short) 3),\n            new NewTopic("order-events", 10, (short) 3)\n        );\n        kafkaAdmin.createTopics(topics);\n    }\n    \n    @RollbackExecution\n    public void rollback(KafkaAdminClient kafkaAdmin) {\n        // Delete topics - used for CLI undo operations\n        kafkaAdmin.deleteTopics(Arrays.asList("user-events", "order-events"));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-3-conditional-logic-based-on-environment",children:"Pattern 3: Conditional Logic Based on Environment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@TargetSystem("user-database")\n@ChangeUnit(id = "user-data-cleanup", order = "030", author = "data-team")\n@Recovery(strategy = RecoveryStrategy.MANUAL_INTERVENTION)  // Explicit for clarity\npublic class UserDataCleanup {\n    \n    @Execution\n    public void execute(MongoDatabase userDb, @Value("${environment}") String env) {\n        if ("production".equals(env)) {\n            // Production data cleanup requires manual oversight\n            cleanupInactiveUsers(userDb);\n        } else {\n            // Non-production can be more aggressive\n            cleanupAllTestData(userDb);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cloud-edition-enhanced-recovery",children:"Cloud Edition Enhanced Recovery"}),"\n",(0,r.jsx)(n.p,{children:"Cloud Edition uses the same recovery strategies but provides enhanced outcomes:"}),"\n",(0,r.jsx)(n.h3,{id:"enhanced-manual_intervention",children:"Enhanced MANUAL_INTERVENTION"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic issue detection"})," with real-time alerts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Detailed diagnostic information"})," for faster resolution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Workflow automation"})," for common resolution patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Team collaboration"})," features for complex issues"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"enhanced-always_retry",children:"Enhanced ALWAYS_RETRY"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Intelligent retry backoff"})," prevents system overload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Circuit breaker patterns"})," prevent cascading failures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic reconciliation"})," detects and resolves inconsistencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advanced monitoring"})," provides visibility into retry patterns"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"marker-mechanism-cloud-edition",children:"Marker Mechanism (Cloud Edition)"}),"\n",(0,r.jsx)(n.p,{children:"For transactional systems, Cloud Edition uses sophisticated coordination:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Intent markers"})," placed before execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State tracking"})," during execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolution markers"})," after completion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic recovery"})," based on marker state"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This enables Cloud Edition to automatically resolve many issues that require manual intervention in Community Edition."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"operational-workflows",children:"Operational Workflows"}),"\n",(0,r.jsx)(n.h3,{id:"issue-resolution-process",children:"Issue Resolution Process"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 1. Detect issues\nflamingock issue list\n# Shows all changes requiring attention\n\n# 2. Get next priority issue\nflamingock issue get\n# Returns detailed context and guidance\n\n# 3. Investigate and resolve\n# Review target system state\n# Make necessary corrections\n# Document resolution\n\n# 4. Mark as resolved\nflamingock audit fix -c change-id --resolution APPLIED\n# or\nflamingock audit fix -c change-id --resolution ROLLED_BACK\n"})}),"\n",(0,r.jsx)(n.h3,{id:"monitoring-and-alerting",children:"Monitoring and Alerting"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Issue detection"}),": Automated monitoring of failure states"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Alert integration"}),": Connect to PagerDuty, Slack, email systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metrics tracking"}),": Success rates, failure patterns, resolution times"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dashboard visibility"}),": Real-time status across environments"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"start-conservative-optimize-gradually",children:(0,r.jsx)(n.strong,{children:"Start Conservative, Optimize Gradually"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Begin with MANUAL_INTERVENTION (default)"}),"\n",(0,r.jsx)(n.li,{children:"Monitor failure patterns and resolution outcomes"}),"\n",(0,r.jsx)(n.li,{children:"Identify truly idempotent operations"}),"\n",(0,r.jsx)(n.li,{children:"Gradually move appropriate changes to ALWAYS_RETRY"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"design-for-idempotency-when-possible",children:(0,r.jsx)(n.strong,{children:"Design for Idempotency When Possible"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// \u2705 Idempotent design\nusers.updateMany(\n    eq("status", "pending"),\n    set("status", "processed")  // Same result regardless of repetition\n);\n\n// \u274c Non-idempotent design  \nusers.updateMany(\n    eq("status", "pending"),\n    inc("processCount", 1)  // Different result each time\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"document-recovery-strategy-decisions",children:(0,r.jsx)(n.strong,{children:"Document Recovery Strategy Decisions"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)\n// Document why: "Cache SET operations are idempotent and safe to retry"\n@ChangeUnit(description = "Warm user profile cache - idempotent operation safe for automatic retry")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"test-both-strategies-in-development",children:(0,r.jsx)(n.strong,{children:"Test Both Strategies in Development"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simulate failures in lower environments"}),"\n",(0,r.jsx)(n.li,{children:"Verify MANUAL_INTERVENTION workflow"}),"\n",(0,r.jsx)(n.li,{children:"Validate ALWAYS_RETRY behavior"}),"\n",(0,r.jsx)(n.li,{children:"Test rollback logic for both strategies"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"enterprise-governance",children:(0,r.jsx)(n.strong,{children:"Enterprise Governance"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Policy definition"}),": Establish organization-wide guidelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code review"}),": Include recovery strategy in review process"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compliance documentation"}),": Maintain records of strategy decisions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular assessment"}),": Review and update strategies based on operational experience"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Takeaway"}),": Recovery strategies are not just error handling - they're a core architectural decision that affects operational safety, team productivity, and business risk. Choose wisely, document thoroughly, and evolve based on operational experience."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);