"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[398],{2613:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"overview/core-concepts","title":"Core concepts","description":"Changes","source":"@site/docs/overview/core-concepts.md","sourceDirName":"overview","slug":"/overview/core-concepts","permalink":"/docs/overview/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/flamingock/flamingock-java/docs/overview/core-concepts.md","tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30},"sidebar":"tutorialSidebar","previous":{"title":"Quick start","permalink":"/docs/overview/quick-start"},"next":{"title":"Target systems vs audit store","permalink":"/docs/overview/audit-store-vs-target-system"}}');var a=s(4848),i=s(8453);const r={sidebar_position:30},o="Core concepts",c={},l=[{value:"Changes",id:"changes",level:2},{value:"Templates",id:"templates",level:2},{value:"Recovery strategies",id:"recovery-strategies",level:2},{value:"Audit store",id:"audit-store",level:2},{value:"Target system",id:"target-system",level:2},{value:"Transaction handling",id:"transaction-handling",level:2},{value:"Transactional target systems",id:"transactional-target-systems",level:3},{value:"Non-transactional target systems",id:"non-transactional-target-systems",level:3},{value:"Stages",id:"stages",level:2}];function d(e){const t={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"core-concepts",children:"Core concepts"})}),"\n",(0,a.jsx)(t.h2,{id:"changes",children:"Changes"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Changes"})," are the fundamental building blocks of Flamingock's Change-as-Code architecture. They represent atomic, versioned changes applied to target systems with complete safety guarantees and audit capabilities."]}),"\n",(0,a.jsx)(t.p,{children:"Each Change includes:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Unique identity"}),": ID, order, and metadata for tracking"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Target system"}),": Where the changes is applied to"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Execution logic"}),": The actual change implementation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rollback capability"}),": Compensation logic for governance and undo operations"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Recovery strategy"}),": Configurable behavior for handling failures"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Changes can be implemented in two forms:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Code-based"}),": Java classes with annotations that contain the change logic"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Template-based"}),": Declarative low-code approach using YAML configurations"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["For a deeper dive around Changes, see the ",(0,a.jsx)(t.a,{href:"/docs/changes/anatomy-and-structure",children:"Changes"})," section."]}),"\n",(0,a.jsx)(t.h2,{id:"templates",children:"Templates"}),"\n",(0,a.jsx)(t.p,{children:"Templates provide a reusable layer on top of Changes for common change patterns. When you have multiple changes that share similar logic (for example, executing SQL statements), templates allow you to abstract that common logic and reuse it."}),"\n",(0,a.jsx)(t.p,{children:"With templates, you create multiple Changes using a declarative, low-code approach. Each Change uses a template and passes its specific configuration. For example, an SQL template receives the SQL statement as configuration, executes it, and handles errors consistently."}),"\n",(0,a.jsx)(t.p,{children:"This approach is particularly useful for:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Standardizing common operations across your codebase"}),"\n",(0,a.jsx)(t.li,{children:"Reducing boilerplate code"}),"\n",(0,a.jsx)(t.li,{children:"Enabling non-developers to define changes through configuration"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["For more information about templates, see the ",(0,a.jsx)(t.a,{href:"/docs/templates/templates-introduction",children:"Templates"})," section."]}),"\n",(0,a.jsx)(t.h2,{id:"recovery-strategies",children:"Recovery strategies"}),"\n",(0,a.jsx)(t.p,{children:"Recovery strategies define how Flamingock responds when a Change fails during execution. They determine whether the system should stop and wait for manual intervention or automatically retry the operation."}),"\n",(0,a.jsx)(t.p,{children:"Flamingock provides two main strategies:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Manual intervention"})," (default): Stops execution and requires human review when failures occur"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Always retry"}),": Automatically retries the change on the next execution attempt"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The choice of strategy depends on whether your changes are idempotent and how critical they are to your system's integrity."}),"\n",(0,a.jsxs)(t.p,{children:["For detailed configuration and implementation, see the ",(0,a.jsx)(t.a,{href:"/docs/safety-and-recovery/recovery-strategies",children:"Recovery strategies"})," section."]}),"\n",(0,a.jsx)(t.h2,{id:"audit-store",children:"Audit store"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"audit store"})," is where Flamingock records metadata about change executions. Its purpose is to track which Changes have been executed, when they ran, and their outcomes. This ensures idempotency, enables rollbacks, and provides audit capabilities. The audit store is managed entirely by Flamingock - your code never directly interacts with it."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"In Cloud Edition, the audit store is automatically provided - no configuration needed in your builder. Community Edition users must configure their own audit store."})}),"\n",(0,a.jsx)(t.h2,{id:"target-system",children:"Target system"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"target system"})," is where your actual business changes are applied. These are the systems your Changes modify - databases, message queues, APIs, configuration services, etc. Each Change declares which target system it operates on."]}),"\n",(0,a.jsxs)(t.p,{children:["For more details about how these systems work together, see the ",(0,a.jsx)(t.a,{href:"/docs/overview/audit-store-vs-target-system",children:"Audit store vs target system"})," section."]}),"\n",(0,a.jsx)(t.h2,{id:"transaction-handling",children:"Transaction handling"}),"\n",(0,a.jsx)(t.p,{children:"Flamingock adapts its behavior based on the transactional capabilities of your target systems:"}),"\n",(0,a.jsx)(t.h3,{id:"transactional-target-systems",children:"Transactional target systems"}),"\n",(0,a.jsx)(t.p,{children:"Systems that support ACID transactions, such as MongoDB 4.0+, PostgreSQL, MySQL, or other transactional stores. When working with these systems, Flamingock can leverage native transaction support to ensure atomicity of changes. If a failure occurs mid-execution, the native rollback mechanism ensures no partial changes are left in the system."}),"\n",(0,a.jsx)(t.h3,{id:"non-transactional-target-systems",children:"Non-transactional target systems"}),"\n",(0,a.jsx)(t.p,{children:"Systems like Kafka, S3, REST APIs, or file systems that don't support transactions. For these systems, Flamingock relies on explicit rollback methods and careful change design to maintain consistency. Recovery strategies become particularly important for handling failures in non-transactional contexts."}),"\n",(0,a.jsxs)(t.p,{children:["For implementation details, see the ",(0,a.jsx)(t.a,{href:"/docs/changes/transactions",children:"Transactions"})," section."]}),"\n",(0,a.jsx)(t.h2,{id:"stages",children:"Stages"}),"\n",(0,a.jsx)(t.p,{children:"Stages organize your changes into logical groups within Flamingock's execution pipeline. By default, you work with a single stage that contains all your changes, ensuring they execute sequentially in a deterministic order."}),"\n",(0,a.jsx)(t.p,{children:"Key characteristics:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Changes within a stage execute sequentially with guaranteed order"}),"\n",(0,a.jsx)(t.li,{children:"Most applications only need a single stage"}),"\n",(0,a.jsx)(t.li,{children:"Multiple stages can be used for modular architectures, but execution order between stages is not guaranteed"}),"\n",(0,a.jsx)(t.li,{children:"Each stage defines where to find its changes (package or directory location)"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["For detailed information about stages and advanced configurations, see the ",(0,a.jsx)(t.a,{href:"/docs/flamingock-library-config/setup-and-stages",children:"Setup and stages"})," section."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var n=s(6540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);