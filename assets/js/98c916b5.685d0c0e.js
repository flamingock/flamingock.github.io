"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[398],{2613:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"overview/core-concepts","title":"Core concepts","description":"ChangeUnits","source":"@site/docs/overview/core-concepts.md","sourceDirName":"overview","slug":"/overview/core-concepts","permalink":"/docs/overview/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/overview/core-concepts.md","tags":[],"version":"current","sidebarPosition":80,"frontMatter":{"sidebar_position":80},"sidebar":"tutorialSidebar","previous":{"title":"Flamingock editions","permalink":"/docs/overview/Editions"},"next":{"title":"Flamingock Technical Overview","permalink":"/docs/overview/technical-overview"}}');var i=t(4848),a=t(8453);const r={sidebar_position:80},o="Core concepts",c={},l=[{value:"ChangeUnits",id:"changeunits",level:3},{value:"Templates",id:"templates",level:3},{value:"Recovery strategies",id:"recovery-strategies",level:2},{value:"Audit store",id:"audit-store",level:2},{value:"Target system",id:"target-system",level:2},{value:"Transaction handling",id:"transaction-handling",level:2},{value:"Transactional target systems",id:"transactional-target-systems",level:3},{value:"Non-transactional target systems",id:"non-transactional-target-systems",level:3},{value:"Stages",id:"stages",level:2},{value:"Events",id:"events",level:2}];function h(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"core-concepts",children:"Core concepts"})}),"\n",(0,i.jsx)(n.h3,{id:"changeunits",children:"ChangeUnits"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ChangeUnits"})," are the fundamental building blocks of Flamingock's Change-as-Code architecture. They represent atomic, versioned changes applied to target systems with complete safety guarantees and audit capabilities."]}),"\n",(0,i.jsx)(n.p,{children:"Each ChangeUnit includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unique identity"}),": ID, order, and metadata for tracking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Target system"}),": Where the changes is applied to"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution logic"}),": The actual change implementation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rollback capability"}),": Compensation logic for governance and undo operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Recovery strategy"}),": Configurable behavior for handling failures"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"ChangeUnits can be implemented in two forms:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code-based"}),": Java classes with annotations that contain the change logic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Template-based"}),": Declarative low-code approach using YAML configurations"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For a deeper dive around ChangeUnits, see the ",(0,i.jsx)(n.a,{href:"/docs/flamingock-library-config/changeunits-deep-dive",children:"ChangeUnits deep dive"})," section."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"templates",children:"Templates"}),"\n",(0,i.jsx)(n.p,{children:"Templates provide a reusable layer on top of ChangeUnits for common change patterns. When you have multiple changes that share similar logic (for example, executing SQL statements), templates allow you to abstract that common logic and reuse it."}),"\n",(0,i.jsx)(n.p,{children:"With templates, you create multiple ChangeUnits using a declarative, low-code approach. Each ChangeUnit uses a template and passes its specific configuration. For example, an SQL template receives the SQL statement as configuration, executes it, and handles errors consistently."}),"\n",(0,i.jsx)(n.p,{children:"This approach is particularly useful for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Standardizing common operations across your codebase"}),"\n",(0,i.jsx)(n.li,{children:"Reducing boilerplate code"}),"\n",(0,i.jsx)(n.li,{children:"Enabling non-developers to define changes through configuration"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more information about templates, see the ",(0,i.jsx)(n.a,{href:"/docs/templates/templates-introduction",children:"Templates"})," section."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"recovery-strategies",children:"Recovery strategies"}),"\n",(0,i.jsx)(n.p,{children:"Recovery strategies define how Flamingock responds when a ChangeUnit fails during execution. They determine whether the system should stop and wait for manual intervention or automatically retry the operation."}),"\n",(0,i.jsx)(n.p,{children:"Flamingock provides two main strategies:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Manual intervention"})," (default): Stops execution and requires human review when failures occur"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Always retry"}),": Automatically retries the change on the next execution attempt"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The choice of strategy depends on whether your changes are idempotent and how critical they are to your system's integrity."}),"\n",(0,i.jsxs)(n.p,{children:["For detailed configuration and implementation, see the ",(0,i.jsx)(n.a,{href:"../flamingock-library-config/recovery-configuration.md",children:"Recovery configuration"})," section."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"audit-store",children:"Audit store"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"audit store"})," is where Flamingock records metadata about change executions. Its purpose is to track which ChangeUnits have been executed, when they ran, and their outcomes. This ensures idempotency, enables rollbacks, and provides audit capabilities. The audit store is managed entirely by Flamingock - your code never directly interacts with it."]}),"\n",(0,i.jsx)(n.h2,{id:"target-system",children:"Target system"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"target system"})," is where your actual business changes are applied. These are the systems your ChangeUnits modify - databases, message queues, APIs, configuration services, etc. Each ChangeUnit declares which target system it operates on."]}),"\n",(0,i.jsxs)(n.p,{children:["For more details about how these systems work together, see the ",(0,i.jsx)(n.a,{href:"/docs/overview/audit-store-vs-target-system",children:"Audit store vs target system"})," section."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"transaction-handling",children:"Transaction handling"}),"\n",(0,i.jsx)(n.p,{children:"Flamingock adapts its behavior based on the transactional capabilities of your target systems:"}),"\n",(0,i.jsx)(n.h3,{id:"transactional-target-systems",children:"Transactional target systems"}),"\n",(0,i.jsx)(n.p,{children:"Systems like PostgreSQL, MySQL, or MongoDB 4.0+ that support ACID transactions. When working with these systems, Flamingock can leverage native transaction support to ensure atomicity of changes. If a failure occurs mid-execution, the native rollback mechanism ensures no partial changes are left in the system."}),"\n",(0,i.jsx)(n.h3,{id:"non-transactional-target-systems",children:"Non-transactional target systems"}),"\n",(0,i.jsx)(n.p,{children:"Systems like Kafka, S3, REST APIs, or file systems that don't support transactions. For these systems, Flamingock relies on explicit rollback methods and careful change design to maintain consistency. Recovery strategies become particularly important for handling failures in non-transactional contexts."}),"\n",(0,i.jsxs)(n.p,{children:["For implementation details, see the ",(0,i.jsx)(n.a,{href:"/docs/flamingock-library-config/transactions",children:"Transactions"})," section."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"stages",children:"Stages"}),"\n",(0,i.jsx)(n.p,{children:"Stages organize your changes into logical groups within Flamingock's execution pipeline. By default, you work with a single stage that contains all your changes, ensuring they execute sequentially in a deterministic order."}),"\n",(0,i.jsx)(n.p,{children:"Key characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Changes within a stage execute sequentially with guaranteed order"}),"\n",(0,i.jsx)(n.li,{children:"Most applications only need a single stage"}),"\n",(0,i.jsx)(n.li,{children:"Multiple stages can be used for modular architectures, but execution order between stages is not guaranteed"}),"\n",(0,i.jsx)(n.li,{children:"Each stage defines where to find its changes (package or directory location)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For detailed information about stages and advanced configurations, see the ",(0,i.jsx)(n.a,{href:"/docs/flamingock-library-config/setup-and-stages",children:"Setup and stages"})," section."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.p,{children:"Flamingock can notify your application about the execution status of changes through events. This enables integration with monitoring systems, custom logging, or triggering downstream processes based on change completion."}),"\n",(0,i.jsxs)(n.p,{children:["For more information about events, see the ",(0,i.jsx)(n.a,{href:"/docs/flamingock-library-config/events",children:"Events"})," section."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);