"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[276],{889:(n,a,e)=>{e.r(a),e.d(a,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"flamingock-library-config/transactions","title":"Transactions","description":"Flamingock provides intelligent transaction management that adapts to your target systems\' capabilities. Understanding when and how changes are executed transactionally is key to building reliable system evolution.","source":"@site/docs/flamingock-library-config/transactions.md","sourceDirName":"flamingock-library-config","slug":"/flamingock-library-config/transactions","permalink":"/docs/flamingock-library-config/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/flamingock-library-config/transactions.md","tags":[],"version":"current","sidebarPosition":40,"frontMatter":{"title":"Transactions","sidebar_position":40},"sidebar":"tutorialSidebar","previous":{"title":"Lock","permalink":"/docs/flamingock-library-config/lock"},"next":{"title":"Additional configuration","permalink":"/docs/flamingock-library-config/additional-configuration"}}');var s=e(4848),i=e(8453);const l={title:"Transactions",sidebar_position:40},o="Transactions",r={},c=[{value:"How Flamingock handles transactions",id:"how-flamingock-handles-transactions",level:2},{value:"Default behavior",id:"default-behavior",level:3},{value:"When to use non-transactional",id:"when-to-use-non-transactional",level:3},{value:"Examples",id:"examples",level:2},{value:"Transactional ChangeUnit (default)",id:"transactional-changeunit-default",level:3},{value:"Non-transactional ChangeUnit",id:"non-transactional-changeunit",level:3},{value:"Non-transactional target system",id:"non-transactional-target-system",level:3},{value:"Best practices",id:"best-practices",level:2},{value:"Always provide @RollbackExecution",id:"always-provide-rollbackexecution",level:3},{value:"Use appropriate transactionality",id:"use-appropriate-transactionality",level:3},{value:"Handle rollback gracefully",id:"handle-rollback-gracefully",level:3}];function d(n){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"transactions",children:"Transactions"})}),"\n",(0,s.jsx)(a.p,{children:"Flamingock provides intelligent transaction management that adapts to your target systems' capabilities. Understanding when and how changes are executed transactionally is key to building reliable system evolution."}),"\n",(0,s.jsx)(a.hr,{}),"\n",(0,s.jsx)(a.h2,{id:"how-flamingock-handles-transactions",children:"How Flamingock handles transactions"}),"\n",(0,s.jsx)(a.h3,{id:"default-behavior",children:"Default behavior"}),"\n",(0,s.jsxs)(a.p,{children:["All ChangeUnits default to ",(0,s.jsx)(a.code,{children:"transactional = true"})," for maximum safety. Flamingock automatically adapts based on your target system:"]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"For transactional target systems"})," (PostgreSQL, MongoDB, SQL databases):"]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Change execution runs within a native database transaction"}),"\n",(0,s.jsx)(a.li,{children:"Automatic rollback on failure"}),"\n",(0,s.jsx)(a.li,{children:"Session/connection managed automatically"}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"For non-transactional target systems"})," (Kafka, S3, REST APIs):"]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"No native transaction support"}),"\n",(0,s.jsxs)(a.li,{children:["Safety through compensation logic (",(0,s.jsx)(a.code,{children:"@RollbackExecution"}),")"]}),"\n",(0,s.jsx)(a.li,{children:"Idempotent operations recommended"}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"when-to-use-non-transactional",children:"When to use non-transactional"}),"\n",(0,s.jsxs)(a.p,{children:["Override the default with ",(0,s.jsx)(a.code,{children:"transactional = false"})," when:"]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"DDL operations (CREATE INDEX, ALTER TABLE) that don't support transactions"}),"\n",(0,s.jsx)(a.li,{children:"Large bulk operations that exceed transaction limits"}),"\n",(0,s.jsx)(a.li,{children:"Operations that must complete regardless of other failures"}),"\n"]}),"\n",(0,s.jsx)(a.hr,{}),"\n",(0,s.jsx)(a.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(a.h3,{id:"transactional-changeunit-default",children:"Transactional ChangeUnit (default)"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'@TargetSystem("user-database")\n@ChangeUnit(id = "update-user-status", order = "001")\n// transactional = true (default)\npublic class UpdateUserStatus {\n    \n    @Execution\n    public void execute(MongoDatabase database, ClientSession session) {\n        // Runs inside a transaction, session provided automatically\n        database.getCollection("users")\n                .updateMany(session, eq("status", "pending"), set("status", "active"));\n    }\n    \n    @RollbackExecution  \n    public void rollback(MongoDatabase database, ClientSession session) {\n        // For manual rollback operations (CLI undo)\n        database.getCollection("users")\n                .updateMany(session, eq("status", "active"), set("status", "pending"));\n    }\n}\n'})}),"\n",(0,s.jsx)(a.h3,{id:"non-transactional-changeunit",children:"Non-transactional ChangeUnit"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'@TargetSystem("user-database")\n@ChangeUnit(id = "create-indexes", order = "002", transactional = false)\npublic class CreateIndexes {\n    \n    @Execution\n    public void execute(MongoDatabase database) {\n        // No transaction - DDL operations\n        database.getCollection("users").createIndex(ascending("email"));\n    }\n    \n    @RollbackExecution\n    public void rollback(MongoDatabase database) {\n        // Called automatically on failure for cleanup\n        try {\n            database.getCollection("users").dropIndex("email_1");\n        } catch (Exception e) {\n            // Handle cleanup errors\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(a.h3,{id:"non-transactional-target-system",children:"Non-transactional target system"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'@TargetSystem("event-stream") \n@ChangeUnit(id = "publish-events", order = "003", transactional = false)\n// Must be false for non-transactional systems\npublic class PublishEvents {\n    \n    @Execution\n    public void execute(KafkaTemplate kafka) {\n        kafka.send("user-topic", "status-changed", eventData);\n    }\n    \n    @RollbackExecution\n    public void rollback(KafkaTemplate kafka) {\n        // Compensation logic - publish rollback event\n        kafka.send("user-topic", "status-rollback", compensationData);\n    }\n}\n'})}),"\n",(0,s.jsx)(a.hr,{}),"\n",(0,s.jsx)(a.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,s.jsx)(a.h3,{id:"always-provide-rollbackexecution",children:"Always provide @RollbackExecution"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Transactional systems"}),": Used for manual rollback operations (CLI undo)"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Non-transactional systems"}),": Called automatically on failure for cleanup"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Both cases"}),": Essential for complete change management"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"use-appropriate-transactionality",children:"Use appropriate transactionality"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsxs)(a.strong,{children:["Keep default ",(0,s.jsx)(a.code,{children:"transactional = true"})]})," for data changes"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsxs)(a.strong,{children:["Use ",(0,s.jsx)(a.code,{children:"transactional = false"})]})," only when necessary (DDL, bulk operations)"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Design idempotent operations"})," for non-transactional systems"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"handle-rollback-gracefully",children:"Handle rollback gracefully"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'@RollbackExecution\npublic void rollback(MongoDatabase database) {\n    try {\n        // Attempt cleanup\n        database.getCollection("temp_data").drop();\n    } catch (Exception e) {\n        // Log but don\'t fail - rollback should be best effort\n        logger.warn("Rollback cleanup failed", e);\n    }\n}\n'})}),"\n",(0,s.jsx)(a.hr,{}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Key takeaway"}),": Flamingock's transaction management adapts to your target systems while maintaining safety. Use the defaults unless you have specific requirements for non-transactional execution."]})]})}function u(n={}){const{wrapper:a}={...(0,i.R)(),...n.components};return a?(0,s.jsx)(a,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,a,e)=>{e.d(a,{R:()=>l,x:()=>o});var t=e(6540);const s={},i=t.createContext(s);function l(n){const a=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(a):{...a,...n}},[a,n])}function o(n){let a;return a=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(i.Provider,{value:a},n.children)}}}]);