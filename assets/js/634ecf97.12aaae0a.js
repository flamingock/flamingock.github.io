"use strict";(self.webpackChunkflamingock=self.webpackChunkflamingock||[]).push([[3468],{7629:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"recovery-and-safety/safety-patterns","title":"Safety Patterns","description":"Proven approaches for enterprise-grade distributed system evolution","source":"@site/docs/recovery-and-safety/safety-patterns.md","sourceDirName":"recovery-and-safety","slug":"/recovery-and-safety/safety-patterns","permalink":"/docs/recovery-and-safety/safety-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/recovery-and-safety/safety-patterns.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Safety Patterns","sidebar_position":3}}');var a=t(4848),r=t(8453);const i={title:"Safety Patterns",sidebar_position:3},o="Safety Patterns",c={},l=[{value:"Core Safety Principles",id:"core-safety-principles",level:2},{value:"1. <strong>Explicit is Better Than Implicit</strong>",id:"1-explicit-is-better-than-implicit",level:3},{value:"2. <strong>Design for Failure</strong>",id:"2-design-for-failure",level:3},{value:"3. <strong>Idempotency by Design</strong>",id:"3-idempotency-by-design",level:3},{value:"Enterprise Safety Patterns",id:"enterprise-safety-patterns",level:2},{value:"Pattern 1: Critical Path Protection",id:"pattern-1-critical-path-protection",level:3},{value:"Pattern 2: Idempotent Operations with Retry",id:"pattern-2-idempotent-operations-with-retry",level:3},{value:"Pattern 3: Progressive Migration",id:"pattern-3-progressive-migration",level:3},{value:"Pattern 4: Multi-System Coordination",id:"pattern-4-multi-system-coordination",level:3},{value:"Operational Safety Patterns",id:"operational-safety-patterns",level:2},{value:"Pattern 5: Environment-Aware Changes",id:"pattern-5-environment-aware-changes",level:3},{value:"Pattern 6: Validation and Verification",id:"pattern-6-validation-and-verification",level:3},{value:"Anti-Patterns to Avoid",id:"anti-patterns-to-avoid",level:2},{value:"\u274c Anti-Pattern 1: Silent Failures",id:"-anti-pattern-1-silent-failures",level:3},{value:"\u2705 Better Approach:",id:"-better-approach",level:3},{value:"\u274c Anti-Pattern 2: Mixing Transactional and Non-Transactional",id:"-anti-pattern-2-mixing-transactional-and-non-transactional",level:3},{value:"\u2705 Better Approach:",id:"-better-approach-1",level:3},{value:"\u274c Anti-Pattern 3: Assuming Success",id:"-anti-pattern-3-assuming-success",level:3},{value:"\u2705 Better Approach:",id:"-better-approach-2",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"<strong>Design for Production</strong>",id:"design-for-production",level:3},{value:"<strong>Choose the Right Strategy</strong>",id:"choose-the-right-strategy",level:3},{value:"<strong>Implement Proper Rollback</strong>",id:"implement-proper-rollback",level:3},{value:"<strong>Monitor and Alert</strong>",id:"monitor-and-alert",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"safety-patterns",children:"Safety Patterns"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Proven approaches for enterprise-grade distributed system evolution"})}),"\n",(0,a.jsx)(n.p,{children:"This guide presents battle-tested patterns that ensure safe, reliable system evolution in production environments. These patterns have been refined through real-world enterprise deployments and operational experience."}),"\n",(0,a.jsx)(n.h2,{id:"core-safety-principles",children:"Core Safety Principles"}),"\n",(0,a.jsxs)(n.h3,{id:"1-explicit-is-better-than-implicit",children:["1. ",(0,a.jsx)(n.strong,{children:"Explicit is Better Than Implicit"})]}),"\n",(0,a.jsx)(n.p,{children:"Always be explicit about your intentions and system boundaries."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// \u2705 Explicit and clear\n@TargetSystem("user-database")  // Clear target\n@ChangeUnit(id = "user-status-update", transactional = true)  // Explicit transaction control\n@Recovery(strategy = RecoveryStrategy.MANUAL_INTERVENTION)  // Explicit strategy\npublic class UserStatusUpdate { }\n\n// \u274c Implicit and unclear  \n@ChangeUnit(id = "update")  // Unclear intent\npublic class Update { }  // No target, relies on defaults\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"2-design-for-failure",children:["2. ",(0,a.jsx)(n.strong,{children:"Design for Failure"})]}),"\n",(0,a.jsx)(n.p,{children:"Every change should anticipate and handle failure scenarios."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("payment-system")\n@ChangeUnit(id = "process-payment-batch", order = "001", author = "finance-team")\npublic class ProcessPaymentBatch {\n    \n    @Execution\n    public void execute(PaymentService paymentService) {\n        List<Payment> pendingPayments = paymentService.getPendingPayments();\n        \n        for (Payment payment : pendingPayments) {\n            try {\n                paymentService.processPayment(payment);\n                // Mark individual payment as processed for granular tracking\n                paymentService.markAsProcessed(payment.getId());\n            } catch (PaymentException e) {\n                // Log failure but continue with other payments\n                logger.error("Failed to process payment {}: {}", payment.getId(), e.getMessage());\n                paymentService.markAsFailed(payment.getId(), e.getMessage());\n            }\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(PaymentService paymentService) {\n        // Rollback only successfully processed payments\n        List<Payment> processedPayments = paymentService.getProcessedPayments();\n        for (Payment payment : processedPayments) {\n            paymentService.revertPayment(payment);\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"3-idempotency-by-design",children:["3. ",(0,a.jsx)(n.strong,{children:"Idempotency by Design"})]}),"\n",(0,a.jsx)(n.p,{children:"When possible, design operations to be naturally idempotent."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// \u2705 Idempotent by design\n@TargetSystem("user-database")\n@ChangeUnit(id = "set-user-preferences", author = "product-team")\n@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)  // Safe because idempotent\npublic class SetUserPreferences {\n    \n    @Execution\n    public void execute(MongoDatabase userDb) {\n        // SET operations are naturally idempotent\n        userDb.getCollection("users")\n              .updateMany(\n                  new Document(), // All users\n                  new Document("$set", new Document("preferences", defaultPreferences()))\n              );\n    }\n}\n\n// \u274c Non-idempotent design\npublic class IncrementUserScores {\n    @Execution\n    public void execute(MongoDatabase userDb) {\n        // INCREMENT is not idempotent - each run changes the result\n        userDb.getCollection("users")\n              .updateMany(new Document(), new Document("$inc", new Document("score", 10)));\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"enterprise-safety-patterns",children:"Enterprise Safety Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"pattern-1-critical-path-protection",children:"Pattern 1: Critical Path Protection"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case"}),": Financial operations, user authentication, compliance-sensitive changes"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("financial-database")\n@ChangeUnit(id = "update-account-balances", order = "001", author = "finance-team",\n           transactional = true)  // Leverage database transactions\n// MANUAL_INTERVENTION default - explicit safety\npublic class UpdateAccountBalances {\n    \n    @Execution\n    public void execute(MongoDatabase financialDb, AuditLogger auditLogger) {\n        MongoCollection<Document> accounts = financialDb.getCollection("accounts");\n        \n        // Pre-execution validation\n        long totalBefore = calculateTotalBalance(accounts);\n        auditLogger.logBalanceSnapshot("before", totalBefore);\n        \n        // Critical financial operation\n        accounts.updateMany(\n            eq("status", "pending_interest"), \n            combine(\n                set("status", "interest_applied"),\n                inc("balance", calculateInterest()),\n                set("lastInterestDate", new Date())\n            )\n        );\n        \n        // Post-execution validation\n        long totalAfter = calculateTotalBalance(accounts);\n        auditLogger.logBalanceSnapshot("after", totalAfter);\n        \n        // Invariant check\n        if (Math.abs(totalAfter - totalBefore - expectedInterestTotal()) > 0.01) {\n            throw new BalanceInconsistencyException("Total balance invariant violated");\n        }\n    }\n    \n    @RollbackExecution  \n    public void rollback(MongoDatabase financialDb, AuditLogger auditLogger) {\n        auditLogger.logRollbackStart("update-account-balances");\n        \n        MongoCollection<Document> accounts = financialDb.getCollection("accounts");\n        accounts.updateMany(\n            eq("status", "interest_applied"),\n            combine(\n                set("status", "pending_interest"),\n                inc("balance", -calculateInterest()),\n                unset("lastInterestDate")\n            )\n        );\n        \n        auditLogger.logRollbackComplete("update-account-balances");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-2-idempotent-operations-with-retry",children:"Pattern 2: Idempotent Operations with Retry"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case"}),": Cache warming, event publishing, infrastructure setup"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("messaging-infrastructure")\n@ChangeUnit(id = "setup-kafka-topics", order = "002", author = "platform-team",\n           transactional = false)  // External system calls\n@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)  // Safe to retry\npublic class SetupKafkaTopics {\n    \n    @Execution\n    public void execute(KafkaAdminClient kafkaAdmin) {\n        List<NewTopic> requiredTopics = Arrays.asList(\n            new NewTopic("user-events", 10, (short) 3),\n            new NewTopic("order-events", 15, (short) 3),\n            new NewTopic("notification-events", 5, (short) 3)\n        );\n        \n        // Get existing topics to avoid creating duplicates\n        Set<String> existingTopics = kafkaAdmin.listTopics().names().get();\n        \n        List<NewTopic> topicsToCreate = requiredTopics.stream()\n            .filter(topic -> !existingTopics.contains(topic.name()))\n            .collect(Collectors.toList());\n        \n        if (!topicsToCreate.isEmpty()) {\n            // Topic creation is idempotent - safe to retry\n            kafkaAdmin.createTopics(topicsToCreate).all().get();\n            logger.info("Created {} new topics: {}", \n                       topicsToCreate.size(), \n                       topicsToCreate.stream().map(NewTopic::name).collect(Collectors.toList()));\n        } else {\n            logger.info("All required topics already exist");\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(KafkaAdminClient kafkaAdmin) {\n        // For infrastructure setup, rollback usually means cleanup\n        List<String> topicNames = Arrays.asList("user-events", "order-events", "notification-events");\n        kafkaAdmin.deleteTopics(topicNames);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-3-progressive-migration",children:"Pattern 3: Progressive Migration"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case"}),": Large-scale data transformations, phased rollouts"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("user-database")\n@ChangeUnit(id = "migrate-user-profiles-batch-1", order = "003", author = "data-team",\n           transactional = false)  // Large operation, process in batches\npublic class MigrateUserProfilesBatch1 {\n    \n    private static final int BATCH_SIZE = 1000;\n    private static final String MIGRATION_MARKER = "profile_v2_migration";\n    \n    @Execution\n    public void execute(MongoDatabase userDb) {\n        MongoCollection<Document> users = userDb.getCollection("users");\n        \n        // Process only users without migration marker (idempotent)\n        FindIterable<Document> unmigrated = users.find(\n            and(\n                exists("profileVersion", false),  // Old schema\n                exists(MIGRATION_MARKER, false)   // Not yet processed\n            )\n        ).limit(BATCH_SIZE);\n        \n        int processed = 0;\n        for (Document user : unmigrated) {\n            try {\n                // Transform user profile to new schema\n                Document newProfile = transformProfile(user);\n                \n                users.updateOne(\n                    eq("_id", user.getObjectId("_id")),\n                    combine(\n                        set("profile", newProfile),\n                        set("profileVersion", 2),\n                        set(MIGRATION_MARKER, new Date())  // Mark as processed\n                    )\n                );\n                processed++;\n                \n            } catch (Exception e) {\n                logger.error("Failed to migrate user {}: {}", user.getObjectId("_id"), e.getMessage());\n                // Mark this user as failed for separate handling\n                users.updateOne(\n                    eq("_id", user.getObjectId("_id")),\n                    set("migrationError", e.getMessage())\n                );\n            }\n        }\n        \n        logger.info("Migrated {} user profiles in this batch", processed);\n        \n        // Check if more batches are needed\n        long remaining = users.countDocuments(\n            and(\n                exists("profileVersion", false),\n                exists(MIGRATION_MARKER, false),\n                exists("migrationError", false)  // Exclude failed ones\n            )\n        );\n        \n        if (remaining > 0) {\n            logger.info("{} users remaining for migration", remaining);\n        } else {\n            logger.info("User profile migration completed successfully");\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(MongoDatabase userDb) {\n        MongoCollection<Document> users = userDb.getCollection("users");\n        \n        // Rollback users that were migrated in this execution\n        users.updateMany(\n            exists(MIGRATION_MARKER),\n            combine(\n                unset("profile"),\n                unset("profileVersion"), \n                unset(MIGRATION_MARKER),\n                unset("migrationError")\n            )\n        );\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-4-multi-system-coordination",children:"Pattern 4: Multi-System Coordination"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case"}),": Distributed system synchronization, event sourcing, complex workflows"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("user-database")  // Primary system\n@ChangeUnit(id = "sync-user-data-across-systems", order = "004", author = "integration-team",\n           transactional = false)  // Multi-system can\'t be transactional\npublic class SyncUserDataAcrossSystems {\n    \n    @Execution\n    public void execute(MongoDatabase userDb, \n                       ElasticsearchOperations searchOps,\n                       KafkaTemplate<String, Object> eventPublisher,\n                       RedisTemplate<String, Object> cacheOps) {\n        \n        // Get users that need synchronization\n        List<User> usersToSync = findUsersNeedingSync(userDb);\n        List<String> processedUsers = new ArrayList<>();\n        \n        try {\n            for (User user : usersToSync) {\n                // Step 1: Update primary database\n                updateUserInDatabase(userDb, user);\n                \n                // Step 2: Update search index  \n                indexUserInElasticsearch(searchOps, user);\n                \n                // Step 3: Update cache\n                updateUserInCache(cacheOps, user);\n                \n                // Step 4: Publish change event\n                publishUserChangeEvent(eventPublisher, user);\n                \n                // Track successful processing\n                processedUsers.add(user.getId());\n                \n                // Mark user as synchronized\n                markUserAsSynced(userDb, user.getId());\n            }\n            \n        } catch (Exception e) {\n            logger.error("Multi-system sync failed for user batch. Processed: {}. Error: {}", \n                        processedUsers.size(), e.getMessage());\n            \n            // Store progress information for rollback\n            storeProcessingProgress(userDb, processedUsers);\n            throw e;  // Re-throw to trigger rollback\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(MongoDatabase userDb,\n                        ElasticsearchOperations searchOps,\n                        KafkaTemplate<String, Object> eventPublisher, \n                        RedisTemplate<String, Object> cacheOps) {\n        \n        // Get list of users that were processed before failure\n        List<String> processedUsers = getProcessingProgress(userDb);\n        \n        for (String userId : processedUsers) {\n            try {\n                // Reverse each step in opposite order\n                publishUserRollbackEvent(eventPublisher, userId);\n                removeUserFromCache(cacheOps, userId);\n                removeUserFromElasticsearch(searchOps, userId);\n                rollbackUserInDatabase(userDb, userId);\n                \n            } catch (Exception e) {\n                logger.error("Failed to rollback user {}: {}", userId, e.getMessage());\n                // Continue with other users - partial rollback is better than none\n            }\n        }\n        \n        // Clean up progress tracking\n        clearProcessingProgress(userDb);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"operational-safety-patterns",children:"Operational Safety Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"pattern-5-environment-aware-changes",children:"Pattern 5: Environment-Aware Changes"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case"}),": Different behavior across environments, gradual rollouts"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("feature-flags")\n@ChangeUnit(id = "enable-new-checkout", order = "005", author = "product-team")\n@Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY)  // Feature flags are idempotent\npublic class EnableNewCheckout {\n    \n    @Execution\n    public void execute(FeatureFlagService flagService, \n                       @Value("${spring.profiles.active}") String environment) {\n        \n        FeatureFlagConfig config = buildConfigForEnvironment(environment);\n        \n        switch (environment) {\n            case "development":\n                // Full rollout in dev\n                flagService.enableFlag("new-checkout", config.withRollout(100));\n                break;\n                \n            case "staging":  \n                // Full rollout in staging\n                flagService.enableFlag("new-checkout", config.withRollout(100));\n                break;\n                \n            case "production":\n                // Gradual rollout in production\n                flagService.enableFlag("new-checkout", config.withRollout(5));  // Start with 5%\n                break;\n                \n            default:\n                logger.warn("Unknown environment: {}. Skipping feature flag change.", environment);\n        }\n    }\n    \n    @RollbackExecution\n    public void rollback(FeatureFlagService flagService) {\n        flagService.disableFlag("new-checkout");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-6-validation-and-verification",children:"Pattern 6: Validation and Verification"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case"}),": Critical changes requiring validation, compliance requirements"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TargetSystem("compliance-database")\n@ChangeUnit(id = "update-gdpr-consent", order = "006", author = "legal-team")\npublic class UpdateGdprConsent {\n    \n    @Execution\n    public void execute(MongoDatabase complianceDb, GdprService gdprService) {\n        MongoCollection<Document> userConsents = complianceDb.getCollection("user_consents");\n        \n        // Pre-execution validation\n        long totalUsers = userConsents.countDocuments();\n        long usersWithoutConsent = userConsents.countDocuments(exists("gdprConsent", false));\n        \n        logger.info("Starting GDPR consent update. Total users: {}, Without consent: {}", \n                   totalUsers, usersWithoutConsent);\n        \n        if (usersWithoutConsent == 0) {\n            logger.info("All users already have GDPR consent recorded. No action needed.");\n            return;\n        }\n        \n        // Execute the change\n        UpdateResult result = userConsents.updateMany(\n            exists("gdprConsent", false),\n            combine(\n                set("gdprConsent", buildDefaultConsent()),\n                set("consentUpdatedDate", new Date()),\n                set("consentSource", "system-migration")\n            )\n        );\n        \n        // Post-execution validation\n        long updatedCount = result.getModifiedCount();\n        long stillWithoutConsent = userConsents.countDocuments(exists("gdprConsent", false));\n        \n        logger.info("GDPR consent update completed. Updated: {}, Remaining without consent: {}", \n                   updatedCount, stillWithoutConsent);\n        \n        // Validation checks\n        if (updatedCount != usersWithoutConsent) {\n            throw new ValidationException(\n                String.format("Expected to update %d users but actually updated %d", \n                             usersWithoutConsent, updatedCount));\n        }\n        \n        if (stillWithoutConsent > 0) {\n            logger.warn("Some users still without consent after migration: {}", stillWithoutConsent);\n        }\n        \n        // Compliance reporting\n        gdprService.reportConsentUpdate(updatedCount, "system-migration");\n    }\n    \n    @RollbackExecution\n    public void rollback(MongoDatabase complianceDb, GdprService gdprService) {\n        MongoCollection<Document> userConsents = complianceDb.getCollection("user_consents");\n        \n        // Rollback only system-generated consent entries\n        UpdateResult result = userConsents.updateMany(\n            eq("consentSource", "system-migration"),\n            combine(\n                unset("gdprConsent"),\n                unset("consentUpdatedDate"),\n                unset("consentSource")\n            )\n        );\n        \n        logger.info("Rolled back GDPR consent for {} users", result.getModifiedCount());\n        gdprService.reportConsentRollback(result.getModifiedCount(), "system-migration");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"anti-patterns-to-avoid",children:"Anti-Patterns to Avoid"}),"\n",(0,a.jsx)(n.h3,{id:"-anti-pattern-1-silent-failures",children:"\u274c Anti-Pattern 1: Silent Failures"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// DON\'T DO THIS\n@Execution\npublic void execute(ExternalService service) {\n    try {\n        service.updateData(data);\n    } catch (Exception e) {\n        // Silent failure - no one knows this failed!\n        logger.debug("Update failed: {}", e.getMessage());\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-better-approach",children:"\u2705 Better Approach:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Execution  \npublic void execute(ExternalService service) {\n    try {\n        service.updateData(data);\n    } catch (ServiceUnavailableException e) {\n        logger.error("Service temporarily unavailable: {}", e.getMessage());\n        throw new RetryableException("External service unavailable", e);\n    } catch (ValidationException e) {\n        logger.error("Data validation failed: {}", e.getMessage());\n        throw new PermanentException("Invalid data provided", e);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-anti-pattern-2-mixing-transactional-and-non-transactional",children:"\u274c Anti-Pattern 2: Mixing Transactional and Non-Transactional"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// DON\'T DO THIS\n@ChangeUnit(transactional = true)  // This won\'t work for Kafka!\npublic class MixedOperations {\n    @Execution\n    public void execute(MongoDatabase db, KafkaTemplate kafka) {\n        db.getCollection("users").updateMany(...);  // Transactional\n        kafka.send("user-topic", event);            // Non-transactional\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-better-approach-1",children:"\u2705 Better Approach:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Separate concerns\n@TargetSystem("user-database")\n@ChangeUnit(id = "update-users", transactional = true)\npublic class UpdateUsers { }\n\n@TargetSystem("event-stream")  \n@ChangeUnit(id = "publish-events", transactional = false)\npublic class PublishEvents { }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-anti-pattern-3-assuming-success",children:"\u274c Anti-Pattern 3: Assuming Success"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// DON'T DO THIS\n@Execution\npublic void execute(List<ExternalService> services) {\n    for (ExternalService service : services) {\n        service.update();  // What if some succeed and others fail?\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"-better-approach-2",children:"\u2705 Better Approach:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Execution\npublic void execute(List<ExternalService> services) {\n    List<String> successfulServices = new ArrayList<>();\n    \n    try {\n        for (ExternalService service : services) {\n            service.update();\n            successfulServices.add(service.getId());\n        }\n    } catch (Exception e) {\n        // Store partial progress for rollback\n        storeProgress(successfulServices);\n        throw e;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsx)(n.h3,{id:"design-for-production",children:(0,a.jsx)(n.strong,{children:"Design for Production"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Assume failures will happen"})," - design changes to handle partial completion"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Make operations idempotent"})," when possible to enable safe retry"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validate inputs and outputs"})," to catch issues early"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Log extensively"})," for troubleshooting and audit purposes"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"choose-the-right-strategy",children:(0,a.jsx)(n.strong,{children:"Choose the Right Strategy"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"MANUAL_INTERVENTION"})," for critical, non-idempotent operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ALWAYS_RETRY"})," for idempotent, low-risk operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Document your reasoning"})," for recovery strategy decisions"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"implement-proper-rollback",children:(0,a.jsx)(n.strong,{children:"Implement Proper Rollback"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Always provide @RollbackExecution"})," methods"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Test rollback logic"})," as thoroughly as execution logic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle partial failures"})," in rollback scenarios"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Log rollback operations"})," for audit trails"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"monitor-and-alert",children:(0,a.jsx)(n.strong,{children:"Monitor and Alert"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Set up monitoring"})," for change execution patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Create alerts"})," for failure conditions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Establish SLAs"})," for issue resolution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Review patterns"})," regularly to improve safety"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Remember"}),": Safety patterns are not just about preventing failures - they're about building confidence in your system evolution process and enabling your team to move fast while maintaining enterprise-grade reliability."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);