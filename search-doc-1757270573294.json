{"searchDocs":[{"title":"DynamoDB Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/dynamodb-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum setup‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#minimum-setup","content":" To use DynamoDB as your audit store you need to provide:  A DynamoDbClient  That's all. Flamingock will take care of tables, indexes, and capacity defaults.  Example:  public class App { public static void main(String[] args) { DynamoDbClient client = DynamoDbClient.builder() .region(Region.US_EAST_1) .build(); Flamingock.builder() .setAuditStore(new DynamoSyncAuditStore() .withClient(client)) .build() .run(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#dependencies","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#required-dependencies","content":" Dependency\tMethod\tDescriptionDynamoDbClient\t.withClient(client)\tAWS DynamoDB client - required  ","version":"1.0.0","tagName":"h3"},{"title":"Reusing target system dependencies‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#reusing-target-system-dependencies","content":" If you're already using a DynamoDB target system, you can reuse its dependencies to avoid duplicating connection configuration:  // Reuse dependencies from existing target system DynamoDBTargetSystem dynamoTargetSystem = new DynamoDBTargetSystem(&quot;inventory-database&quot;) .withDynamoDBClient(dynamoDbClient); // Create audit store reusing the same dependencies DynamoSyncAuditStore auditStore = DynamoSyncAuditStore .reusingDependenciesFrom(dynamoTargetSystem); Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(dynamoTargetSystem) .build() .run();     ","version":"1.0.0","tagName":"h2"},{"title":"Supported versions‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#supported-versions","content":" AWS SDK\tDynamoDB\tSupport leveldynamodb 2.25.29+\tAll versions\tFull support    ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#dependencies-1","content":" GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community&quot;) // AWS SDK (if not already present) implementation(&quot;software.amazon.awssdk:dynamodb:2.28.0&quot;) implementation(&quot;software.amazon.awssdk:dynamodb-enhanced:2.28.0&quot;)     ","version":"1.0.0","tagName":"h2"},{"title":"Configuration options‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#configuration-options","content":" DynamoDB audit store works out of the box with production-ready defaults. Optional properties let you tune behavior if needed:  Property\tDefault\tDescriptiondynamodb.autoCreate\ttrue\tAuto-create tables if they don't exist. dynamodb.readCapacityUnits\t5\tRead capacity units (PROVISIONED mode only). dynamodb.writeCapacityUnits\t5\tWrite capacity units (PROVISIONED mode only). dynamodb.auditRepositoryName\tflamingockAuditLogs\tTable name for audit entries. dynamodb.lockRepositoryName\tflamingockLocks\tTable name for distributed locks.  Example overriding defaults:  Flamingock.builder() .setAuditStore(new DynamoSyncAuditStore() .withClient(client) .withProperty(&quot;dynamodb.readCapacityUnits&quot;, 10) .withProperty(&quot;dynamodb.writeCapacityUnits&quot;, 10)) .build() .run();   ‚ö†Ô∏è Warning: Adjust capacity units based on your workload. Under-provisioning may cause throttling. Consider using ON_DEMAND billing mode for unpredictable workloads.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"DynamoDB Audit Store","url":"/docs/audit-stores/community/dynamodb-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"Couchbase Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/couchbase-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum setup‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#minimum-setup","content":" To use Couchbase as your audit store you need to provide:  A ClusterA Bucket  That's all. Flamingock will take care of collections, indexes, and scope defaults.  Example:  public class App { public static void main(String[] args) { Cluster cluster = Cluster.connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;); Bucket bucket = cluster.bucket(&quot;audit-bucket&quot;); Flamingock.builder() .setAuditStore(new CouchbaseSyncAuditStore() .withCluster(cluster) .withBucket(bucket)) .build() .run(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#dependencies","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#required-dependencies","content":" Dependency\tMethod\tDescriptionCluster\t.withCluster(cluster)\tCouchbase cluster connection - required Bucket\t.withBucket(bucket)\tTarget bucket instance - required  ","version":"1.0.0","tagName":"h3"},{"title":"Reusing target system dependencies‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#reusing-target-system-dependencies","content":" If you're already using a Couchbase target system, you can reuse its dependencies to avoid duplicating connection configuration:  // Reuse dependencies from existing target system CouchbaseTargetSystem couchbaseTargetSystem = new CouchbaseTargetSystem(&quot;user-database&quot;) .withCluster(cluster) .withBucket(bucket); // Create audit store reusing the same dependencies CouchbaseSyncAuditStore auditStore = CouchbaseSyncAuditStore .reusingDependenciesFrom(couchbaseTargetSystem); Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(couchbaseTargetSystem) .build() .run();     ","version":"1.0.0","tagName":"h2"},{"title":"Supported versions‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#supported-versions","content":" Couchbase SDK\tCouchbase Server\tSupport leveljava-client 3.6.0+\t7.0+\tFull support    ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#dependencies-1","content":" GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community&quot;) // Couchbase SDK (if not already present) implementation(&quot;com.couchbase.client:java-client:3.7.0&quot;)     ","version":"1.0.0","tagName":"h2"},{"title":"Configuration options‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#configuration-options","content":" Couchbase audit store works out of the box with production-ready defaults. Optional properties let you tune behavior if needed:  Property\tDefault\tDescriptioncouchbase.autoCreate\ttrue\tAuto-create collections and indexes. couchbase.scopeName\t_default\tScope where audit collections will be created. couchbase.auditRepositoryName\tflamingockAuditLogs\tCollection name for audit entries. couchbase.lockRepositoryName\tflamingockLocks\tCollection name for distributed locks.  Example overriding defaults:  Flamingock.builder() .setAuditStore(new CouchbaseSyncAuditStore() .withCluster(cluster) .withBucket(bucket) .withProperty(&quot;couchbase.scopeName&quot;, &quot;custom-scope&quot;) .withProperty(&quot;couchbase.autoCreate&quot;, true)) .build() .run();   ‚ö†Ô∏è Warning: Ensure your Couchbase user has permissions to create collections if autoCreate is enabled.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Couchbase Audit Store","url":"/docs/audit-stores/community/couchbase-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"MongoDB Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/mongodb-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum setup‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#minimum-setup","content":" To use MongoDB as your audit store you need to provide:  A MongoClientA MongoDatabase  That's all. Flamingock will take care of collections, indexes, and consistency defaults.  Example:  public class App { public static void main(String[] args) { MongoClient client = MongoClients.create(&quot;mongodb://localhost:27017&quot;); MongoDatabase db = client.getDatabase(&quot;flamingock_audit&quot;); Flamingock.builder() .setAuditStore(new MongoSyncAuditStore() .withMongoClient(client) .withDatabase(db)) .build() .run(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#dependencies","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#required-dependencies","content":" Dependency\tMethod\tDescriptionMongoClient\t.withMongoClient(client)\tMongoDB connection client - required MongoDatabase\t.withDatabase(database)\tTarget database instance - required  ","version":"1.0.0","tagName":"h3"},{"title":"Optional configurations‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#optional-configurations","content":" Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads  ","version":"1.0.0","tagName":"h3"},{"title":"Reusing target system dependencies‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#reusing-target-system-dependencies","content":" If you're already using a MongoDB target system, you can reuse its dependencies to avoid duplicating connection configuration:  // Reuse dependencies from existing target system MongoSyncTargetSystem mongoTargetSystem = new MongoSyncTargetSystem(&quot;user-database&quot;) .withMongoClient(client) .withDatabase(userDatabase); // Create audit store reusing the same dependencies MongoSyncAuditStore auditStore = MongoSyncAuditStore .reusingDependenciesFrom(mongoTargetSystem); Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(mongoTargetSystem) .build() .run();   You can still override specific settings if needed:  MongoSyncAuditStore auditStore = MongoSyncAuditStore .reusingDependenciesFrom(mongoTargetSystem) .withReadConcern(ReadConcern.LOCAL);     ","version":"1.0.0","tagName":"h2"},{"title":"Supported versions‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#supported-versions","content":" MongoDB Driver\tMongoDB Server\tSupport levelmongodb-driver-sync 4.0‚Äì5.x\t3.6 ‚Äì 7.0\tFull support mongodb-driver-sync 3.12.x\t3.4 ‚Äì 4.4\tLegacy support    ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#dependencies-1","content":" GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community&quot;) // MongoDB driver (if not already present) implementation(&quot;org.mongodb:mongodb-driver-sync:5.2.0&quot;)     ","version":"1.0.0","tagName":"h2"},{"title":"Configuration options‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#configuration-options","content":" MongoDB audit store works out of the box with production-ready defaults. Optional properties let you tune behavior if needed:  Property\tDefault\tDescriptionmongodb.autoCreate\ttrue\tAuto-create collections and indexes. mongodb.readConcern\tMAJORITY\tRead isolation level. mongodb.writeConcern.w\tMAJORITY\tWrite acknowledgment level. mongodb.writeConcern.journal\ttrue\tRequires journal commit for durability. mongodb.writeConcern.wTimeout\t1s\tMax wait time for write concern fulfillment. mongodb.readPreference\tPRIMARY\tNode selection for reads. mongodb.auditRepositoryName\tflamingockAuditLogs\tCollection name for audit entries. mongodb.lockRepositoryName\tflamingockLocks\tCollection name for distributed locks.  Example overriding defaults:  Flamingock.builder() .setAuditStore(new MongoSyncAuditStore() .withClient(client) .withDatabase(db) .withProperty(&quot;mongodb.readConcern&quot;, &quot;LOCAL&quot;) .withProperty(&quot;mongodb.writeConcern.w&quot;, 1)) .build() .run();   ‚ö†Ô∏è Warning: lowering concerns (e.g. LOCAL, w=1) increases performance but reduces safety. Recommended only for dev/test environments.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Audit Store","url":"/docs/audit-stores/community/mongodb-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"Audit stores","type":0,"sectionRef":"#","url":"/docs/audit-stores/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"What is the audit store?‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#what-is-the-audit-store","content":" The audit store tracks:  Execution history: Which ChangeUnits ran, when, and with what outcomeDistributed locking: Prevents concurrent executions across multiple instancesIssue tracking: Failed or uncertain executions requiring resolution  Unlike target systems (which your code modifies), the audit store is managed automatically by Flamingock and never modified by your ChangeUnits.  Conceptual overview: For architectural understanding, see Target systems vs audit store  ","version":"1.0.0","tagName":"h2"},{"title":"Cloud Edition‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#cloud-edition","content":" No configuration needed - Flamingock Cloud provides a fully managed audit store with superior synchronization, recovery mechanisms, real-time dashboards, and multi-environment governance.  ","version":"1.0.0","tagName":"h2"},{"title":"Community Edition‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#community-edition","content":" With Community Edition, you provide and configure your own audit store. Flamingock supports several databases:  MongoDB audit storeMongoDB Spring Data audit storeDynamoDB audit storeCouchbase audit store  ","version":"1.0.0","tagName":"h2"},{"title":"Community Audit Stores general configuration pattern‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#community-audit-stores-general-configuration-pattern","content":" In Community Audit Stores, you register the audit store with the Flamingock builder:  // Generic example - audit store configuration public class App { public static void main(String[] args) { // Create your audit store connection AuditStore auditStore = new MongoSyncAuditStore(mongoClient, mongoDatabase); // Register with Flamingock FlamingockStandalone .setAuditStore(auditStore) // Set the audit store .addTargetSystems(myTargetSystem) .build() .run(); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Spring Boot configuration‚Äã","type":1,"pageTitle":"Audit stores","url":"/docs/audit-stores/introduction#spring-boot-configuration","content":" @Bean public AuditStore auditStore(MongoClient mongoClient) { return new MongoSyncAuditStore(mongoClient, &quot;flamingock-audit&quot;); } // Flamingock Spring Boot auto-configuration will pick this up automatically     Key takeaway: The audit store is critical for Flamingock's safety guarantees. Cloud Edition provides this fully managed, while Community Audit Stores requires you to configure one of the supported databases. ","version":"1.0.0","tagName":"h3"},{"title":"MongoDB Spring Data Audit Store","type":0,"sectionRef":"#","url":"/docs/audit-stores/community/mongodb-springdata-audit-store","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum setup‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#minimum-setup","content":" To use MongoDB Spring Data as your audit store you need to provide:  A MongoTemplate  That's all. Flamingock will take care of collections, indexes, and consistency defaults.  Example:  public class App { public static void main(String[] args) { // Assuming MongoTemplate is configured via Spring MongoTemplate mongoTemplate = // ... from Spring context Flamingock.builder() .setAuditStore(new MongoSpringDataAuditStore() .withMongoTemplate(mongoTemplate)) .build() .run(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#dependencies","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#required-dependencies","content":" Dependency\tMethod\tDescriptionMongoTemplate\t.withMongoTemplate(template)\tSpring Data MongoDB template - required  ","version":"1.0.0","tagName":"h3"},{"title":"Optional configurations‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#optional-configurations","content":" Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads  ","version":"1.0.0","tagName":"h3"},{"title":"Reusing target system dependencies‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#reusing-target-system-dependencies","content":" If you're already using a MongoDB Spring Data target system, you can reuse its dependencies to avoid duplicating connection configuration:  // Reuse dependencies from existing target system MongoSpringDataTargetSystem mongoTargetSystem = new MongoSpringDataTargetSystem(&quot;user-database&quot;) .withMongoTemplate(mongoTemplate); // Create audit store reusing the same dependencies MongoSpringDataAuditStore auditStore = MongoSpringDataAuditStore .reusingDependenciesFrom(mongoTargetSystem); Flamingock.builder() .setAuditStore(auditStore) .addTargetSystems(mongoTargetSystem) .build() .run();   You can still override specific settings if needed:  MongoSpringDataAuditStore auditStore = MongoSpringDataAuditStore .reusingDependenciesFrom(mongoTargetSystem) .withReadConcern(ReadConcern.LOCAL);     ","version":"1.0.0","tagName":"h2"},{"title":"Supported versions‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#supported-versions","content":" Flamingock provides two editions for different Spring Data MongoDB versions:  Edition\tSpring Data MongoDB\tJDK Required\tSupport levelflamingock-community (standard)\t4.0.0 - 5.x\t17+\tFull support flamingock-community (with legacy flag)\t3.1.4 - 3.x\t8-11\tLegacy support  Choose the edition that matches your Spring Data MongoDB and JDK version.    ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#dependencies-1","content":" GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community&quot;) // Spring Data MongoDB (if not already present) implementation(&quot;org.springframework.boot:spring-boot-starter-data-mongodb&quot;)     ","version":"1.0.0","tagName":"h2"},{"title":"Configuration options‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#configuration-options","content":" MongoDB Spring Data audit store works out of the box with production-ready defaults. Optional properties let you tune behavior if needed:  Property\tDefault\tDescriptionmongodb.autoCreate\ttrue\tAuto-create collections and indexes. mongodb.readConcern\tMAJORITY\tRead isolation level. mongodb.writeConcern.w\tMAJORITY\tWrite acknowledgment level. mongodb.writeConcern.journal\ttrue\tRequires journal commit for durability. mongodb.writeConcern.wTimeout\t1s\tMax wait time for write concern fulfillment. mongodb.readPreference\tPRIMARY\tNode selection for reads. mongodb.auditRepositoryName\tflamingockAuditLogs\tCollection name for audit entries. mongodb.lockRepositoryName\tflamingockLocks\tCollection name for distributed locks.  Example with Spring Boot configuration:  # application.yml flamingock: mongodb: autoCreate: true readConcern: MAJORITY writeConcern: w: MAJORITY journal: true wTimeout: 1s   Or programmatically:  Flamingock.builder() .setAuditStore(new MongoSpringDataAuditStore() .withMongoTemplate(mongoTemplate) .withProperty(&quot;mongodb.readConcern&quot;, &quot;LOCAL&quot;) .withProperty(&quot;mongodb.writeConcern.w&quot;, 1)) .build() .run();   ‚ö†Ô∏è Warning: lowering concerns (e.g. LOCAL, w=1) increases performance but reduces safety. Recommended only for dev/test environments.    ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot integration‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#spring-boot-integration","content":" For Spring Boot applications, use @EnableFlamingock for automatic configuration:  @EnableFlamingock @SpringBootApplication public class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } }   Spring Boot will automatically:  Detect and use your configured MongoTemplateApply configuration from application.ymlSet up the audit store    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Spring Data Audit Store","url":"/docs/audit-stores/community/mongodb-springdata-audit-store#next-steps","content":" Learn about Target systemsüëâ See a full example project ","version":"1.0.0","tagName":"h2"},{"title":"ChangeUnit Anatomy & Structure","type":0,"sectionRef":"#","url":"/docs/change-units/anatomy-and-structure","content":"","keywords":"","version":"1.0.0"},{"title":"Required properties‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#required-properties","content":" Every ChangeUnit must define these three properties:  ","version":"1.0.0","tagName":"h2"},{"title":"id - Unique identifier‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#id---unique-identifier","content":" The id must be unique across all ChangeUnits in your application.  @ChangeUnit(id = &quot;add-user-status&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;)   Rules:  Must be unique application-wideUse descriptive names (e.g., add-user-status, not change1)Cannot be modified once deployed  ","version":"1.0.0","tagName":"h3"},{"title":"order - Execution sequence‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#order---execution-sequence","content":" The order determines when the ChangeUnit executes relative to others.  @ChangeUnit(id = &quot;create-indexes&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;) @ChangeUnit(id = &quot;migrate-data&quot;, order = &quot;0002&quot;, author = &quot;dev-team&quot;) @ChangeUnit(id = &quot;cleanup-temp-data&quot;, order = &quot;0003&quot;, author = &quot;dev-team&quot;)   Requirements:  Must use zero-padded format: 0001, 0002, 0100, etc.Minimum 4 digits recommended for future expansionDetermines execution order across all target systemsCannot be changed once deployed  ","version":"1.0.0","tagName":"h3"},{"title":"author - Responsibility tracking‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#author---responsibility-tracking","content":" Identifies who is responsible for this change.  @ChangeUnit(id = &quot;update-schema&quot;, order = &quot;0001&quot;, author = &quot;database-team&quot;) @ChangeUnit(id = &quot;migrate-users&quot;, order = &quot;0002&quot;, author = &quot;john.doe@company.com&quot;)   Best practices:  Use team names for shared responsibility: database-team, api-teamUse individual emails for personal changes: john.doe@company.comKeep consistent within your organization  ","version":"1.0.0","tagName":"h3"},{"title":"Optional properties‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#optional-properties","content":" ","version":"1.0.0","tagName":"h2"},{"title":"description - Change explanation‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#description---change-explanation","content":" Briefly describes what the change does, especially useful for complex operations.  @ChangeUnit( id = &quot;optimize-user-queries&quot;, order = &quot;0001&quot;, author = &quot;performance-team&quot;, description = &quot;Add composite index on user table to improve search performance&quot; )   ","version":"1.0.0","tagName":"h3"},{"title":"transactional - Transaction behavior‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#transactional---transaction-behavior","content":" Controls whether the change runs within a transaction (default: true).  @ChangeUnit( id = &quot;create-large-index&quot;, order = &quot;0001&quot;, author = &quot;db-team&quot;, transactional = false // DDL operations may require this )   When to set transactional = false:  DDL operations (CREATE INDEX, ALTER TABLE)Large bulk operations that exceed transaction limitsCross-system changes spanning multiple databasesOperations that don't support transactions  Important: For non-transactional target systems (S3, Kafka, etc.), this flag has no effect.  ","version":"1.0.0","tagName":"h3"},{"title":"Required annotations‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#required-annotations","content":" ","version":"1.0.0","tagName":"h2"},{"title":"@TargetSystem - System specification‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#targetsystem---system-specification","content":" Declares which target system this ChangeUnit affects.  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;add-user-fields&quot;, order = &quot;0001&quot;, author = &quot;api-team&quot;) public class _0001_AddUserFields { // Implementation }   ","version":"1.0.0","tagName":"h3"},{"title":"@ChangeUnit - Class marker‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#changeunit---class-marker","content":" Marks the class as a ChangeUnit and contains all metadata.  @ChangeUnit( id = &quot;migrate-user-data&quot;, order = &quot;0001&quot;, author = &quot;migration-team&quot;, description = &quot;Migrate legacy user format to new schema&quot;, transactional = true )   ","version":"1.0.0","tagName":"h3"},{"title":"Required methods‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#required-methods","content":" ","version":"1.0.0","tagName":"h2"},{"title":"@Execution - Change logic‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#execution---change-logic","content":" Contains the actual change implementation.  @Execution public void execute(MongoDatabase database, ClientSession session) { // Your change logic here database.getCollection(&quot;users&quot;) .insertOne(session, new Document(&quot;status&quot;, &quot;active&quot;)); }   Method characteristics:  Must be publicCan have any name (execute, run, apply, etc.)Parameters are dependency-injected by FlamingockShould contain idempotent operations when possible  ","version":"1.0.0","tagName":"h3"},{"title":"@RollbackExecution - Undo logic‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#rollbackexecution---undo-logic","content":" Provides logic to reverse the change, essential for safety and CLI undo operations.  @RollbackExecution public void rollback(MongoDatabase database, ClientSession session) { // Undo the change database.getCollection(&quot;users&quot;) .deleteMany(new Document(&quot;status&quot;, &quot;active&quot;)); }   Why rollback is required:  Non-transactional systems: Used automatically if execution failsAll systems: Required for CLI/UI undo operationsSafety: Ensures every change can be reversedGovernance: Demonstrates you've thought through the change impact  ","version":"1.0.0","tagName":"h3"},{"title":"Method parameters and dependency injection‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#method-parameters-and-dependency-injection","content":" ChangeUnits receive dependencies through method parameters, automatically injected by Flamingock from the target system's context, global context, or underlying framework context.  // MongoDB target system @Execution public void execute(MongoDatabase database, ClientSession session) { // database and session injected from target system or global context } // SQL target system @Execution public void execute(DataSource dataSource) { // dataSource and connection injected from target system or global context }   For more details on how dependency resolution works, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"File naming conventions‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#file-naming-conventions","content":" All ChangeUnit files must follow the _XXXX_DescriptiveName pattern:  _0001_CreateUserIndexes.java _0002_MigrateUserData.java _0003_AddUserStatusColumn.yml _0100_OptimizeQueries.java   Rules:  Start with underscore and zero-padded orderUse PascalCase for descriptive namesMatch the order property in the annotationApplies to both code (.java/.kt/.groovy) and template (.yml/.json) files  ","version":"1.0.0","tagName":"h2"},{"title":"Complete example‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#complete-example","content":" Here's a complete ChangeUnit showing all elements:  @TargetSystem(&quot;user-database&quot;) @ChangeUnit( id = &quot;add-user-preferences&quot;, order = &quot;0001&quot;, author = &quot;user-experience-team&quot;, description = &quot;Add preferences object to user documents with default values&quot;, transactional = true ) public class _0001_AddUserPreferences { @Execution public void execute(MongoDatabase database, ClientSession session) { // Add preferences field with default values Document defaultPreferences = new Document() .append(&quot;notifications&quot;, true) .append(&quot;theme&quot;, &quot;light&quot;) .append(&quot;language&quot;, &quot;en&quot;); database.getCollection(&quot;users&quot;) .updateMany( session, new Document(&quot;preferences&quot;, new Document(&quot;$exists&quot;, false)), new Document(&quot;$set&quot;, new Document(&quot;preferences&quot;, defaultPreferences)) ); } @RollbackExecution public void rollback(MongoDatabase database, ClientSession session) { // Remove the preferences field database.getCollection(&quot;users&quot;) .updateMany( session, new Document(), new Document(&quot;$unset&quot;, new Document(&quot;preferences&quot;, &quot;&quot;)) ); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"ChangeUnit Anatomy & Structure","url":"/docs/change-units/anatomy-and-structure#next-steps","content":" ChangeUnit types &amp; Implementation - Deep dive into code-based vs template-based approachesChangeUnit best Practices - Learn proven patterns for reliable ChangeUnitsTarget Systems - Configure where your changes will be applied ","version":"1.0.0","tagName":"h2"},{"title":"ChangeUnits","type":0,"sectionRef":"#","url":"/docs/change-units/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Key characteristics‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#key-characteristics","content":" Atomic execution: Each ChangeUnit runs exactly onceOrdered sequence: Executed based on their order propertyAuditable: Recorded in the audit store to prevent duplicate executionSafe by default: If Flamingock is uncertain about a change's outcome, it stops and requires manual interventionRollback capable: Can be undone through rollback methods  ","version":"1.0.0","tagName":"h2"},{"title":"What ChangeUnits can do‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#what-changeunits-can-do","content":" ChangeUnits enable you to version and track changes across your entire technology stack:  Message queue operations: Topic creation, schema registry updatesObject storage: Bucket setup, file migrations, policy updatesDatabase migrations: Schema changes, data transformations, index creationExternal API integrations: Service configurations, webhook setupsInfrastructure changes: Feature flag updates, configuration changes  ","version":"1.0.0","tagName":"h2"},{"title":"Types of ChangeUnits‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#types-of-changeunits","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Code-based ChangeUnits‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#code-based-changeunits","content":" Written in Java, Kotlin, or Groovy with annotations. Best for complex logic or when you need full programmatic control.  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;add-user-status&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;) public class _0001_AddUserStatus { @Execution public void execute(MongoDatabase database) { // Your change logic here } @RollbackExecution public void rollback(MongoDatabase database) { // Your rollback logic here } }   ","version":"1.0.0","tagName":"h3"},{"title":"Template-based ChangeUnits‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#template-based-changeunits","content":" Use YAML or JSON definitions with reusable templates. Perfect for repetitive operations and standardized patterns.  # File: _0002_add_status_column.yml id: add_status_column order: &quot;0002&quot; author: &quot;db-team&quot; templateName: sql-template templateConfiguration: executionSql: &quot;ALTER TABLE orders ADD COLUMN status VARCHAR(20);&quot; rollbackSql: &quot;ALTER TABLE orders DROP COLUMN status;&quot;   ","version":"1.0.0","tagName":"h3"},{"title":"Safety and recovery‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#safety-and-recovery","content":" Flamingock prioritizes safety over automation. If execution fails or results are uncertain, Flamingock stops and requires manual intervention rather than risking data corruption. This ensures you always know the exact state of your systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"ChangeUnits","url":"/docs/change-units/introduction#next-steps","content":" Dive deeper into specific aspects of ChangeUnits:  Anatomy &amp; Structure - Learn the technical structure, required properties, and annotationsTypes &amp; Implementation - Understand code-based vs template-based approachesBest Practices - Follow proven patterns for reliable ChangeUnits  Or continue to other key concepts:  Target Systems - Configure where your changes will be appliedTemplates - Explore reusable change patterns ","version":"1.0.0","tagName":"h2"},{"title":"ChangeUnit Types & Implementation","type":0,"sectionRef":"#","url":"/docs/change-units/types-and-implementation","content":"","keywords":"","version":"1.0.0"},{"title":"Code-based ChangeUnits‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#code-based-changeunits","content":" Code-based ChangeUnits are written in Java, Kotlin, or Groovy with annotations. They provide full programmatic control for custom logic or specific operations that don't fit existing templates.  ","version":"1.0.0","tagName":"h2"},{"title":"Basic structure‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#basic-structure","content":" @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;migrate-user-emails&quot;, order = &quot;0001&quot;, author = &quot;data-team&quot;) public class _0001_MigrateUserEmails { @Execution public void execute(MongoDatabase database, ClientSession session) { // Custom implementation logic with full programmatic control MongoCollection&lt;Document&gt; users = database.getCollection(&quot;users&quot;); users.updateMany(session, new Document(&quot;email&quot;, new Document(&quot;$exists&quot;, true)), new Document(&quot;$set&quot;, new Document(&quot;emailVerified&quot;, false))); } @RollbackExecution public void rollback(MongoDatabase database, ClientSession session) { // Rollback logic database.getCollection(&quot;users&quot;) .updateMany(session, new Document(), new Document(&quot;$unset&quot;, new Document(&quot;emailVerified&quot;, &quot;&quot;))); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Template-based ChangeUnits‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#template-based-changeunits","content":" Template-based ChangeUnits use YAML or JSON files with reusable templates. Templates provide a low-code, declarative approach for common patterns and repetitive operations. Templates can be as powerful and complex as code-based ChangeUnits - the difference is that templates are developed for reusable patterns and integrations.  ","version":"1.0.0","tagName":"h2"},{"title":"Basic YAML structure‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#basic-yaml-structure","content":" # File: _0001_add_user_index.yml id: add_user_index order: &quot;0001&quot; author: &quot;database-team&quot; description: &quot;Add index on user email field for faster lookups&quot; templateName: mongodb-index templateConfiguration: collection: users indexSpec: email: 1 options: unique: true name: &quot;idx_user_email&quot;   For more details about available templates and creating custom templates, see Templates.  ","version":"1.0.0","tagName":"h3"},{"title":"File organization‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#file-organization","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Recommended project structure:‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#recommended-project-structure","content":" src/main/java/com/yourapp/changes/ ‚îú‚îÄ‚îÄ _0001_CreateUserIndexes.java ‚îú‚îÄ‚îÄ _0002_add_user_status.yml ‚îú‚îÄ‚îÄ _0003_MigrateUserData.java ‚îú‚îÄ‚îÄ _0004_setup_notifications.yml ‚îî‚îÄ‚îÄ _0005_OptimizeQueries.java   ","version":"1.0.0","tagName":"h3"},{"title":"Best practices:‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#best-practices","content":" Keep together: Store both code and template files in the same directoryConsistent naming: Follow _XXXX_DescriptiveName pattern for both types  ","version":"1.0.0","tagName":"h3"},{"title":"Template development‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#template-development","content":" Flamingock and the community provide useful templates for common operations. Organizations can also develop their own templates to standardize patterns and integrations specific to their needs.  For more information about available templates and how to create custom templates, see Templates.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"ChangeUnit Types & Implementation","url":"/docs/change-units/types-and-implementation#next-steps","content":" Best Practices - Learn proven patterns for reliable ChangeUnitsTemplates - Explore available templates and create custom onesTarget Systems - Configure where your changes will be applied ","version":"1.0.0","tagName":"h2"},{"title":"ChangeUnit Best Practices","type":0,"sectionRef":"#","url":"/docs/change-units/best-practices","content":"","keywords":"","version":"1.0.0"},{"title":"Core principles‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#core-principles","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Treat ChangeUnits as immutable‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#treat-changeunits-as-immutable","content":" Once a ChangeUnit is deployed, never modify it. Create new ChangeUnits for corrections.  ‚ùå Don't do this:  // Modifying an existing ChangeUnit after deployment @ChangeUnit(id = &quot;add-user-field&quot;, order = &quot;0001&quot;, author = &quot;team&quot;) public class _0001_AddUserField { @Execution public void execute(MongoDatabase db) { // Original: db.getCollection(&quot;users&quot;).updateMany(/* add field */) // Modified: db.getCollection(&quot;users&quot;).updateMany(/* different logic */) } }   ‚úÖ Do this instead:  // Keep the original unchanged @ChangeUnit(id = &quot;add-user-field&quot;, order = &quot;0001&quot;, author = &quot;team&quot;) public class _0001_AddUserField { @Execution public void execute(MongoDatabase db) { // Original logic remains unchanged } } // Create a new ChangeUnit for corrections @ChangeUnit(id = &quot;fix-user-field-values&quot;, order = &quot;0002&quot;, author = &quot;team&quot;) public class _0002_FixUserFieldValues { @Execution public void execute(MongoDatabase db) { // Correction logic } }   ","version":"1.0.0","tagName":"h3"},{"title":"Always provide rollback logic‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#always-provide-rollback-logic","content":" Every ChangeUnit must have a @RollbackExecution method, regardless of target system type.  Why rollback matters:  Non-transactional systems: Automatic cleanup on failureAll systems: CLI/UI undo operationsSafety: Proves you understand the change impactGovernance: Required for audit compliance  Example with comprehensive rollback:  @ChangeUnit(id = &quot;setup-user-indexes&quot;, order = &quot;0001&quot;, author = &quot;db-team&quot;) public class _0001_SetupUserIndexes { @Execution public void execute(MongoDatabase database) { MongoCollection&lt;Document&gt; users = database.getCollection(&quot;users&quot;); // Create compound index for user queries users.createIndex( new Document(&quot;email&quot;, 1).append(&quot;status&quot;, 1), new IndexOptions().name(&quot;idx_user_email_status&quot;).unique(false) ); // Create text index for search users.createIndex( new Document(&quot;firstName&quot;, &quot;text&quot;).append(&quot;lastName&quot;, &quot;text&quot;), new IndexOptions().name(&quot;idx_user_search&quot;) ); } @RollbackExecution public void rollback(MongoDatabase database) { MongoCollection&lt;Document&gt; users = database.getCollection(&quot;users&quot;); // Drop indexes in reverse order try { users.dropIndex(&quot;idx_user_search&quot;); } catch (Exception e) { // Index might not exist - log but continue } try { users.dropIndex(&quot;idx_user_email_status&quot;); } catch (Exception e) { // Index might not exist - log but continue } } }   ","version":"1.0.0","tagName":"h3"},{"title":"Keep scope focused‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#keep-scope-focused","content":" Each ChangeUnit should address one logical change. Avoid combining unrelated operations.  ‚ùå Avoid mixing concerns:  @ChangeUnit(id = &quot;big-refactor&quot;, order = &quot;0001&quot;, author = &quot;team&quot;) public class _0001_BigRefactor { @Execution public void execute(MongoDatabase db, KafkaProducer producer) { // Adding user field db.getCollection(&quot;users&quot;).updateMany(/* ... */); // Creating Kafka topic producer.send(/* create topic message */); // Updating configuration db.getCollection(&quot;config&quot;).updateOne(/* ... */); } }   ‚úÖ Separate concerns:  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;add-user-status&quot;, order = &quot;0001&quot;, author = &quot;team&quot;) public class _0001_AddUserStatus { // Focus: User schema change only } @TargetSystem(&quot;kafka-events&quot;) @ChangeUnit(id = &quot;create-user-topic&quot;, order = &quot;0001&quot;, author = &quot;team&quot;) public class _0001_CreateUserTopic { // Focus: Kafka topic creation only }   ","version":"1.0.0","tagName":"h3"},{"title":"Technical guidelines‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#technical-guidelines","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Design for idempotency‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#design-for-idempotency","content":" Make operations safe to re-run whenever possible.  Example: Idempotent field addition:  @ChangeUnit(id = &quot;add-user-preferences&quot;, order = &quot;0001&quot;, author = &quot;team&quot;) public class _0001_AddUserPreferences { @Execution public void execute(MongoDatabase database) { // Only update users that don't already have preferences database.getCollection(&quot;users&quot;).updateMany( new Document(&quot;preferences&quot;, new Document(&quot;$exists&quot;, false)), new Document(&quot;$set&quot;, new Document(&quot;preferences&quot;, getDefaultPreferences())) ); } private Document getDefaultPreferences() { return new Document() .append(&quot;theme&quot;, &quot;light&quot;) .append(&quot;notifications&quot;, true); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Handle errors gracefully‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#handle-errors-gracefully","content":" Don't catch exceptions unless you have specific recovery logic. Let Flamingock handle error management.  ‚ùå Don't suppress errors:  @Execution public void execute(MongoDatabase database) { try { // Some operation database.getCollection(&quot;users&quot;).updateMany(/* ... */); } catch (Exception e) { // Silently ignoring errors prevents proper error handling System.out.println(&quot;Error occurred: &quot; + e.getMessage()); } }   ‚úÖ Let exceptions bubble up:  @Execution public void execute(MongoDatabase database) { // Let Flamingock handle exceptions and recovery database.getCollection(&quot;users&quot;).updateMany(/* ... */); }   ","version":"1.0.0","tagName":"h3"},{"title":"Use meaningful method names‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#use-meaningful-method-names","content":" Method names should clearly indicate their purpose.  Good examples:  @Execution public void migrateUserProfilesToNewSchema(MongoDatabase db) { } @Execution public void addEmailIndexForFasterLookups(MongoDatabase db) { } @RollbackExecution public void removeEmailIndexAndRevertSchema(MongoDatabase db) { }   ","version":"1.0.0","tagName":"h3"},{"title":"Avoid domain objects‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#avoid-domain-objects","content":" Don't use domain objects in ChangeUnits. Since ChangeUnits are immutable and your domain evolves, using domain classes can cause compilation errors when fields are removed or modified in newer versions. Instead, work with primitive types, collections, or framework-native objects like Document for MongoDB.  ","version":"1.0.0","tagName":"h3"},{"title":"Naming and organization‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#naming-and-organization","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Follow consistent naming patterns‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#follow-consistent-naming-patterns","content":" File names:  Use _XXXX_DescriptiveName formatMatch the order in @ChangeUnit annotationUse PascalCase for class names  Good examples:  _0001_CreateUserIndexes.java _0002_MigrateUserData.java _0003_AddUserPreferences.java _0100_OptimizeUserQueries.java   ","version":"1.0.0","tagName":"h3"},{"title":"Use descriptive IDs and descriptions‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#use-descriptive-ids-and-descriptions","content":" Make your ChangeUnits self-documenting:  @ChangeUnit( id = &quot;migrate-legacy-user-format-to-v2&quot;, order = &quot;0001&quot;, author = &quot;data-migration-team&quot;, description = &quot;Migrate user documents from legacy format to v2 schema with new preference structure&quot; )   ","version":"1.0.0","tagName":"h3"},{"title":"Organize by chronological order‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#organize-by-chronological-order","content":" ChangeUnits should be organized chronologically by their order within stages. If you need logical grouping, use stages - but remember that execution order is only guaranteed within a stage, not between stages.  src/main/java/com/company/changes/ ‚îú‚îÄ‚îÄ _0001_CreateUserCollection.java ‚îú‚îÄ‚îÄ _0002_AddUserIndexes.java ‚îú‚îÄ‚îÄ _0003_MigrateUserData.java ‚îú‚îÄ‚îÄ _0004_CreateOrdersTable.java ‚îî‚îÄ‚îÄ _0005_AddOrderStatusColumn.java   ","version":"1.0.0","tagName":"h3"},{"title":"Testing and validation‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#testing-and-validation","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Test both execution and rollback‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#test-both-execution-and-rollback","content":" Create comprehensive tests for your ChangeUnits:  @Test public void testUserMigrationChangeUnit() { // Arrange MongoDatabase testDb = getTestDatabase(); insertTestUsers(testDb); _0001_MigrateUsers changeUnit = new _0001_MigrateUsers(); // Act - Test execution changeUnit.execute(testDb); // Assert - Verify execution results MongoCollection&lt;Document&gt; users = testDb.getCollection(&quot;users&quot;); assertEquals(5, users.countDocuments(new Document(&quot;status&quot;, &quot;active&quot;))); // Act - Test rollback changeUnit.rollback(testDb); // Assert - Verify rollback results assertEquals(0, users.countDocuments(new Document(&quot;status&quot;, new Document(&quot;$exists&quot;, true)))); }   ","version":"1.0.0","tagName":"h3"},{"title":"Validate with real-like data‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#validate-with-real-like-data","content":" Test with data that resembles production:  @Test public void testWithRealisticData() { // Use realistic data volumes and edge cases insertUsers(1000); // Test batch processing insertUsersWithMissingFields(); // Test data inconsistencies insertUsersWithEdgeCaseValues(); // Test boundary conditions // Run your ChangeUnit changeUnit.execute(database); // Verify all scenarios handled correctly }   ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"ChangeUnit Best Practices","url":"/docs/change-units/best-practices#next-steps","content":" Templates - Explore reusable change patternsTarget Systems - Configure where changes are appliedTesting - Comprehensive testing strategies for ChangeUnits ","version":"1.0.0","tagName":"h2"},{"title":"Cloud Edition","type":0,"sectionRef":"#","url":"/docs/cloud-edition","content":"","keywords":"","version":"1.0.0"},{"title":"What the Cloud Edition will offer‚Äã","type":1,"pageTitle":"Cloud Edition","url":"/docs/cloud-edition#what-the-cloud-edition-will-offer","content":" Once released, the Cloud Edition will enable:  Centralized dashboards to track and visualize changes across services and environmentsBuilt-in user and team management with Role-Based Access Control (RBAC)Cross-environment visibility for staging, production, and everything in betweenAdvanced template and extension support for faster integration and reuseGovernance, auditability, and compliance built into every change lifecycleMulti-tenant and multi-service support, ready for real-world deployment complexity  note The Cloud Edition still relies on the Flamingock client library to run within your application.  ","version":"1.0.0","tagName":"h2"},{"title":"What's coming in this section‚Äã","type":1,"pageTitle":"Cloud Edition","url":"/docs/cloud-edition#whats-coming-in-this-section","content":" This section will guide you through:  How to set up your Cloud Edition environmentHow to configure the Flamingock client for Cloud EditionHow to use the dashboard, explore audits, and manage servicesBest practices for working with multi-environment and multi-team setups ","version":"1.0.0","tagName":"h2"},{"title":"Flamingock CLI","type":0,"sectionRef":"#","url":"/docs/cli","content":"","keywords":"","version":"1.0.0"},{"title":"Enterprise Operational Capabilities‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#enterprise-operational-capabilities","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Issue Resolution & Recovery‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#issue-resolution--recovery","content":" The CLI is central to Flamingock's recovery strategy workflow, providing enterprise-grade operational excellence:  Issue Detection: Identify failed or incomplete changes across your distributed systemsGuided Resolution: Get specific guidance for resolving each type of failureAudit Management: Mark changes as resolved after manual verification or correctionCompliance Workflow: Maintain complete audit trails during issue resolution  ","version":"1.0.0","tagName":"h3"},{"title":"Operational Control‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#operational-control","content":" Change Execution: Run changes on-demand without full application startupDry-Run Analysis: Preview pending changes and their execution orderRollback Operations: Safely revert changes using compensation logicLock Management: Clear stale distributed locks from interrupted processes  ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Integration‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#enterprise-integration","content":" CI/CD Pipeline Integration: Embed Flamingock operations in deployment workflowsAutomation Scripts: Script common operational tasks and maintenance proceduresCompliance Reporting: Generate audit reports and change history analysis    ","version":"1.0.0","tagName":"h3"},{"title":"Core CLI Operations‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#core-cli-operations","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Issue Resolution Workflow‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#issue-resolution-workflow","content":" The primary CLI workflow for operational excellence:  # 1. Discover issues requiring attention flamingock issue list # 2. Get the next issue to resolve (automatic prioritization) flamingock issue get # 3. Get specific issue with detailed guidance flamingock issue get -c change-id --guidance # 4. Resolve the issue after manual verification/correction flamingock audit fix -c change-id --resolution APPLIED flamingock audit fix -c change-id --resolution ROLLED_BACK   ","version":"1.0.0","tagName":"h3"},{"title":"Change Execution & Management‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#change-execution--management","content":" Execute Changes: Run pending changes on-demandDry-Run Analysis: Preview execution order and dependencies without applying changesRollback Operations: Safely revert changes using @RollbackExecution methodsAudit Inspection: Query execution history with filtering by author, date, status  ","version":"1.0.0","tagName":"h3"},{"title":"Operational Maintenance‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#operational-maintenance","content":" Lock Management: View and clear distributed locks from interrupted processesConsistency Checks: Validate change definitions against audit log entriesIntegrity Verification: Ensure audit store consistency and detect anomalies  ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Reporting‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#enterprise-reporting","content":" Audit Trails: Generate compliance reports and change history analysisIssue Analytics: Track resolution patterns and operational metricsChange Impact: Analyze cross-system dependencies and execution patterns    ","version":"1.0.0","tagName":"h3"},{"title":"Operational Workflows‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#operational-workflows","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Issue Resolution Workflow‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#issue-resolution-workflow-1","content":" The most common CLI usage pattern for enterprise operations:  # Daily operational workflow flamingock issue list # Output: Shows all unresolved issues across your distributed systems flamingock issue get # Output: Returns next priority issue with detailed context and guidance # After manual investigation and correction: flamingock audit fix -c user-data-update-v2 --resolution APPLIED # Output: ‚úÖ Issue resolved - change marked as successfully applied # Alternative resolution: flamingock audit fix -c problematic-change --resolution ROLLED_BACK # Output: ‚úÖ Issue resolved - change marked as rolled back   ","version":"1.0.0","tagName":"h3"},{"title":"Change Management Operations‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#change-management-operations","content":" # Execute pending changes on-demand flamingock run --app-jar /path/to/app.jar --config application.yaml # Preview what would execute (dry-run) flamingock dry-run --config application.yaml --profile production # Execute specific change by ID flamingock run -c user-schema-update --app-jar /path/to/app.jar # Rollback/undo specific change flamingock undo -c user-schema-update --app-jar /path/to/app.jar   ","version":"1.0.0","tagName":"h3"},{"title":"Audit and Compliance Operations‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#audit-and-compliance-operations","content":" # List all executed changes with filtering flamingock audit list --author platform-team --from 2024-01-01 # Generate compliance report flamingock audit report --format csv --output /reports/compliance-2024.csv # Verify audit store integrity flamingock audit verify --config application.yaml   ","version":"1.0.0","tagName":"h3"},{"title":"Maintenance Operations‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#maintenance-operations","content":" # Clear stale distributed locks flamingock lock clear --config application.yaml # Check consistency between code and audit store flamingock consistency-check --app-jar /path/to/app.jar --config application.yaml     ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Integration Patterns‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#enterprise-integration-patterns","content":" ","version":"1.0.0","tagName":"h2"},{"title":"CI/CD Pipeline Integration‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#cicd-pipeline-integration","content":" # Example: Jenkins/GitHub Actions integration deploy: steps: - name: Execute Flamingock Changes run: | flamingock run --app-jar dist/app.jar --config prod.yaml - name: Verify No Issues run: | flamingock issue list --fail-if-any   ","version":"1.0.0","tagName":"h3"},{"title":"Operational Runbooks‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#operational-runbooks","content":" # Daily operations checklist #!/bin/bash echo &quot;Checking for Flamingock issues...&quot; flamingock issue list if [ $? -ne 0 ]; then echo &quot;Issues detected - resolving...&quot; while flamingock issue get &gt; /dev/null; do echo &quot;Resolve the displayed issue manually, then press Enter&quot; read flamingock issue get -c $(flamingock issue get --format id) --resolution APPLIED done fi   ","version":"1.0.0","tagName":"h3"},{"title":"Emergency Response‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#emergency-response","content":" # Emergency rollback procedure flamingock undo -c problematic-change --app-jar emergency-build.jar flamingock audit fix -c problematic-change --resolution ROLLED_BACK     ","version":"1.0.0","tagName":"h3"},{"title":"Installation & Setup‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#installation--setup","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Download CLI‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#download-cli","content":" # Linux/macOS curl -L https://releases.flamingock.io/cli/latest/flamingock-cli-linux -o flamingock chmod +x flamingock # Windows # Download from: https://releases.flamingock.io/cli/latest/flamingock-cli-windows.exe   ","version":"1.0.0","tagName":"h3"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#configuration","content":" The CLI uses your existing Flamingock configuration files:  application.yaml / application.propertiesflamingock.yaml / flamingock.properties  ","version":"1.0.0","tagName":"h3"},{"title":"JAR Requirements‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#jar-requirements","content":" Supply --app-jar only for commands that execute change logic:  Required: run, undo, rollback commandsNot required: issue, audit, lock commands    ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Support‚Äã","type":1,"pageTitle":"Flamingock CLI","url":"/docs/cli#enterprise-support","content":" The Flamingock CLI is production-ready and provides enterprise-grade operational capabilities for managing distributed system evolution at scale.  Need help? Contact support@flamingock.io for enterprise support and training. ","version":"1.0.0","tagName":"h2"},{"title":"Additional configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/additional-configuration","content":"","keywords":"","version":"1.0.0"},{"title":"Metadata‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#metadata","content":" Flamingock provides a Metadata object - which is a flexible Map&lt;String, Object&gt; that allows you to attach custom information to your Flamingock process.  The metadata is stored as part of the audit log, and can be used for labeling, traceability, and future reporting.  ","version":"1.0.0","tagName":"h2"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#use-cases","content":" You can use metadata to:  Tag executions by team, service, or regionInclude a deployment ID, build number, or triggering userAttach comments or labels for easier traceability  ","version":"1.0.0","tagName":"h3"},{"title":"Example‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#example","content":" YAMLBuilder metadata: owner: platform-team triggeredBy: ci-cd-pipeline notes: initial deployment setup     ","version":"1.0.0","tagName":"h3"},{"title":"Default Author‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#default-author","content":" If a change unit does not specify an author, Flamingock will use this value as the fallback.  Applies to both code-based and template-based changesDefault value: &quot;default_author&quot;Ignored if the change itself defines an explicit author  ","version":"1.0.0","tagName":"h3"},{"title":"Example‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#example-1","content":" YAMLBuilder defaultAuthor: antonio     ","version":"1.0.0","tagName":"h3"},{"title":"Disable flamingock process‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#disable-flamingock-process","content":" This global toggle allows you to enable or disable Flamingock.  If set to false, Flamingock will not runA log message will appear in the application logs, indicating that Flamingock is disabledNo changes will be applied and no audit entries will be created  note Useful in test environments, local runs, or cases where you want to conditionally skip changes.  ","version":"1.0.0","tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Additional configuration","url":"/docs/flamingock-library-config/additional-configuration#example-2","content":" YAMLBuilder enabled: false  ","version":"1.0.0","tagName":"h3"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/events","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#introduction","content":" Flamingock utilizes events to notify the main application about the current state of the Flamingock process, as well as the eventual outcome of its execution.  The event-handling approach differs significantly depending on the type of runner being used:  For Spring-based applications, Flamingock leverages the ApplicationEventPublisher, which is provided during the build process.For standalone applications, Flamingock requires an explicit event handler to be defined at build time.  Flamingock offers event handling capabilities for both Pipelines and Stages.  ","version":"1.0.0","tagName":"h2"},{"title":"Type of events‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#type-of-events","content":" Flamingock emits three types of events:  Start Event: Triggered just before the migration process begins, following successful validation.Success Event: Emitted upon successful completion of the migration. This indicates that no unhandled exceptions occurred, or that any errors were either properly handled or associated changeLogs were marked with 'Fail' as false.Failure Event: Emitted when a change log fails and the failure is not handled, as described above.  warning The Success and Failure events are mutually exclusive, only one of them will be raised for a given migration execution.  ","version":"1.0.0","tagName":"h2"},{"title":"Get started‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#get-started","content":" Each runner's documentation page provides the necessary information for using events in accordance with that runner's specific implementation.  ","version":"1.0.0","tagName":"h2"},{"title":"Standalone basic example‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#standalone-basic-example","content":" In the Flamingock builder, you must configure the events you intend to use and implement the corresponding listeners.  ","version":"1.0.0","tagName":"h2"},{"title":"Builder‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#builder","content":" JavaKotlin FlamingockStandalone.local() .setPipelineStartedListener(new PipelineStartedListener()) .setPipelineCompletedListener(new PipelineCompletedListener()) .setPipelineFailedListener(new PipelineFailedListener()) .setStageStartedListener(new StageStartedListener()) .setStageCompletedListener(new StageCompletedListener()) .setStageFailedListener(new StageFailedListener()) .build() .run();   ","version":"1.0.0","tagName":"h3"},{"title":"Listener‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#listener","content":" JavaKotlin public class StageCompletedListener implements Consumer&lt;IStageCompletedEvent&gt; { public static int executed = 0; @Override public void accept(IStageCompletedEvent iStageCompletedEvent) { executed++; } }   ","version":"1.0.0","tagName":"h3"},{"title":"Spring-based basic example‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#spring-based-basic-example","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Listeners‚Äã","type":1,"pageTitle":"Events","url":"/docs/flamingock-library-config/events#listeners","content":" JavaKotlin @Bean public PipelineStartedListener startFlamingockListener() { return new PipelineStartedListener(); } @Bean public PipelineCompletedListener successFlamingockListener() { return new PipelineCompletedListener(); } @Bean public PipelineFailedListener sailedFlamingockListener() { return new PipelineFailedListener(); } @Bean public StageStartedListener stageStartedListener() {return new StageStartedListener();} @Bean public StageCompletedListener stageCompletedListener() {return new StageCompletedListener();} @Bean public StageFailedListener stageFailedListener() {return new StageFailedListener();}  ","version":"1.0.0","tagName":"h3"},{"title":"Flamingock library configuration","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"What you can configure‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#what-you-can-configure","content":" Area\tDescription\tLink‚≠ê Setup &amp; stages\tOrganize changes into ordered stages - Essential\tSetup &amp; stages ‚≠ê Target systems\tConfigure target systems for your changes - Essential\tTarget systems ‚≠ê Audit store\tConfigure audit storage - Essential (Not needed for Cloud Edition)\tAudit stores Global dependency injection\tDependency injection to ChangeUnits and environment\tContext and dependencies Cloud Edition\tCloud-specific setup: token, env, service\tCloud Edition Framework integration\tIntegration with frameworks (currently Spring Boot)\tSpring Boot integration Lock\tDistributed locking and timing options\tLock configuration Extra\tMetadata, default author, enable/disable\tAdditional configuration  Each of these topics is explained in its own section.    ","version":"1.0.0","tagName":"h2"},{"title":"Applying runtime configuration‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#applying-runtime-configuration","content":" Runtime configuration (everything except the pipeline) can be applied in the following ways:  Runtime environment\tBuilder\tFileStandalone\t‚úÖ\t‚ùå (coming soon) Springboot\t‚úÖ\t‚úÖ(framework native)  info You can combine both approaches. If a property is defined in both, the builder value takes precedence.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#next-steps","content":" Start with the essential configurations marked with ‚≠ê, then explore additional options based on your needs:  ","version":"1.0.0","tagName":"h2"},{"title":"Essential configurations (start here)‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#essential-configurations-start-here","content":" ‚≠ê Setup &amp; stages - Define how changes are organized and discovered‚≠ê Target systems - Configure systems where changes will be applied‚≠ê Audit stores - Set up audit storage (not needed for Cloud Edition)  ","version":"1.0.0","tagName":"h3"},{"title":"Additional configurations‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#additional-configurations","content":" Global dependency injection - Configure dependency resolutionFramework integration - Spring Boot integrationLock configuration - Distributed locking optionsAdditional configuration - Metadata, author, and other settings  ","version":"1.0.0","tagName":"h3"},{"title":"Choose your edition‚Äã","type":1,"pageTitle":"Flamingock library configuration","url":"/docs/flamingock-library-config/introduction#choose-your-edition","content":" ‚òÅÔ∏è Cloud Edition - Fully-featured managed solutionüß™ Community Edition - Community audit stores (feature-limited) ","version":"1.0.0","tagName":"h3"},{"title":"Context and dependencies","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/context-and-dependencies","content":"","keywords":"","version":"1.0.0"},{"title":"What is the context?‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#what-is-the-context","content":" The context is Flamingock's dependency container that holds all the dependencies your ChangeUnits might need. It's organized hierarchically, allowing for proper scoping and isolation of dependencies.  Contexts can contain:  System connectors (databases, message queues, storage services, APIs)Configuration properties and objectsService instances and business logic componentsFramework-specific beans (like Spring components)Custom utilities and helpers  ","version":"1.0.0","tagName":"h2"},{"title":"Dependency resolution hierarchy‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#dependency-resolution-hierarchy","content":" Flamingock uses a hierarchical resolution strategy that searches for dependencies in this order:  Target system context - Dependencies provided by the specific target system. For more information, see Target systems.General application context - Shared dependencies registered globally directly in the builderFramework context - When using Spring Boot, beans from the Spring container. For more information, see Spring Boot integration.  This approach ensures that system-specific dependencies are properly scoped while allowing shared utilities to be available everywhere.  ","version":"1.0.0","tagName":"h2"},{"title":"How it works in practice‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#how-it-works-in-practice","content":" When a ChangeUnit needs a dependency, Flamingock follows a specific search pattern. For example, imagine your ChangeUnit requires a NotificationService:  Scenario 1: If the Kafka target system provides its own notification service specifically for event streaming, and your ChangeUnit belongs to that Kafka target system, Flamingock will use the Kafka-specific notification service. The target system context always wins.  Scenario 2: If your MongoDB target system doesn't provide a notification service, but you've registered one globally in Flamingock's builder, the ChangeUnit will receive that global notification service. Flamingock searches the target system first, doesn't find it, then falls back to the global context.  Scenario 3: In a Spring Boot application, if neither the target system nor the global context provides the dependency, Flamingock will look for a Spring bean of that type. This allows seamless integration with your existing Spring components.  This hierarchy ensures that specialized implementations (like a Kafka-optimized notification service) are used when available, while still allowing shared services to be accessible across all ChangeUnits.  ","version":"1.0.0","tagName":"h3"},{"title":"Providing dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#providing-dependencies","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Target system dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#target-system-dependencies","content":" Every target system provides two ways to add dependencies:  Specific methods - Each concrete implementation offers .withXXX() methods for common dependencies:  MongoSyncTargetSystem mongoTarget = new MongoSyncTargetSystem(&quot;user-db&quot;) .withDatabase(database) // MongoDB-specific method .withMongoClient(client); // MongoDB-specific method   Generic methods - All target systems (including DefaultTargetSystem) support generic dependency injection:  DefaultTargetSystem kafkaTarget = new DefaultTargetSystem(&quot;events&quot;) .addDependency(kafkaProducer) .addDependency(&quot;notification-service&quot;, notificationService) .setProperty(&quot;batch.size&quot;, 1000);   This flexibility allows DefaultTargetSystem to inject any dependencies needed for non-transactional systems, while specialized target systems provide convenience methods for their common dependencies.  ","version":"1.0.0","tagName":"h3"},{"title":"Global dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#global-dependencies","content":" You can register dependencies globally to make them available to all ChangeUnits:  Flamingock.builder() .addDependency(userService) .addDependency(emailService) .addDependency(configurationProperties) .addTargetSystems(mongoTarget) .build();   ","version":"1.0.0","tagName":"h3"},{"title":"Framework dependencies‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#framework-dependencies","content":" When using frameworks like Spring Boot, Flamingock automatically accesses beans from the framework container:  @Service public class UserService { // This service is automatically available to ChangeUnits }   warning Remember that target system contexts are isolated. Dependencies in one target system aren't available to ChangeUnits in another target system.  ","version":"1.0.0","tagName":"h3"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Scope dependencies appropriately‚Äã","type":1,"pageTitle":"Context and dependencies","url":"/docs/flamingock-library-config/context-and-dependencies#scope-dependencies-appropriately","content":" Target system specific: System connectors (DB, Kafka, S3, etc.), system-specific configurationsGlobal: Shared services, utilities, application-wide configurationFramework: Let Spring manage beans, services, and repositories    Key takeaway: Flamingock's hierarchical dependency resolution provides flexibility while maintaining clear separation of concerns. Use target system contexts for system-specific dependencies and global context for shared resources. ","version":"1.0.0","tagName":"h3"},{"title":"Lock","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/lock","content":"","keywords":"","version":"1.0.0"},{"title":"Configurable properties‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#configurable-properties","content":" Property\tDefault\tDescriptionlockAcquiredForMillis\t60000 (1 min)\tTime the lock remains valid once acquired. Automatically released if not refreshed. lockQuitTryingAfterMillis\t180000 (3 min)\tHow long to retry acquiring the lock if another instance holds it. lockTryFrequencyMillis\t1000 (1 sec)\tInterval between attempts while waiting for the lock. throwExceptionIfCannotObtainLock\ttrue\tWhether Flamingock should fail if the lock can't be acquired. enableRefreshDaemon\ttrue\tWhether to run a background thread that periodically extends the lock.    ","version":"1.0.0","tagName":"h2"},{"title":"Why locking matters‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#why-locking-matters","content":" In distributed systems, multiple app instances may start simultaneously ‚Äî but only one should apply pending changes. Flamingock uses locking to:  Prevent race conditionsEnsure consistent and safe state transitionsGuarantee single execution of each change  info If no pending changes exist, the lock is not acquired and startup proceeds normally.    ","version":"1.0.0","tagName":"h2"},{"title":"Refresh Daemon (safety net)‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#refresh-daemon-safety-net","content":" The refresh daemon is a background thread that extends the lock before it expires. It‚Äôs critical for long-running changes that might exceed the lock duration.  Without the daemon:  A long-running change (e.g., 90s) could outlive a default lock (e.g., 60s)Another instance might acquire the lock prematurely, causing conflict  note By default, Flamingock uses proxy-based injection guards. Before executing any injected dependency, Flamingock verifies that the lock is still valid.  If you're injecting non-critical components (e.g., a local list or stateless helper), you can annotate them with @NonLockGuarded to avoid the proxy overhead.    ","version":"1.0.0","tagName":"h2"},{"title":"Configuration Examples‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#configuration-examples","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Builder‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#builder","content":" FlamingockStandalone .setLockAcquiredForMillis(120000) .setLockQuitTryingAfterMillis(300000) .setLockTryFrequencyMillis(2000) .setThrowExceptionIfCannotObtainLock(true) .setEnableRefreshDaemon(true) ...     ","version":"1.0.0","tagName":"h3"},{"title":"When to tweak Lock settings‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#when-to-tweak-lock-settings","content":" Most projects can use the default configuration. You may need to adjust values if:  You expect long-running changes (increase lockAcquiredForMillis)You run many app instances and want to reduce startup wait (decrease lockTryFrequencyMillis)You want Flamingock to fail fast if it can't acquire a lock (keep throwExceptionIfCannotObtainLock as true)    ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best Practices‚Äã","type":1,"pageTitle":"Lock","url":"/docs/flamingock-library-config/lock#-best-practices","content":" Keep the refresh daemon enabled, especially for distributed or slow-processing environmentsAvoid setting lockAcquiredForMillis too short if any changes might run longerUse @NonLockGuarded sparingly ‚Äî only when you're sure no side-effects will occur ","version":"1.0.0","tagName":"h2"},{"title":"Transactions","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/transactions","content":"","keywords":"","version":"1.0.0"},{"title":"How Flamingock handles transactions‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#how-flamingock-handles-transactions","content":" Flamingock's transaction handling is determined by the target system's capabilities, not just the transactional flag. The behavior differs fundamentally between transactional and non-transactional target systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional target systems‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#transactional-target-systems","content":" Examples: PostgreSQL, MySQL, MongoDB, SQL databases, DynamoDB, Couchbase  These systems support native transaction capabilities:  When transactional = true (default):  Execution runs within a native database transactionOn failure: Automatic rollback using database's native transaction mechanismSession/connection managed automatically by Flamingock@RollbackExecution used only for manual operations (CLI undo)  When transactional = false:  Execution runs without transactionOn failure: Safety through compensation logic (@RollbackExecution)Useful for DDL operations or large bulk operations that exceed transaction limits  ","version":"1.0.0","tagName":"h3"},{"title":"Non-transactional target systems‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#non-transactional-target-systems","content":" Examples: Kafka, S3, REST APIs, file systems, message queues  These systems have no native transaction support:  The transactional flag is ignored - behavior is always the same:  Execution runs normally (no native transaction possible)On failure: Safety through compensation logic (@RollbackExecution)Safety relies entirely on idempotent operations and rollback methods  ","version":"1.0.0","tagName":"h3"},{"title":"Behavior summary table‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#behavior-summary-table","content":" Target System Type\ttransactional = true (default)\ttransactional = falseTransactional\tNative transaction rollback on failure\t@RollbackExecution on failure Non-transactional\tFlag ignored - @RollbackExecution on failure\tFlag ignored - @RollbackExecution on failure    ","version":"1.0.0","tagName":"h3"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Always provide @RollbackExecution‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#always-provide-rollbackexecution","content":" Transactional systems with transactional = true: Used for manual rollback operations (CLI undo)Transactional systems with transactional = false: Called automatically on failureNon-transactional systems: Always called automatically on failure (flag ignored)All cases: Essential for complete change management  ","version":"1.0.0","tagName":"h3"},{"title":"Use appropriate transactionality‚Äã","type":1,"pageTitle":"Transactions","url":"/docs/flamingock-library-config/transactions#use-appropriate-transactionality","content":" Keep default transactional = true for regular data changes on transactional systemsUse transactional = false only when necessary on transactional systems (DDL, bulk operations)For non-transactional systems: The flag doesn't matter - design idempotent operations and robust rollback logic    Key takeaway: Flamingock's transaction behavior is determined by your target system's capabilities. For transactional systems, the transactional flag controls failure handling (native rollback vs @RollbackExecution). For non-transactional systems, the flag is ignored and @RollbackExecution is always used. ","version":"1.0.0","tagName":"h3"},{"title":"Setup & Stages","type":0,"sectionRef":"#","url":"/docs/flamingock-library-config/setup-and-stages","content":"","keywords":"","version":"1.0.0"},{"title":"Setup configuration‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#setup-configuration","content":" Flamingock is configured using the @EnableFlamingock annotation on any class in your application. This annotation is required for all environments ‚Äî whether you're using the standalone runner or Spring Boot integration.  The annotation is only used for defining the setup (stages and their sources). No runtime configuration should be placed here.    ","version":"1.0.0","tagName":"h2"},{"title":"Defining the setup‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#defining-the-setup","content":" Here's the default single-stage configuration:  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } ) public class FlamingockConfig { // Configuration class }   Alternatively, using a YAML file:  @EnableFlamingock(pipelineFile = &quot;config/setup.yaml&quot;) public class FlamingockConfig {}   Where config/setup.yaml contains:  pipeline: stages: - name: main location: com.yourcompany.changes   Advanced options: Multiple stages: For complex scenarios requiring independent change sets go to the stage section belowFile-based configuration: Use pipelineFile parameter for YAML configurationExplicit naming: Use @Stage(name = &quot;custom&quot;, location = &quot;com.yourcompany.changes&quot;)    ","version":"1.0.0","tagName":"h2"},{"title":"Stage Types‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#stage-types","content":" Flamingock supports two families of stages:  ","version":"1.0.0","tagName":"h2"},{"title":"Standard Stages (default)‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#standard-stages-default","content":" The default stage type where users place their changes. This is where you'll put all your application changes (Kafka, MongoDB, SQL, S3, etc.). Standard stages execute changeUnits in order and provide predictable, sequential execution.  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) // Standard stage (default type) } )   ","version":"1.0.0","tagName":"h3"},{"title":"Special Stages‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#special-stages","content":" For specific scenarios, Flamingock provides special stage types that require explicitly specifying a type parameter. Examples include SYSTEM and LEGACY stage types, which are used in particular contexts such as the Mongock upgrade process.  @EnableFlamingock( stages = { @Stage(type = SYSTEM, location = &quot;com.yourapp.system&quot;), @Stage(type = LEGACY, location = &quot;com.yourapp.mongock&quot;), @Stage(location = &quot;com.yourcompany.changes&quot;) // Standard stage (default type) } )   To see these special stages in action, refer to the Upgrade from Mongock guide which demonstrates their practical usage.    ","version":"1.0.0","tagName":"h3"},{"title":"Multiple Stages (Advanced)‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#multiple-stages-advanced","content":" Most applications will naturally fit into a single stage, which keeps things simple and ensures a clear, deterministic execution order. However, if you prefer to organize changes into multiple stages‚Äîfor example, to separate concerns or enforce isolated execution flows‚ÄîFlamingock fully supports that as well. We‚Äôll explain how it works and what to consider when taking that approach.  Default approach: Most applications use a single stage: @Stage(location = &quot;com.yourcompany.changes&quot;). The name is auto-derived (&quot;changes&quot;) and this is the recommended default setup.  ","version":"1.0.0","tagName":"h2"},{"title":"When to Use Multiple Stages‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#when-to-use-multiple-stages","content":" Multiple stages are beneficial in specific scenarios:  Multi-module Applications‚Äã  In monolithic applications with well-defined module boundaries, you can give each module its own stage for full autonomy:  @EnableFlamingock( stages = { @Stage(name = &quot;user-module&quot;, location = &quot;com.yourapp.users.changes&quot;), @Stage(name = &quot;billing-module&quot;, location = &quot;com.yourapp.billing.changes&quot;), @Stage(name = &quot;notification-module&quot;, location = &quot;com.yourapp.notifications.changes&quot;) } )   This approach allows:  Independent change management across modulesDifferent release cycles for different modulesClear separation of concerns and responsibilities  Functional Separation‚Äã  You might want to separate changes by function or lifecycle:  @EnableFlamingock( stages = { @Stage(name = &quot;core-setup&quot;, location = &quot;com.yourapp.setup.changes&quot;), @Stage(name = &quot;business-logic&quot;, location = &quot;com.yourapp.business.changes&quot;), @Stage(name = &quot;monitoring-setup&quot;, location = &quot;com.yourapp.monitoring.changes&quot;) } )   ","version":"1.0.0","tagName":"h3"},{"title":"Restrictions and Important Considerations‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#restrictions-and-important-considerations","content":" No Execution Order Guarantees‚Äã  Critical limitation: Flamingock does not guarantee execution order between stages. This means:  Stage A might execute before, after, or concurrently with Stage BYou cannot rely on changes in one stage being applied before another stage startsEach stage should be completely independent from others  Why This Matters‚Äã  Consider this problematic scenario:  // ‚ùå PROBLEMATIC: Relies on execution order @EnableFlamingock( stages = { @Stage(name = &quot;create-tables&quot;, location = &quot;com.yourapp.schema&quot;), // Creates tables @Stage(name = &quot;seed-data&quot;, location = &quot;com.yourapp.data&quot;) // Inserts data - DEPENDS on tables existing! } )   The seed-data stage might execute before create-tables, causing failures.  Correct Approach‚Äã  Instead, group dependent changes in the same stage:  // ‚úÖ CORRECT: All related changes in one stage @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) // Contains both table creation AND data seeding in order } )   ","version":"1.0.0","tagName":"h3"},{"title":"When NOT to Use Multiple Stages‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#when-not-to-use-multiple-stages","content":" Avoid multiple stages when:  You need execution order across different change types - Use a single stage insteadChanges are logically related - Keep them together for easier maintenanceSimple applications - The complexity isn't worth the overheadCross-cutting concerns - Changes that affect multiple areas should be in one stage  Future Enhancements Conditional stage execution based on dependencies or conditions is planned for future releases, which would allow: Running stages based on success/failure of other stagesDefining explicit dependencies between stagesMore sophisticated stage orchestration patterns    ","version":"1.0.0","tagName":"h3"},{"title":"Required fields‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#required-fields","content":" Each stage must define:  name (optional): A unique identifier - if not provided, it will be auto-derived from the locationlocation: The package or directory where changes are located    ","version":"1.0.0","tagName":"h2"},{"title":"Stage fields‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#stage-fields","content":" Field\tRequired\tDescriptionlocation\t‚úÖ\tPackage or directory scanned for both code-based and template-based changes name\t‚ùå\tUnique identifier for the stage (auto-derived from location if not provided) description\t‚ùå\tOptional text explaining the stage's purpose    ","version":"1.0.0","tagName":"h2"},{"title":"Where Changes are located‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#where-changes-are-located","content":" location refers to a source package (e.g., com.company.changes), a relative(e.g., my/path/changes) or absolute(e.g., /my/path/changes) resources directory. Template-based and code-based changes can co-exist if location is a source package.If location references a resource directory, it only accepts template-based changeUnits.Default source roots: src/main/java, src/main/kotlin, src/main/scala, src/main/groovy.Source root can be customized via the sources compiler option.Resource root can be customized via the resources compiler option. Customizing Source and Resource Root Paths  GradleMaven tasks.withType&lt;JavaCompile&gt; { options.compilerArgs.addAll(listOf( &quot;-Asources=custom/src&quot;, &quot;-Aresources=custom/resources&quot; )) }     ","version":"1.0.0","tagName":"h2"},{"title":"Example Pipeline‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#example-pipeline","content":" pipeline: stages: - name: user-setup description: User-related DB setup location: com.yourapp.flamingock.users   Folder view:  src/ main/ java/ com/ yourapp/ flamingock/ users/ _0001_CREATE_USERS_TABLE.java _0002_ADD_INDEX.yaml     ","version":"1.0.0","tagName":"h2"},{"title":"Best Practices‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Single Stage Execution (default and recommended)‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#single-stage-execution-default-and-recommended","content":" In most applications, changes that require a specific, deterministic execution order should be grouped into a single stage. This ensures they are applied sequentially and in the exact order they are defined.  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourcompany.changes&quot;) } )   Grouping related changes into a single stage:  Ensures predictable, sequential executionAvoids ambiguity from cross-stage execution timingEliminates the need to manage inter-stage dependenciesKeeps setup simple and easier to maintainSupports mixing all types of changes (Kafka, MongoDB, SQL, S3, etc.) in a well-defined order  Advanced scenarios If your application benefits from separating changes‚Äîfor example, by module or lifecycle‚Äîyou can define Multiple Stages (Advanced). Just remember: deterministic execution is guaranteed only within a stage, not across them.  ","version":"1.0.0","tagName":"h3"},{"title":"Placing your changes‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#placing-your-changes","content":" We strongly recommend placing all your changes ‚Äî code-based and template-based ‚Äî in a single location defined by the @Stage annotation.  Ensures changes are always scanned, regardless of typeAvoids needing two locations if one template-based change requires fallback to codeKeeps everything in one logical location    ","version":"1.0.0","tagName":"h3"},{"title":"Naming Convention for Changes‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#naming-convention-for-changes","content":" To ensure clarity and enforce ordering, we recommend naming changes using the following format:  _0001_CREATE_CLIENTS_TABLE.java _0002_ADD_INDEX_TO_EMAIL.yaml   XXXX: The execution order of the changeCHANGE_NAME: Descriptive name of what the change does  This convention:  Works across both code-based and template-based formatsMakes the execution order obvious at a glanceEnsures consistent naming and project hygiene  tip While Java typically avoids underscores and leading digits, change units are not traditional classes. Prioritizing readability and order is more valuable in this context.  ","version":"1.0.0","tagName":"h3"},{"title":"üõ† Troubleshooting‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#-troubleshooting","content":" ","version":"1.0.0","tagName":"h2"},{"title":"My stage isn't picked up‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#my-stage-isnt-picked-up","content":" Make sure the stage has a location field definedCheck the file path is correct and uses / as a separator, not . in YAMLIf using resource directory paths, make sure the file is placed under src/main/resources/your-dir  ","version":"1.0.0","tagName":"h3"},{"title":"No changes found in stage‚Äã","type":1,"pageTitle":"Setup & Stages","url":"/docs/flamingock-library-config/setup-and-stages#no-changes-found-in-stage","content":" Verify that the class or YAML file is located in the expected package/directoryFor code-based changes, ensure the class is annotated with @Change or @ChangeUnitFor template-based changes, check file names and YAML formatting   ","version":"1.0.0","tagName":"h3"},{"title":"GraalVM support","type":0,"sectionRef":"#","url":"/docs/frameworks/graalvm","content":"","keywords":"","version":"1.0.0"},{"title":"How it works‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#how-it-works","content":" When building your application, Flamingock's annotation processor:  Scans for all annotated code-based changes (@ChangeUnit)Discovers template-based changes from sourcesPackage and resourcesDirGenerates metadata files containing all required classes for reflection  At native image generation time, Flamingock‚Äôs GraalVM feature picks up these files and registers the required types with GraalVM, so they‚Äôre available at runtime.  tip Learn more about the basics of GraalVM native image compilation in the GraalVM Native Image basics guide.    ","version":"1.0.0","tagName":"h2"},{"title":"Step-by-step setup‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#step-by-step-setup","content":" ","version":"1.0.0","tagName":"h2"},{"title":"1. Add Flamingock GraalVM dependency‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#1-add-flamingock-graalvm-dependency","content":" GradleMaven implementation(&quot;io.flamingock:flamingock-graalvm:$flamingockVersion&quot;)     ","version":"1.0.0","tagName":"h3"},{"title":"2. Add plugin management (only for Gradle)‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#2-add-plugin-management-only-for-gradle","content":" If using Gradle, ensure your settings.gradle.kts includes:  pluginManagement { repositories { mavenLocal() gradlePluginPortal() mavenCentral() } }     ","version":"1.0.0","tagName":"h3"},{"title":"3. Add GraalVM resource config‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#3-add-graalvm-resource-config","content":" Create a file named resource-config.json in your project root:  { &quot;resources&quot;: { &quot;includes&quot;: [ { &quot;pattern&quot;: &quot;META-INF/flamingock/metadata.json&quot; } ] } }   info This file declares which resource files should be accessible to your native image. You can add other application-specific resources here as needed. See the GraalVM resource configuration documentation for more details.    ","version":"1.0.0","tagName":"h3"},{"title":"4. Build the application‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#4-build-the-application","content":" ./gradlew clean build   Expected build output‚Äã  During the build process, Flamingock will emit logs similar to the following ‚Äî indicating successful annotation processing and metadata generation.  Click to see the expected logs GradleMaven &gt; Task :compileJava Note: [Flamingock] Starting Flamingock annotation processor initialization. Note: [Flamingock] 'resources' parameter NOT passed. Using default 'src/main/resources' Note: [Flamingock] 'sources' parameter NOT passed. Searching in: '[src/main/java, src/main/kotlin, src/main/scala, src/main/groovy]' Note: [Flamingock] Reading flamingock pipeline from file: 'src/main/resources/flamingock/pipeline.yaml' Note: [Flamingock] Initialization completed. Processed templated-based changes. Note: [Flamingock] Searching for code-based changes (Java classes annotated with @Change or legacy @ChangeUnit annotations) Note: [Flamingock] Reading flamingock pipeline from file: 'src/main/resources/flamingock/pipeline.yaml' Note: [Flamingock] Finished processing annotated classes and generating metadata. Note: [Flamingock] Final processing round detected - skipping execution.     ","version":"1.0.0","tagName":"h3"},{"title":"5. Create the native image‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#5-create-the-native-image","content":" native-image \\ --no-fallback \\ --features=io.flamingock.graalvm.RegistrationFeature \\ -H:ResourceConfigurationFiles=resource-config.json \\ -H:+ReportExceptionStackTraces \\ --initialize-at-build-time=org.slf4j.simple \\ -jar build/libs/your-app.jar   What these options do:‚Äã  --features=io.flamingock.graalvm.RegistrationFeature: Registers all Flamingock-related classes for reflection using metadata gathered during build time.-H:ResourceConfigurationFiles=resource-config.json: Informs GraalVM of required static resource files to include.--initialize-at-build-time: ‚Äì Optional. Build‚Äëtime init for listed classes/packages (freeze static state; faster start; avoids early reflection/I/O). Flamingock does not require specific entries. Use only if a library benefits (e.g., logging). Example: --initialize-at-build-time=org.slf4j.impl,org.slf4j.simple. Omit if unsure.  Expected native image output‚Äã  When creating the native image, you should see log output from Flamingock's GraalVM RegistrationFeature, confirming that Flamingock successfully scanned and registered internal classes, templates, system modules, and user-defined change units.  The actual output may differ slightly depending on the modules you‚Äôve included, but it should look similar to the following:  Click to see the expected logs - io.flamingock.graalvm.RegistrationFeature [Flamingock] Starting GraalVM classes registration [Flamingock] Starting registration of internal classes Registering class: io.flamingock.core.task.TaskDescriptor Registering class: io.flamingock.core.task.AbstractTaskDescriptor Registering class: io.flamingock.core.preview.PreviewPipeline Registering class: io.flamingock.core.preview.PreviewStage Registering class: io.flamingock.core.preview.CodePreviewChangeUnit Registering class: io.flamingock.core.preview.CodePreviewLegacyChangeUnit Registering class: io.flamingock.core.preview.PreviewMethod Registering class: io.flamingock.core.api.template.ChangeTemplateConfig Registering class: io.flamingock.core.preview.TemplatePreviewChangeUnit Registering class: io.flamingock.core.pipeline.Pipeline Registering class: io.flamingock.core.pipeline.LoadedStage Registering class: io.flamingock.core.task.loaded.AbstractLoadedTask Registering class: io.flamingock.core.task.loaded.AbstractReflectionLoadedTask Registering class: io.flamingock.core.task.loaded.AbstractLoadedChangeUnit Registering class: io.flamingock.core.task.loaded.CodeLoadedChangeUnit Registering class: io.flamingock.core.task.loaded.TemplateLoadedChangeUnit Registering class: java.nio.charset.CoderResult [Flamingock] Completed internal classes [Flamingock] Starting registration of templates Registering class: io.flamingock.core.api.template.TemplateFactory Registering class: io.flamingock.core.api.template.ChangeTemplate Registering class: io.flamingock.core.api.template.AbstractChangeTemplate Registering class: io.flamingock.template.mongodb.MongoChangeTemplate Registering class: io.flamingock.template.mongodb.model.MongoOperation Registering class: io.flamingock.template.mongodb.MongoChangeTemplateConfig [Flamingock] Completed templates [Flamingock] Starting registration of system modules Registering class: io.flamingock.core.engine.audit.importer.changeunit.MongockImporterChangeUnit Registering class: io.flamingock.core.engine.audit.importer.ImporterModule [Flamingock] Completed system modules [Flamingock] Starting registration of user classes Registering class: io.flamingock.changes._1_create_clients_collection_change Registering class: io.flamingock.changes._2_insertClientFederico_change Registering class: io.flamingock.changes._3_insert_client_jorge [Flamingock] Completed user classes [Flamingock] Completed GraalVM classes registration   tip For more information on image creation and options, refer to the GraalVM build overview documentation.    ","version":"1.0.0","tagName":"h3"},{"title":"6. Run the native image‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#6-run-the-native-image","content":" ./your-app     ","version":"1.0.0","tagName":"h3"},{"title":"Example project‚Äã","type":1,"pageTitle":"GraalVM support","url":"/docs/frameworks/graalvm#example-project","content":" We have built a complete example project for GraalVM that demonstrates:  A working Flamingock configuration with GraalVMSample change unitsProper resource configurationNative image generation process  You can use this example as a reference implementation while following the steps in this guide. ","version":"1.0.0","tagName":"h2"},{"title":"How does Flamingock work within a k8s ecosystem? (to-do)","type":0,"sectionRef":"#","url":"/docs/frameworks/kubernetes","content":"How does Flamingock work within a k8s ecosystem? (to-do)","keywords":"","version":"1.0.0"},{"title":"Automatic Setup","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup","content":"","keywords":"","version":"1.0.0"},{"title":"Import the springboot integration library‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#import-the-springboot-integration-library","content":" Add the appropriate Flamingock Spring Boot integration dependency, depending on your version:  GradleMaven // For Spring Boot 3.x (Spring 6.x) implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;) // For Spring Boot 2.x (Spring 5.x, legacy) implementation(&quot;io.flamingock:flamingock-springboot-integration-v2-legacy:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#version-compatibility","content":" Check Version Compatibility  ","version":"1.0.0","tagName":"h3"},{"title":"Configure setup and activate integration‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#configure-setup-and-activate-integration","content":" To activate the integration, add @EnableFlamingock to any class in your application (commonly on your main class or a configuration class):  @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }   The @EnableFlamingock annotation enables automatic Spring Boot integration, which:  Detect and use Spring‚Äôs ApplicationContext and ApplicationEventPublisherLoads Flamingock configuration directly from your Spring Boot config fileAutomatically configures the runner (e.g., ApplicationRunner or InitializingBean)Processes the setup configuration from the annotation    ","version":"1.0.0","tagName":"h2"},{"title":"Providing configuration‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#providing-configuration","content":" Runtime configuration is defined using standard Spring Boot configuration files. Use the flamingock section for all core and edition-specific options.  flamingock: lockAcquiredForMillis: 1200 runnerType: InitializingBean # other configuration...   info If the runnerType property is not provided, Flamingock defaults to using ApplicationRunner.    ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Automatic Setup","url":"/docs/frameworks/springboot-integration/enable-flamingock-setup#next-steps","content":" Want full control over the builder? See Builder-based setupExplore Spring Boot profile supportLearn about Flamingock lifecycle events ","version":"1.0.0","tagName":"h2"},{"title":"Builder-based (manual)","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/builder-based-setup","content":"","keywords":"","version":"1.0.0"},{"title":"Import the springboot integration library‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#import-the-springboot-integration-library","content":" Add the appropriate Flamingock Spring Boot integration dependency, depending on your version:  GradleMaven // For Spring Boot 3.x implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;) // For Spring Boot 2.x (legacy) implementation(&quot;io.flamingock:flamingock-springboot-integration-v2-legacy:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#version-compatibility","content":" Check Version Compatibility  ","version":"1.0.0","tagName":"h3"},{"title":"Configure setup and build Flamingock manually‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#configure-setup-and-build-flamingock-manually","content":" With the manual setup, you first need to configure Flamingock using @EnableFlamingock annotation with setup = SetupType.BUILDER, then manually configure and run Flamingock using the builder API.  ","version":"1.0.0","tagName":"h2"},{"title":"1. Configure the annotation‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#1-configure-the-annotation","content":" @EnableFlamingock( setup = SetupType.BUILDER, stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) @Configuration public class FlamingockConfig { // Configuration class }   ","version":"1.0.0","tagName":"h3"},{"title":"2. Manual builder configuration‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#2-manual-builder-configuration","content":" With the manual setup, you are responsible for configuring and running Flamingock using the builder API. This includes:  Providing your configuration (e.g., lock settings, metadata) directly via the builderRegistering the required platform components using .addDependency(...)ApplicationContextApplicationEventPublisher  FlamingockBuilder builder = Flamingock .setLockAcquiredForMillis(120000) // example config .addDependency(applicationContext) .addDependency(applicationEventPublisher);   info Platform components are registered using the same .addDependency(...) method used for change unit dependencies. For details, see the Platform component injection page.    ","version":"1.0.0","tagName":"h3"},{"title":"Overriding Spring-provided dependencies‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#overriding-spring-provided-dependencies","content":" When using the builder-based setup, Flamingock will attempt to resolve dependencies using the Spring context.  However, if you manually register a dependency via .addDependency(...), that dependency will take precedence over anything resolved from the Spring context. This gives you fine-grained control when you want to:  Override a Spring-managed bean with a custom instanceInject mock or test-specific versions of servicesProvide external or non-Spring-managed components directly  builder .addDependency(customClientService) // Overrides Spring's bean of same type .addDependency(applicationContext); // Registers Spring context for base dependency injection   In a nutshell, Flamingock resolves dependencies using the following order:  Manually added dependencies via .addDependency(...)Beans from the Spring context (if ApplicationContext was registered)    ","version":"1.0.0","tagName":"h2"},{"title":"Running Flamingock‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#running-flamingock","content":" Once you've configured the builder, you can choose how to execute Flamingock:  ","version":"1.0.0","tagName":"h2"},{"title":"Option 1: Run manually‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#option-1-run-manually","content":" You can run Flamingock manually:  builder.build().run();   ","version":"1.0.0","tagName":"h3"},{"title":"Option 2: Expose as a Spring Bean‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#option-2-expose-as-a-spring-bean","content":" Alternatively, you can integrate Flamingock into the Spring Boot lifecycle by exposing it as an ApplicationRunner or InitializingBean:  @Bean public ApplicationRunner flamingockRunner() { return SpringbootUtil.toApplicationRunner(builder.build()); }   Or:  @Bean public InitializingBean flamingockRunner() { return SpringbootUtil.toInitializingBean(builder.build()); }   This ensures Flamingock executes automatically as part of the Spring Boot startup sequence.    ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Builder-based (manual)","url":"/docs/frameworks/springboot-integration/builder-based-setup#next-steps","content":" Want to avoid manual setup? Explore the Automatic Setup for automatic integration with minimal code. ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot profiles","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/profiles","content":"","keywords":"","version":"1.0.0"},{"title":"What is a Spring profile?‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#what-is-a-spring-profile","content":" Spring profiles provide a way to segregate parts of your application configuration and behavior based on the active environment.  You can define profiles like dev, test, staging, or prod, and activate one or more of them using any of the following methods:  Inside application.yml or application.properties: spring: profiles: active: dev,staging Using profile-specific configuration files like application-dev.yml or application-prod.yml As command-line arguments: --spring.profiles.active=dev,staging Through environment variables: SPRING_PROFILES_ACTIVE=dev,staging   When multiple profiles are active, Flamingock evaluates each change unit against all active profiles, and includes it if any match.    ","version":"1.0.0","tagName":"h2"},{"title":"How Flamingock uses profiles‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#how-flamingock-uses-profiles","content":" Flamingock automatically retrieves the active profiles from Spring‚Äôs ApplicationContext. You don‚Äôt need to manually provide them.  You can then annotate any change unit with Spring‚Äôs native @Profile annotation to control whether it runs:  @ChangeUnit(id = &quot;add-test-data&quot;, order = &quot;001&quot;) @Profile(&quot;dev&quot;) public class AddTestDataChangeUnit { // will only run if &quot;dev&quot; profile is active }   Flamingock applies the same logic as Spring Boot when evaluating whether a change unit should run.    ","version":"1.0.0","tagName":"h2"},{"title":"Multiple profiles‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#multiple-profiles","content":" You can declare multiple profiles in a single @Profile expression:  @Profile({&quot;dev&quot;, &quot;staging&quot;})   This change unit will run if any of the listed profiles is active.    ","version":"1.0.0","tagName":"h2"},{"title":"Excluding profiles‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#excluding-profiles","content":" To exclude a change unit from a specific profile, you can use Spring Expression Language (SpEL):  @Profile(&quot;!prod&quot;)   This will run the change unit in all environments except prod.    ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Spring Boot profiles","url":"/docs/frameworks/springboot-integration/profiles#-best-practices","content":" Use profiles to isolate test data, preview features, or tenant-specific migrationsAvoid mixing profile-specific logic inside a single change unit ‚Äî split them into separate classesKeep profile names consistent across your team and environments (e.g., use dev everywhere, not development, dev-env, etc.)Consider grouping related change units under a shared profile for easier activation ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot integration","type":0,"sectionRef":"#","url":"/docs/frameworks/springboot-integration/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Why integrate Flamingock with Spring Boot?‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#why-integrate-flamingock-with-spring-boot","content":" Using Flamingock with Spring Boot allows you to:  Inject Spring-managed beans directly into change unitsConfigure Flamingock via Spring Boot's native configuration filesUse Spring profiles to control when specific change units runReceive execution lifecycle events using ApplicationEventPublisherChoose between Spring Boot lifecycle hooks (ApplicationRunner or InitializingBean) to run Flamingock.    ","version":"1.0.0","tagName":"h2"},{"title":"Two setup approaches‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#two-setup-approaches","content":" Flamingock offers two ways to integrate with Spring Boot, depending on how much control you want over the configuration and lifecycle.  ","version":"1.0.0","tagName":"h2"},{"title":"Builder-based setup (manual)‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#builder-based-setup-manual","content":" This approach gives you full control and uses the standard Flamingock builder with @EnableFlamingock(setup = SetupType.BUILDER). You manually inject the required Spring Boot components(ApplicationContext and ApplicationEventPublisher) as well as any Flamingock core configuration.  In addition, you can register other dependencies manually ‚Äî these will take precedence over beans from the Spring context when resolving what to inject into change units.  This is recommended for advanced users or highly customized environments.  See: Builder-based setup    ","version":"1.0.0","tagName":"h3"},{"title":"Automatic setup‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#automatic-setup","content":" This is the simplest way to enable Flamingock in Spring Boot. Just annotate any class with @EnableFlamingock (commonly your main application class), and Flamingock will:  Auto-detect the application context and event publisherRead configuration from Spring Boot config filesAutomatically wire the FlamingockRunner beanProcess the setup configuration from the annotation  Ideal for most users who prefer convention over configuration.  See: Automatic setup    ","version":"1.0.0","tagName":"h3"},{"title":"Runner strategy: ApplicationRunner vs InitializingBean‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#runner-strategy-applicationrunner-vs-initializingbean","content":" Flamingock supports two strategies for executing its process during Spring Boot startup. You can control this via the runnerType property in your Spring configuration (flamingock.runnerType), or programmatically if using the manual builder.  ","version":"1.0.0","tagName":"h2"},{"title":"Comparison‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#comparison","content":" \tApplicationRunner\tInitializingBeanPhase\tAfter all beans are initialized ‚Äî just before the app is marked as started\tDuring bean initialization ‚Äî before the app is considered started Context availability\t‚úÖ Full ‚Äî all Spring beans and profiles available\t‚ö†Ô∏è Limited ‚Äî not all beans may be available Typical use case\tMost common ‚Äî recommended for production environments\tFor lightweight internal logic or strict startup ordering Events fully supported?\t‚úÖ Yes\t‚ö†Ô∏è Risky ‚Äî context may not be fully ready Spring beans available in change units\t‚úÖ Yes\t‚ö†Ô∏è May fail or be incomplete  ","version":"1.0.0","tagName":"h3"},{"title":"Startup failure behavior‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#startup-failure-behavior","content":" If Flamingock encounters an error during execution ‚Äî whether using ApplicationRunner or InitializingBean ‚Äî the Spring Boot application will fail to start.  This is intentional: Flamingock runs before the application is marked as ready. In deployment platforms such as Kubernetes, a failure at this stage will:  Prevent the container from reaching a Ready stateTrigger restart policies, health checks, or rollbacks as configuredEnsure that the system is never exposed in a partially initialized or inconsistent state  This behavior ensures your application only starts when all change units have been applied successfully.    ","version":"1.0.0","tagName":"h3"},{"title":"Dependency‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#dependency","content":" To use the Spring Boot integration, add the appropriate module for your version:  GradleMaven // For Spring Boot 3.x implementation(&quot;io.flamingock:flamingock-springboot-integration:$flamingockVersion&quot;) // For Spring Boot 2.x (legacy) implementation(&quot;io.flamingock:flamingock-springboot-integration-v2-legacy:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Version Compatibility‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#version-compatibility","content":" Flamingock provides two editions for Spring Boot integration.  ","version":"1.0.0","tagName":"h3"},{"title":"Why are there two Spring Boot integration community-audit-stores artifacts?‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#why-are-there-two-spring-boot-integration-community-audit-stores-artifacts","content":" The only difference is the Java version they target:  flamingock-springboot-integration ‚Äî requires JDK 17 or newer.flamingock-springboot-integration-v2-legacy ‚Äî kept for teams still on Spring Boot 2 who must stay on JDK 8 ‚Äì 11.  Choose the artifact that matches the JDK level of your application today; switching later is as simple as changing the dependency.  Package Name\tSpring Boot Versionflamingock-springboot-integration\t[3.0.0, 4.0.0) flamingock-springboot-integration-v2-legacy\t[2.0.0, 3.0.0)    ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Spring Boot integration","url":"/docs/frameworks/springboot-integration/introduction#white_check_mark-best-practices","content":" Consider the following recommendations to get the most out of Flamingock‚Äôs Spring Boot integration:  Prefer ApplicationRunner as your runner strategy It ensures Flamingock runs after the application context is fully initialized, giving it access to all beans, profiles, and configuration. It also integrates more safely with event publishing and external monitoring tools like Actuator or Prometheus. Use automatic setup (@EnableFlamingock) for simpler setups Unless you have advanced needs (such as injecting non-Spring-managed dependencies), the automatic setup provides a clean and reliable integration path. Use Spring profiles to scope change units Profiles let you control when specific change units execute, avoiding the need for environment-specific pipelines. Avoid manual execution unless absolutely necessary Letting Spring handle the execution via ApplicationRunner or InitializingBean ensures Flamingock runs at the appropriate time in your application lifecycle. Register custom platform components using .addDependency(...) only when required Most applications using automatic setup will not need to register components manually. ","version":"1.0.0","tagName":"h2"},{"title":"How it works?","type":0,"sectionRef":"#","url":"/docs/getting-started/how-it-works","content":"","keywords":"","version":"1.0.0"},{"title":"1. Define your changes as ChangeUnits‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#1-define-your-changes-as-changeunits","content":" Every change ‚Äî whether it‚Äôs a database migration, a feature flag update, or a third-party API configuration ‚Äî is encapsulated into a ChangeUnit.  Each ChangeUnit is uniquely identified, versioned, and optionally includes rollback logic.Changes can be defined in code (Java/Kotlin) or declaratively (YAML/JSON) via reusable templates templates.    ","version":"1.0.0","tagName":"h2"},{"title":"2. Organize changes into Workflows‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#2-organize-changes-into-workflows","content":" ChangeUnits are grouped into stages and structured into a Workflow pipeline to represent a coordinated sequence of changes.  Workflows allow you to define how changes should be applied: sequentially or (in future releases) in parallel or conditionally.This logical grouping simplifies the orchestration and order of changes across systems / services / components.    ","version":"1.0.0","tagName":"h2"},{"title":"3. Execute at startup (or on demand)‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#3-execute-at-startup-or-on-demand","content":" When your application starts, Flamingock automatically:  Scans for pending ChangeUnitsApplies them in the defined workflow orderEnsures idempotency so the same changes aren't applied twice  Flamingock can also run in standalone mode, ideal for setups that don't use an underlying framework (ie. Spring).    ","version":"1.0.0","tagName":"h2"},{"title":"4. Locking for safety in distributed environments‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#4-locking-for-safety-in-distributed-environments","content":" Using distributed locking, Flamingock ensures only one instance (or one node) applies changes at a time ‚Äî preventing race conditions or duplicate executions.  Works across microservices and distributed system setupsSupports multiple store types: Flamingock Community Audit Stores, with native driver compatibility with MongoDB, Couchbase, DynamoDBFlamingock SaaS or Flamingock self-hosted options to leverage Flamingock's provisioned storage.    ","version":"1.0.0","tagName":"h2"},{"title":"5. Audit everything, rollback when needed‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#5-audit-everything-rollback-when-needed","content":" Every change applied is fully audited:  When, by whom, and what was changedStatus of execution (success/failure)And a provisioned optional rollback strategy for non-transactional integrations.  In case of failure or rollback scenario, Flamingock uses defined compensating logic to revert changes and restore consistency.    ","version":"1.0.0","tagName":"h2"},{"title":"Example Use Cases‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#example-use-cases","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Example 1: Versioning made simple‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#example-1-versioning-made-simple","content":" Imagine a developer needs to introduce the following system changes as part of a release:  Add a new field to the user collection in MongoDBEnable a feature flag in a SaaS dashboard via REST APIUpdate an environment variable in a remote configuration store    Here‚Äôs how Flamingock helps:  The developer defines each change as an individual ChangeUnit, with rollback logic included.These ChangeUnits are grouped into stages and a embedded into a workflow, ensuring they run in the correct order.On the next application startup, Flamingock: Detects that these changes haven‚Äôt been applied yetAcquires a distributed lockExecutes all ChangeUnits safely and atomicallyLogs every detail in the audit system  Flamingock rolls back automatically in case of failure(if defined), ensuring the system doesn‚Äôt end up in a partial state.  The result? Faster deployments, consistent environments, and complete traceability.    ","version":"1.0.0","tagName":"h3"},{"title":"Example 2: Synchronizing Changes across domain services‚Äã","type":1,"pageTitle":"How it works?","url":"/docs/getting-started/how-it-works#example-2-synchronizing-changes-across-domain-services","content":" In a Domain-Driven Design (DDD) environment, a change to a domain model often requires updates across several components:  Update to the Database and API specification (e.g., OpenAPI/Swagger)Modify the Kafka event schema and topic configurationAdjust the API Gateway routing and validation rules    Here‚Äôs how Flamingock makes this seamless:  The team creates ChangeUnits for: Updating the Database and API specificationReconfiguring Kafka topics and event schemaUpdating API Gateway specs All related ChangeUnits are grouped into a single workflow to ensure coordinated application.During deployment, Flamingock: Applies all changes atomically, respecting dependenciesAcquires a distributed lock to avoid concurrent modificationsAudits the entire process for traceability and compliance  This ensures that changes in the Database, messaging, and APIs exposed in the gateway are synchronized, reducing integration errors and deployment friction across microservices.   ","version":"1.0.0","tagName":"h3"},{"title":"Get started","type":0,"sectionRef":"#","url":"/docs/getting-started/get-started","content":"","keywords":"","version":"1.0.0"},{"title":"1. Set up Flamingock in your project‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#1-set-up-flamingock-in-your-project","content":" Add Flamingock to your build:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-community-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-community&quot;) annotationProcessor(&quot;io.flamingock:flamingock-processor:$flamingockVersion&quot;)   For more about editions, see Community Audit Stores and Cloud Edition.    ","version":"1.0.0","tagName":"h2"},{"title":"2. Define your first ChangeUnits‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#2-define-your-first-changeunits","content":" Each ChangeUnit represents a single change. For our example, we'll define three:  MySQL: Add a column category to productsS3: Create a product-images bucketKafka: Create a stock-updates topic  ChangeUnits can be:  Code-based: Java classes with annotationsTemplate-based: YAML files using reusable templates  Template basedCode based id: add-product-category author: team order: &quot;001&quot; targetSystem: mysql-inventory template: sql-template templateConfiguration: executionSql: | ALTER TABLE products ADD COLUMN category VARCHAR(255) rollbackSql: | ALTER TABLE products DROP COLUMN category   For more details, see Concepts ‚Üí ChangeUnits.    ","version":"1.0.0","tagName":"h2"},{"title":"3. Create target systems‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#3-create-target-systems","content":" Target systems represent the external systems Flamingock will apply your changes to. They are configured in the builder and shared across ChangeUnits.  For our example:  A MySQL database (mysql-inventory)An S3 bucket service (aws-s3)A Kafka cluster (kafka)  SqlTargetSystem sql = new SqlTargetSystem(&quot;mysql-inventory&quot;).withDatasource(ds); DefaultTargetSystem s3 = new DefaultTargetSystem(&quot;aws-s3&quot;); DefaultTargetSystem kafka = new DefaultTargetSystem(&quot;kafka&quot;);   See Target systems for more details.    ","version":"1.0.0","tagName":"h2"},{"title":"4. Configure stages‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#4-configure-stages","content":" Flamingock organizes your changes in stages. Most applications only need one stage:  @EnableFlamingock( stages = { @Stage(location = &quot;com.company.inventory.changes&quot;) } ) public class App {}   location: Where Flamingock should look for changes (package or resources)name: Optional ‚Äî defaults to the location name  See Stages for more details and advanced setups.    ","version":"1.0.0","tagName":"h2"},{"title":"5. Configure Flamingock runtime‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#5-configure-flamingock-runtime","content":" Finally, configure Flamingock before running your application.  Community Audit Stores: Set your audit store (MongoDB, DynamoDB, Couchbase, etc.) in the builder Cloud Edition (coming soon): Provide your API token, service name, and environment  CommunityCloud (coming soon) FlamingockStandalone .setAuditStore(new MongoSyncAuditStore(mongoClient, mongoDatabase)) .addTargetSystems(sql, s3, kafka) .build() .run();     ","version":"1.0.0","tagName":"h2"},{"title":"6. Run your application‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#6-run-your-application","content":" When your service starts, Flamingock automatically:  Discovers your ChangeUnitsChecks pending changesExecutes them safely in orderRecords everything in the audit store  If Flamingock cannot guarantee a safe outcome, it stops and alerts you. Safety first.  ","version":"1.0.0","tagName":"h2"},{"title":"Example output‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#example-output","content":" Click to see the expected logs GradleMaven &gt; Task :compileJava Note: [Flamingock] Starting Flamingock annotation processor initialization. Note: [Flamingock] 'resources' parameter NOT passed. Using default 'src/main/resources' Note: [Flamingock] 'sources' parameter NOT passed. Searching in: '[src/main/java, src/main/kotlin, src/main/scala, src/main/groovy]' Note: [Flamingock] Reading flamingock setup from annotation configuration Note: [Flamingock] Initialization completed. Processed templated-based changes. Note: [Flamingock] Searching for code-based changes (Java classes annotated with @Change or legacy @ChangeUnit annotations) Note: [Flamingock] Reading flamingock setup from annotation configuration Note: [Flamingock] Finished processing annotated classes and generating metadata. Note: [Flamingock] Final processing round detected - skipping execution.     ","version":"1.0.0","tagName":"h3"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Get started","url":"/docs/getting-started/get-started#next-steps","content":" Spring Boot integrationConfiguration optionsRecovery and safety ","version":"1.0.0","tagName":"h2"},{"title":"Target systems vs audit store","type":0,"sectionRef":"#","url":"/docs/overview/audit-store-vs-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"The dual-system architecture‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#the-dual-system-architecture","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Target systems: where changes are applied‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#target-systems-where-changes-are-applied","content":" Target systems are your business systems where actual changes happen:  Examples: User database, Product catalog, Order management system, Kafka topics, S3 buckets, REST APIsPurpose: Store and process your business data and configurationsModified by: Your business logic through ChangeUnitsConfiguration: See Target System Configuration for technical setup  ","version":"1.0.0","tagName":"h3"},{"title":"Audit store: where execution is tracked‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#audit-store-where-execution-is-tracked","content":" Audit store is Flamingock's dedicated system for tracking what happened:  Examples: Flamingock Cloud backend or dedicated audit table/collection in the user's database.Purpose: Record execution history, compliance data, issue trackingModified by: Flamingock framework automatically (never your code)Configuration: See Audit Store Configuration for technical setup    ","version":"1.0.0","tagName":"h3"},{"title":"Why this separation matters‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#why-this-separation-matters","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Enterprise safety benefits‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#enterprise-safety-benefits","content":" Complete Audit Trail: Every change attempt is recorded regardless of business system failuresGovernance Separation: Business data and compliance data have different access patternsRecovery Capabilities: Operations team can resolve issues by reading audit state, not business dataCompliance Independence: Audit integrity is maintained even during business system issues    ","version":"1.0.0","tagName":"h3"},{"title":"Target system types‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#target-system-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Transactional target systems‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#transactional-target-systems","content":" Systems with native ACID transaction support (PostgreSQL, MySQL, MongoDB 4.0+):  Safety and coordination:  Community Audit Stores: Reliable execution tracking and recovery capabilitiesCloud Edition: Advanced coordination protocols ensure complete recoverability  ","version":"1.0.0","tagName":"h3"},{"title":"Non-transactional target systems‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#non-transactional-target-systems","content":" Systems without native transaction support (Kafka, S3, REST APIs, File Systems):  Safety and coordination:  Community Audit Stores: Reliable execution tracking and rollback-based recoveryCloud Edition: Enhanced recoverability with custom validation options    ","version":"1.0.0","tagName":"h3"},{"title":"Audit store types‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#audit-store-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Cloud Edition audit store‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#cloud-edition-audit-store","content":" Flamingock Cloud provides a fully managed audit store with superior synchronization and recovery through advanced coordination protocols, real-time dashboards, advanced analytics, and multi-environment governance.  ","version":"1.0.0","tagName":"h3"},{"title":"Community Audit Stores audit store‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#community-audit-stores-audit-store","content":" User-provided audit store (MongoDB, DynamoDB, Couchbase) that ensures complete execution tracking, prevents duplicate executions, and provides basic recovery capabilities. See Community audit store configuration for setup.    ","version":"1.0.0","tagName":"h3"},{"title":"How it works‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#how-it-works","content":"  Your ChangeUnits: ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ 1. Change[UpdateKafkaSchema] ‚Üí Target System[Kafka Schema Registry] ‚îÇ ‚îÇ 2. Change[SeedKafkaEvents] ‚Üí Target System[Kafka Topics] ‚îÇ ‚îÇ 3. Change[AddUserStatus] ‚Üí Target System[User Database] ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Flamingock ‚îÇ ‚îÇ (Orchestrator) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ Executes sequentially ‚îÇ ChangeUnit #1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê (UpdateKafkaSchema) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ñº ‚ñº ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Target System: ‚îÇ ‚îÇ Audit Store ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Schema Registry ‚îÇ ‚îÇ ‚îÇ Records: ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ #1 applied ‚îÇ ‚îÇ ‚îÇ (applies change) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ChangeUnit #2 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê (SeedKafkaEvents) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ñº ‚ñº ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Target System: ‚îÇ ‚îÇ Audit Store ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Kafka Topics ‚îÇ ‚îÇ ‚îÇ Records: ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ #2 applied ‚îÇ ‚îÇ ‚îÇ (applies change) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ChangeUnit #3 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê (AddUserStatus) ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ñº ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Target System: ‚îÇ ‚îÇ Audit Store ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ User Database ‚îÇ ‚îÇ ‚îÇ Records: ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ #3 applied ‚îÇ ‚îÇ (applies change) ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   The Flow:  You create ChangeUnits - Define what changes need to happenFlamingock orchestrates - Safely applies changes across all your systemsTarget systems evolve - Your business systems get updatedAudit store tracks everything - Complete history for compliance and recovery    ","version":"1.0.0","tagName":"h2"},{"title":"Key takeaways‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#key-takeaways","content":" ","version":"1.0.0","tagName":"h2"},{"title":"For developers‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#for-developers","content":" Target systems: Where your business logic runs and makes changesAudit store: Automatically managed by Flamingock for tracking and complianceImplementation: See Target System Configuration and Audit Store Configuration  ","version":"1.0.0","tagName":"h3"},{"title":"For architects‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#for-architects","content":" Clean separation: Business logic separated from execution trackingEnterprise scalability: Architecture supports compliance, governance, multi-environmentFlexibility: Works with any target system type (transactional, non-transactional, hybrid)  ","version":"1.0.0","tagName":"h3"},{"title":"For operations‚Äã","type":1,"pageTitle":"Target systems vs audit store","url":"/docs/overview/audit-store-vs-target-system#for-operations","content":" Issue resolution: Tools operate on audit store, you fix target systemsCompliance: Complete audit trail independent of business system availabilityRecovery: Always know the state, even during complex failure scenarios  Bottom Line: This dual-system architecture is what enables Flamingock to provide enterprise-grade safety and governance capabilities that traditional tools cannot match. ","version":"1.0.0","tagName":"h3"},{"title":"Core concepts","type":0,"sectionRef":"#","url":"/docs/overview/core-concepts","content":"","keywords":"","version":"1.0.0"},{"title":"ChangeUnits‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#changeunits","content":" ChangeUnits are the fundamental building blocks of Flamingock's Change-as-Code architecture. They represent atomic, versioned changes applied to target systems with complete safety guarantees and audit capabilities.  Each ChangeUnit includes:  Unique identity: ID, order, and metadata for trackingTarget system: Where the changes is applied toExecution logic: The actual change implementationRollback capability: Compensation logic for governance and undo operationsRecovery strategy: Configurable behavior for handling failures  ChangeUnits can be implemented in two forms:  Code-based: Java classes with annotations that contain the change logicTemplate-based: Declarative low-code approach using YAML configurations  For a deeper dive around ChangeUnits, see the ChangeUnits deep dive section.    ","version":"1.0.0","tagName":"h3"},{"title":"Templates‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#templates","content":" Templates provide a reusable layer on top of ChangeUnits for common change patterns. When you have multiple changes that share similar logic (for example, executing SQL statements), templates allow you to abstract that common logic and reuse it.  With templates, you create multiple ChangeUnits using a declarative, low-code approach. Each ChangeUnit uses a template and passes its specific configuration. For example, an SQL template receives the SQL statement as configuration, executes it, and handles errors consistently.  This approach is particularly useful for:  Standardizing common operations across your codebaseReducing boilerplate codeEnabling non-developers to define changes through configuration  For more information about templates, see the Templates section.    ","version":"1.0.0","tagName":"h3"},{"title":"Recovery strategies‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#recovery-strategies","content":" Recovery strategies define how Flamingock responds when a ChangeUnit fails during execution. They determine whether the system should stop and wait for manual intervention or automatically retry the operation.  Flamingock provides two main strategies:  Manual intervention (default): Stops execution and requires human review when failures occurAlways retry: Automatically retries the change on the next execution attempt  The choice of strategy depends on whether your changes are idempotent and how critical they are to your system's integrity.  For detailed configuration and implementation, see the Recovery configuration section.    ","version":"1.0.0","tagName":"h2"},{"title":"Audit store‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#audit-store","content":" The audit store is where Flamingock records metadata about change executions. Its purpose is to track which ChangeUnits have been executed, when they ran, and their outcomes. This ensures idempotency, enables rollbacks, and provides audit capabilities. The audit store is managed entirely by Flamingock - your code never directly interacts with it.  ","version":"1.0.0","tagName":"h2"},{"title":"Target system‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#target-system","content":" The target system is where your actual business changes are applied. These are the systems your ChangeUnits modify - databases, message queues, APIs, configuration services, etc. Each ChangeUnit declares which target system it operates on.  For more details about how these systems work together, see the Audit store vs target system section.    ","version":"1.0.0","tagName":"h2"},{"title":"Transaction handling‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#transaction-handling","content":" Flamingock adapts its behavior based on the transactional capabilities of your target systems:  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional target systems‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#transactional-target-systems","content":" Systems like PostgreSQL, MySQL, or MongoDB 4.0+ that support ACID transactions. When working with these systems, Flamingock can leverage native transaction support to ensure atomicity of changes. If a failure occurs mid-execution, the native rollback mechanism ensures no partial changes are left in the system.  ","version":"1.0.0","tagName":"h3"},{"title":"Non-transactional target systems‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#non-transactional-target-systems","content":" Systems like Kafka, S3, REST APIs, or file systems that don't support transactions. For these systems, Flamingock relies on explicit rollback methods and careful change design to maintain consistency. Recovery strategies become particularly important for handling failures in non-transactional contexts.  For implementation details, see the Transactions section.    ","version":"1.0.0","tagName":"h3"},{"title":"Stages‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#stages","content":" Stages organize your changes into logical groups within Flamingock's execution pipeline. By default, you work with a single stage that contains all your changes, ensuring they execute sequentially in a deterministic order.  Key characteristics:  Changes within a stage execute sequentially with guaranteed orderMost applications only need a single stageMultiple stages can be used for modular architectures, but execution order between stages is not guaranteedEach stage defines where to find its changes (package or directory location)  For detailed information about stages and advanced configurations, see the Setup and stages section.    ","version":"1.0.0","tagName":"h2"},{"title":"Events‚Äã","type":1,"pageTitle":"Core concepts","url":"/docs/overview/core-concepts#events","content":" Flamingock can notify your application about the execution status of changes through events. This enables integration with monitoring systems, custom logging, or triggering downstream processes based on change completion.  For more information about events, see the Events section. ","version":"1.0.0","tagName":"h2"},{"title":"Flamingock Editions","type":0,"sectionRef":"#","url":"/docs/overview/Editions","content":"","keywords":"","version":"1.0.0"},{"title":"üîπ Community Audit Stores (Open Source)‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#-community-audit-stores-open-source","content":" Complete safety foundation for distributed system evolution  The Foundation: All core safety guarantees and audit capabilities that make Flamingock unique.  ","version":"1.0.0","tagName":"h2"},{"title":"What You Get:‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#what-you-get","content":" Safety-First Architecture: MANUAL_INTERVENTION default strategy prevents silent data corruptionComplete Audit Trail: Full execution history, compliance reporting, issue trackingIntelligent Recovery: Configurable strategies (MANUAL_INTERVENTION, ALWAYS_RETRY)Enterprise-Grade CLI: Issue resolution, audit management, rollback operationsUniversal Target Support: Databases, APIs, message queues, cloud services, SaaS platformsDistributed Coordination: Safe execution across clustered deployments  ","version":"1.0.0","tagName":"h3"},{"title":"Infrastructure:‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#infrastructure","content":" Your Database: MongoDB, DynamoDB, CosmosDB, or Couchbase as audit storeSelf-Managed: Full control over your audit and execution infrastructureExtensible: Driver architecture supports additional database integrations  ","version":"1.0.0","tagName":"h3"},{"title":"Ideal For:‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#ideal-for","content":" Teams requiring enterprise-grade safety without managed infrastructureOrganizations with strong operational capabilitiesDevelopment teams seeking autonomous change managementProjects requiring complete audit trails and governance  ","version":"1.0.0","tagName":"h3"},{"title":"‚òÅÔ∏è Flamingock Cloud Edition‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#Ô∏è-flamingock-cloud-edition","content":" Enterprise platform for organizational transformation  Launch Timeline: Early 2025 | Beta Program: Now accepting participants  ","version":"1.0.0","tagName":"h2"},{"title":"Three-Tier Value Proposition‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#three-tier-value-proposition","content":" Foundation (All Community Audit Stores capabilities included)‚Äã  Complete safety guarantees and audit capabilitiesAll recovery strategies and CLI operationsUniversal target system support with distributed coordination  Enhanced Execution (Same configuration, better outcomes)‚Äã  Intelligent Automation: Advanced reconciliation and marker mechanismsEnhanced Recovery: Automatic issue resolution for operations that would require manual intervention in Community Audit StoresSmart Retry Logic: Sophisticated backoff and circuit breaker patternsCross-System Coordination: Advanced transaction protocols for distributed changes  Enterprise Platform Features‚Äã  Real-Time Dashboards: Executive visibility, team metrics, compliance reportingAdvanced RBAC: Team-based access control, approval workflows, audit delegationMulti-Environment Management: Coordinated rollouts, environment promotion, configuration drift detectionEnterprise Integrations: SSO, LDAP, external audit systems, notification platformsSLA Guarantees: Committed uptime, support response times, data durabilityCompliance Automation: Regulatory reporting, policy enforcement, audit trail management  ","version":"1.0.0","tagName":"h3"},{"title":"Strategic Investment Path‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#strategic-investment-path","content":" &quot;Same safety foundations ‚Üí Enhanced automatic outcomes ‚Üí Enterprise platform capabilities&quot;  Start with Community Audit Stores's complete safety guarantees, then enhance with Cloud's automatic resolution and enterprise features. Your configurations and change definitions remain unchanged - Cloud Edition amplifies their effectiveness.  ","version":"1.0.0","tagName":"h3"},{"title":"Join the Beta Program‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#join-the-beta-program","content":" Early Access Available Flamingock Cloud Edition beta program is accepting enterprise participants. What you get: Early access to enterprise platform featuresDirect influence on product roadmap and prioritizationDedicated technical support and onboarding assistanceGrandfathered pricing for early adopters Contact: support@flamingock.io with &quot;Cloud Beta Program&quot; in the subject line  ","version":"1.0.0","tagName":"h3"},{"title":"üíé Flamingock Self-Hosted Edition‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#-flamingock-self-hosted-edition","content":" Cloud platform capabilities in your infrastructure  Status: Available by request for enterprise customers  ","version":"1.0.0","tagName":"h2"},{"title":"What You Get:‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#what-you-get-1","content":" All Flamingock Cloud Edition capabilities deployed and managed within your infrastructure:  Full Cloud Platform Features: Dashboards, RBAC, multi-environment managementYour Infrastructure: Complete data sovereignty and infrastructure controlEnterprise Security: Meets stringent compliance requirements for regulated industriesCustom Integrations: Tailored integrations with your existing enterprise systems  ","version":"1.0.0","tagName":"h3"},{"title":"Ideal For:‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#ideal-for-1","content":" Regulated Industries: Financial services, healthcare, government requiring data sovereigntyEnterprise Security: Organizations with strict infrastructure and data policiesCustom Requirements: Teams needing specialized integrations or compliance featuresHybrid Architectures: Organizations requiring both cloud and on-premises capabilities  Enterprise Availability Flamingock Self-Hosted Edition is available by request for qualifying enterprise customers. Requirements: Enterprise contract, dedicated technical onboarding, infrastructure requirements assessment Contact: support@flamingock.io with &quot;Self-Hosted Edition&quot; in the subject line    ","version":"1.0.0","tagName":"h3"},{"title":"Choosing Your Edition‚Äã","type":1,"pageTitle":"Flamingock Editions","url":"/docs/overview/Editions#choosing-your-edition","content":" Need\tCommunity Audit Stores\tCloud Edition\tSelf-HostedEnterprise Safety\t‚úÖ Complete\t‚úÖ Enhanced\t‚úÖ Enhanced Audit &amp; Compliance\t‚úÖ Full capabilities\t‚úÖ Advanced automation\t‚úÖ Advanced + sovereignty Team Collaboration\tCLI-based\t‚úÖ Platform features\t‚úÖ Platform features Multi-Environment\tManual coordination\t‚úÖ Automated\t‚úÖ Automated Infrastructure Management\tSelf-managed\tFully managed\tSelf-managed Data Sovereignty\t‚úÖ Your control\tFlamingock managed\t‚úÖ Your control  Start your journey: Community Audit Stores ‚Üí Cloud Beta Program ‚Üí Enterprise Self-Hosted ","version":"1.0.0","tagName":"h2"},{"title":"Change-as-Code (CaC)","type":0,"sectionRef":"#","url":"/docs/overview/Change-as-Code","content":"","keywords":"","version":"1.0.0"},{"title":"Why CaC matters today‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#why-cac-matters-today","content":" Modern applications increasingly span dozens of external systems‚Äîranging from relational and NoSQL databases to SaaS feature flags, message buses, and infrastructure APIs. Managing these changes manually or with ad-hoc scripts leads to:  Drift and ‚Äúsnowflake‚Äù environments When teams manually tweak production configurations, environments diverge, making rollbacks or audits nearly impossible. Lack of auditability Regulatory and security teams require a full record of ‚Äúwhat changed, when, and who made it.‚Äù Spreadsheets and one-off commands don‚Äôt cut it. Inefficient collaboration Developers, operations, and security need a single source of truth: change definitions in code, reviewed and versioned via pull requests. Increased risk of human error Pasting commands into a console or clicking UI checkboxes invites typos, misconfigurations, and stress during deployment windows.  Flamingock‚Äôs CaC approach solves these problems by treating every external-system change as first-class code‚Äîcomplete with version control, automated execution, and a centralized audit trail.    ","version":"1.0.0","tagName":"h2"},{"title":"Four Pillars of Change-as-Code‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#four-pillars-of-change-as-code","content":" One-Hundred-Percent Versioned All ChangeUnits live in your Git repository (or other VCS). This means you can review, diff, and roll back changes just like application code. Automated Execution Flamingock scans and applies ChangeUnits at application startup or on-demand via the CLI. No manual intervention‚Äîjust code running code. Auditable &amp; Traceable Every ChangeUnit outcome is recorded in an audit store (your database or Flamingock Cloud). Teams can query ‚Äúwho ran what change, and when,‚Äù ensuring full compliance. Cross-Component Support Whether it‚Äôs SQL/NoSQL DDL, S3 buckets, Kafka topics, feature-flag toggles, or REST API calls‚ÄîFlamingock treats them all as code. Your entire system evolves in lockstep.    ","version":"1.0.0","tagName":"h2"},{"title":"‚ÄúHello, CaC‚Äù Code Snippet‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#hello-cac-code-snippet","content":" Imagine you need to toggle a feature flag in a downstream service (not a database). In Flamingock, you‚Äôd write:  @Change(id = &quot;enable-autosave&quot;, order = &quot;0005&quot;, author = &quot;ops-team&quot;) public class _0005_EnableAutoSaveFeature { @Execution public void enableAutoSave(FeatureFlagClient client) { client.setFlag(&quot;autosave_feature&quot;, true); } @RollbackExecution public void disableAutoSave(FeatureFlagClient client) { client.setFlag(&quot;autosave_feature&quot;, false); } }   Versioned: This code-based or template-based ChangeUnit lives in your VCS.Automated: Flamingock executes it in order (0005) at startup or via CLI.Auditable: Upon success, an audit entry is written to your audit store.Cross-Component: The same pattern works for a DynamoDB schema change, a Kafka topic creation, or any REST API call.    ","version":"1.0.0","tagName":"h2"},{"title":"Illustration: CaC vs. IaC‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#illustration-cac-vs-iac","content":"   Infrastructure as Code (IaC): Use Terraform, CloudFormation, Pulumi, etc., to provision VMs, networks, and databases (the ‚Äúfoundation‚Äù).Change as Code (CaC): Use Flamingock to version and apply everything that lives on that foundation‚Äîdatabase schemas, feature flags, SaaS configurations, message topics, and more.    ","version":"1.0.0","tagName":"h2"},{"title":"Real-World Use Cases‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#real-world-use-cases","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Multi-tenant SaaS Onboarding‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#multi-tenant-saas-onboarding","content":" Problem: Over the lifetime of your application, you might need to create and then later modify external resources‚Äîsuch as an S3 bucket, Kafka topics, IAM roles, and initial database state‚Äîas part of each new release. Doing this manually or with ad-hoc scripts risks drift, missing audits, and inconsistent environments..  CaC Solution: Define a sequence of ChangeUnits that run in order on mutiple deployments, inserting audit entries and ensuring reproducible, versioned updates::  CodeTemplate @ChangeUnit(id = &quot;provision-bucket&quot;, order = &quot;0001&quot;, author = &quot;team-a&quot;, transactional = false) public class _0001_ProvisionBucketChange { @Execution public void execute(S3Client s3) { s3.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .build()); } @RollbackExecution public void rollback(S3Client s3) { s3.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .build()); } } @ChangeUnit(id = &quot;create-kafka-topics&quot;, order = &quot;0002&quot;, author = &quot;devops&quot;, transactional = false) public class _0002_CreateKafkaTopicsChange { @Execution public void exec(KafkaAdminClient admin) { NewTopic topic1 = new NewTopic(&quot;app-events&quot;, 3, (short) 1); NewTopic topic2 = new NewTopic(&quot;user-notifications&quot;, 2, (short) 1); admin.createTopics(Arrays.asList(topic1, topic2)); } @RollbackExecution public void rollback(KafkaAdminClient admin) { admin.deleteTopics(Arrays.asList(&quot;app-events&quot;, &quot;user-notifications&quot;)); } } @ChangeUnit(id = &quot;setup-iam-roles&quot;, order = &quot;0003&quot;, author = &quot;devops&quot;, transactional = false) public class _0003_SetupIamRolesChange { @Execution public void exec(IamClient iam) { CreateRoleResponse response = iam.createRole(CreateRoleRequest.builder() .roleName(&quot;flamingock-app-role&quot;) .assumeRolePolicyDocument(&quot;{...}&quot;) // truncated for brevity .build()); } @RollbackExecution public void rollback(IamClient iam) { iam.deleteRole(DeleteRoleRequest.builder() .roleName(&quot;flamingock-app-role&quot;) .build()); } } @ChangeUnit(id = &quot;seed-database&quot;, order = &quot;0004&quot;, author = &quot;devops&quot;, transactional = true) public class _0004_SeedTenantDataChange { @Execution public void exec(DataSource ds) { try (Connection conn = ds.getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate( &quot;INSERT INTO tenants (id, name, created_at) &quot; + &quot;VALUES (1, 'TenantA', NOW()), (2, 'TenantB', NOW())&quot; ); } catch (SQLException e) { throw new RuntimeException(e); } } @RollbackExecution public void rollback(DataSource ds) { try (Connection conn = ds.getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate(&quot;DELETE FROM tenants WHERE id IN (1, 2)&quot;); } catch (SQLException e) { throw new RuntimeException(e); } } } @ChangeUnit(id = &quot;update-bucket-settings&quot;, order = &quot;0005&quot;, author = &quot;team-a&quot;, transactional = false) public class _0005_UpdateBucketSettingsChange { @Execution public void execute(S3Client s3) { // Example: enable versioning on the bucket s3.putBucketVersioning(PutBucketVersioningRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .versioningConfiguration(VersioningConfiguration.builder() .status(&quot;Enabled&quot;) .build()) .build()); } @RollbackExecution public void rollback(S3Client s3) { // Example: disable versioning on the bucket s3.putBucketVersioning(PutBucketVersioningRequest.builder() .bucket(&quot;flamingock-app-bucket&quot;) .versioningConfiguration(VersioningConfiguration.builder() .status(&quot;Suspended&quot;) .build()) .build()); } }   Flamingock ensures these four steps run in sequence‚Äînever twice‚Äîand logs them in your audit store for future reference.    ","version":"1.0.0","tagName":"h3"},{"title":"Change-as-Code Checklist‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#change-as-code-checklist","content":" ‚úÖ Change lives in VCS: Every ChangeUnit class (or YAML template) is versioned.‚úÖ Automated pipeline: Flamingock applies changes automatically at startup or via CLI.‚úÖ Audit trail: Query your audit store for a complete history of applied changes.‚úÖ Rollback logic: Each ChangeUnit provides @RollbackExecution to undo or compensate if needed.‚úÖ Consistent ordering: All ChangeUnits follow a strict, declared ordering (via the order attribute).‚úÖ Cross-component: You can target databases, SaaS APIs, feature flags, message systems‚Äîanything with a client API.    ","version":"1.0.0","tagName":"h2"},{"title":"Next Steps‚Äã","type":1,"pageTitle":"Change-as-Code (CaC)","url":"/docs/overview/Change-as-Code#next-steps","content":" Quickstart Guide ‚Üí Learn how to create your first ChangeUnit and run Flamingock.Core concepts ‚Üí Dive deeper into auditing, drivers, transactions, and distributed locking.Real use case examples ‚Üí Explore real-world code samples: MongoDB, DynamoDB, Couchbase, Kafka, and more. ","version":"1.0.0","tagName":"h2"},{"title":"Key features","type":0,"sectionRef":"#","url":"/docs/overview/key-features","content":"Key features With Flamingock, you can take advantage of the following features: üß± Change management of any component: Manage configuration and data changes with your Application code for any component. NoSQL Databases are a first-class citizen, and we've expanded this capability for any type of component that requires configuration. info Currently supported languages: Java, Kotlin. üîó Extended integrations and custom use case support: Flamingock enables one-time or repeatable operational processes ‚Äî such as fetching external data, initializing third-party services, or executing custom logic ‚Äî ensuring they run safely, just once, and in the right context. It expands on Mongock's support to manage Database changes to all systems, databases, technologies and configurations (ie. Kafka, Twilio, Auth0, etc) or any user-defined scenario. üß© Flexible migration Templates: New mechanisms for defining changes, offering a no-code option to streamline and simplify change management. üöÄ Seamless deployment: Deploy your application and systems together, ensuring version compatibility and reducing deployment friction. ‚ö° GraalVM support: Enables the compilation of Java applications into native executables for improved performance. üë• Multi-Tenant support (coming soon!): Designed to handle multiple tenants within the same infrastructure. üîí Distributed Locking: Ensures synchronized deployment of multiple service instances, maintaining consistency and preventing conflicts in distributed environments. üîÑ Auditing &amp; Rollback: Comprehensive auditing capabilities with support for rollback of changes to ensure consistency and control. ‚òÅÔ∏è Cloud offering (coming soon!): Offers a fully managed service by hosting Flamingock‚Äôs operational data on our servers, removing the need for users to set up and manage their own infrastructure whilst unlocking the full Flamingock suite of features. üíª Management Operations via a Dashboard and CLI (coming soon!): Flamingock offers tools to simplify Operational management tasks. Some of these example are: List history of changes, execute Rollbacks, Undo deployment, Audit, etc. Additionally, offers a Dashboard with metrics and alerts. üõ†Ô∏è Advanced Workflow Management: Enables multiple streams of change units that can be organized to execute sequentially, in parallel, or as a combination, providing flexibility in managing complex processes. üîÄ Parallel Synchronised Execution: When workflows include parallel streams, they can be executed simultaneously by different service instances, maximizing efficiency in distributed deployments.","keywords":"","version":"1.0.0"},{"title":"Flamingock Technical Overview","type":0,"sectionRef":"#","url":"/docs/overview/technical-overview","content":"","keywords":"","version":"1.0.0"},{"title":"Architectural Overview‚Äã","type":1,"pageTitle":"Flamingock Technical Overview","url":"/docs/overview/technical-overview#architectural-overview","content":" In a nutshell, the Flamingock process takes all the pending changes and executes them in order during your Application startup process.  Application Startup ‚Üí Initializes the Runner.Runner scans and loads all registered ChangeUnits.Drivers communicate with an underlying component that varies by edition. In Flamingock CE, this component is a simple storage layer (e.g., MongoDB, DynamoDB).In the Cloud and Self-Hosted editions, the driver connects to a more sophisticated Flamingock backend that includes orchestration, auditing, and support for advanced operational features. ChangeUnits execute in a coordinated workflow, optionally using templates.Distributed Locking ensures safe execution in distributed environments.All executions are audited and can be rolled backed.  Flamingock is designed to either apply all defined changes successfully or fail early. On the next run, it will resume from the last failed change.    ","version":"1.0.0","tagName":"h2"},{"title":"A more detailed process steps‚Äã","type":1,"pageTitle":"Flamingock Technical Overview","url":"/docs/overview/technical-overview#a-more-detailed-process-steps","content":" Flamingock process follows the next steps:  The runner/builder loads the pipeline of execution of changes.The runner loads the files storing the changes desired (changeUnits).The runner checks if there is pending change to execute.The runner acquires the distributed lock through the driver.The runner loops over the ChangeUnits (change files) in order.Takes the next ChangeUnit and executes it.  If the ChangeUnit is successfully executed, Flamingock persists an entry in the Flamingock change history with the state SUCCESS and start the step 5 again.If the ChangeUnit fails, the runner rolls back the change. If the driver supports transactions and transactions are enabled, the rollback is done natively. When the driver does not support transactions or transactions are disabled, the method @RollbackExecution is executed. In both cases the ChangeUnit failed, whereas in the latter option, and entry is added in the changelog that a change has been rolled back.If the runner acomplished to execute the entire migration with no failures, it's considered successful. It releases the lock and finishes the migration. On the other hand, if any ChangeUnit fails, the runner stops the migration at that point and throws an exception. When Flamingock is executed again, it will continue from the failure ChangeUnit(included). ","version":"1.0.0","tagName":"h3"},{"title":"","type":0,"sectionRef":"#","url":"/docs/overview/Introduction","content":"","keywords":"","version":"1.0.0"},{"title":"The Flamingock Guarantee‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#the-flamingock-guarantee","content":" &quot;Your system will always be left in a known, auditable, and consistent state ‚Äî no matter what happens.&quot;  Managing change across an application and the distributed systems it interacts with is inherently complex ‚Äî database schema updates, message broker configuration, API evolution, cloud service provisioning. Traditional tools optimize for the happy path, but real-world deployments face partial failures, network issues, and uncertain states.  Flamingock is built for this reality. It provides safety-first distributed system evolution with complete auditability and configurable recovery strategies, ensuring that change is never left in doubt.    ","version":"1.0.0","tagName":"h2"},{"title":"Why Flamingock?‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#why-flamingock","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Safety and auditability by design‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#safety-and-auditability-by-design","content":" Safe by default: When Flamingock cannot guarantee success, it stops and alerts instead of risking corruption.Built-in recovery mechanisms: By default Flamingock retries safely where possible, and users can configure recovery strategies to minimize manual intervention.Complete audit trail: Every execution, success, and failure is tracked for compliance and troubleshooting.Deterministic execution: ChangeUnits run once and only once, in a controlled order.  ","version":"1.0.0","tagName":"h3"},{"title":"Designed for distributed reality‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#designed-for-distributed-reality","content":" Non-transactional systems supported: Kafka, S3, REST APIs, and more get first-class safety treatment.Network-resilient: Handles interruptions and partial failures with recovery strategies.Cluster-safe: Prevents race conditions in distributed or containerized deployments.  ","version":"1.0.0","tagName":"h3"},{"title":"Organizational benefits‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#organizational-benefits","content":" Reduce risk: Eliminate silent corruption and ensure compliance.Increase velocity: Developers can evolve their systems independently, without waiting on infrastructure teams.Enable governance: Clear ownership, auditability, and rollback capabilities across all environments.    ","version":"1.0.0","tagName":"h3"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#use-cases","content":" Flamingock enables controlled, auditable evolution across your technology stack:  Data Systems  Database schema changes (SQL/NoSQL)Index creation and optimizationData migrations and transformations  Infrastructure &amp; APIs  Message broker topic and schema managementAPI gateway and routing rulesCloud service configuration  Application Configuration  Feature flag rolloutsSaaS integrations and external service setupSecurity policies and permissions  Distributed Coordination  Multi-service configuration synchronizationCross-system dependency management  ...and other systems requiring safe, auditable evolution    ","version":"1.0.0","tagName":"h2"},{"title":"What Flamingock Is Not‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#what-flamingock-is-not","content":" Not Infrastructure-as-Code: We evolve systems already provisioned by your infrastructure.Not generic batch processing: Optimized for deterministic, auditable changes ‚Äî not arbitrary long-running jobs.Not a CI/CD replacement: Complements your pipeline but focuses exclusively on safe system evolution.    ","version":"1.0.0","tagName":"h2"},{"title":"How Flamingock Works‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#how-flamingock-works","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Change-as-code architecture‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#change-as-code-architecture","content":" Developers define ChangeUnits in code or templates. Each ChangeUnit is versioned, auditable, and executed once per system.  ","version":"1.0.0","tagName":"h3"},{"title":"Execution lifecycle‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#execution-lifecycle","content":" Discovery ‚Äì Flamingock scans your app for ChangeUnitsValidation ‚Äì Prevents duplicate execution using the audit storeExecution ‚Äì Runs the change with the configured recovery strategyAudit ‚Äì Records all outcomes for visibility and complianceRecovery ‚Äì Provides CLI (and Cloud UI) tools for resolution if needed    ","version":"1.0.0","tagName":"h3"},{"title":"Next Steps‚Äã","type":1,"pageTitle":"","url":"/docs/overview/Introduction#next-steps","content":" Quickstart GuideHow it WorksTechnical Overview ","version":"1.0.0","tagName":"h2"},{"title":"Recovery Strategies","type":0,"sectionRef":"#","url":"/docs/recovery-and-safety/recovery-strategies","content":"","keywords":"","version":"1.0.0"},{"title":"The Safety-First Philosophy‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#the-safety-first-philosophy","content":" Core Principle: &quot;When in doubt, stop and alert rather than corrupt data.&quot;  Traditional tools assume the &quot;happy path&quot; - they retry operations blindly or fail without context. This approach leads to:  Silent data corruptionInconsistent system statesDifficult troubleshootingCompliance gaps  Flamingock's Approach: Configurable recovery strategies that match your operation's risk profile.    ","version":"1.0.0","tagName":"h2"},{"title":"Recovery Strategy Types‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#recovery-strategy-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"MANUAL_INTERVENTION (Default)‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#manual_intervention-default","content":" Philosophy: &quot;Safety first - human judgment for uncertain situations.&quot;  @TargetSystem(&quot;financial-database&quot;) @ChangeUnit(id = &quot;process-payments&quot;, order = &quot;001&quot;, author = &quot;finance-team&quot;) // No @Recovery annotation = MANUAL_INTERVENTION default public class ProcessPayments { @Execution public void execute(MongoDatabase financialDb) { // Critical financial operations // Any failure requires manual review to ensure data integrity financialDb.getCollection(&quot;payments&quot;) .updateMany(eq(&quot;status&quot;, &quot;pending&quot;), combine(set(&quot;status&quot;, &quot;processed&quot;), set(&quot;processedAt&quot;, new Date()))); } @RollbackExecution public void rollback(MongoDatabase financialDb) { // Financial rollback requires careful manual oversight financialDb.getCollection(&quot;payments&quot;) .updateMany(eq(&quot;status&quot;, &quot;processed&quot;), combine(set(&quot;status&quot;, &quot;pending&quot;), unset(&quot;processedAt&quot;))); } }   When It Activates: Any failure where system state is uncertainWhat Happens:  Execution stops immediatelyIssue logged with detailed contextHuman review required via CLIComplete audit trail maintained  Best For:  Financial transactionsUser data modificationsCritical business logicNon-idempotent operationsCompliance-sensitive changes  ","version":"1.0.0","tagName":"h3"},{"title":"ALWAYS_RETRY‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#always_retry","content":" Philosophy: &quot;Keep trying until successful - for operations we know are safe.&quot;  @TargetSystem(&quot;user-cache&quot;) @ChangeUnit(id = &quot;warm-user-cache&quot;, order = &quot;002&quot;, author = &quot;platform-team&quot;) @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) public class WarmUserCache { @Execution public void execute(RedisTemplate redis, UserService userService) { // Idempotent cache warming - safe to repeat List&lt;User&gt; activeUsers = userService.findActiveUsers(); for (User user : activeUsers) { String cacheKey = &quot;user:&quot; + user.getId(); UserProfile profile = userService.getUserProfile(user.getId()); redis.opsForValue().set(cacheKey, profile, Duration.ofHours(24)); } } @RollbackExecution public void rollback(RedisTemplate redis) { // Clear cache - used for CLI undo operations redis.delete(&quot;user:*&quot;); } }   When It Activates: Any failure, regardless of causeWhat Happens:  Failure is loggedAutomatic retry on next executionContinues until successfulNo manual intervention required  Best For:  Cache warming operationsIdempotent API callsEvent publishing (with consistent keys)Configuration updatesIndex creationFile operations with overwrite    ","version":"1.0.0","tagName":"h3"},{"title":"Decision Framework‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#decision-framework","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Is Your Operation Idempotent?‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#is-your-operation-idempotent","content":" Idempotent: Running multiple times produces same result as running once  ‚úÖ Cache SET operations‚úÖ Database UPSERT operations‚úÖ File overwrites‚úÖ CREATE IF NOT EXISTS operations‚ùå Increment/decrement operations‚ùå Append operations‚ùå Time-sensitive operations  ","version":"1.0.0","tagName":"h3"},{"title":"Risk Assessment Matrix‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#risk-assessment-matrix","content":" Operation Risk\tData Criticality\tRecovery StrategyHigh\tHigh\tMANUAL_INTERVENTION High\tLow\tMANUAL_INTERVENTION Low\tHigh\tMANUAL_INTERVENTION Low\tLow\tALWAYS_RETRY (if idempotent)  Examples:  High Risk + High Criticality: Financial transactions, user authentication dataHigh Risk + Low Criticality: Complex multi-step processes, dependency changesLow Risk + High Criticality: Simple user data updates, critical configurationLow Risk + Low Criticality: Cache operations, metrics collection    ","version":"1.0.0","tagName":"h3"},{"title":"Practical Implementation Patterns‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#practical-implementation-patterns","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Pattern 1: Financial Operations‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#pattern-1-financial-operations","content":" @TargetSystem(&quot;payment-system&quot;) @ChangeUnit(id = &quot;process-refunds&quot;, order = &quot;010&quot;, author = &quot;finance-team&quot;) // MANUAL_INTERVENTION default - no annotation needed public class ProcessRefunds { @Execution public void execute(PaymentService paymentService) { // Critical financial operation - requires human oversight on failure List&lt;RefundRequest&gt; pendingRefunds = paymentService.getPendingRefunds(); for (RefundRequest refund : pendingRefunds) { paymentService.processRefund(refund); auditService.logRefund(refund); } } @RollbackExecution public void rollback(PaymentService paymentService) { // Financial rollbacks require manual verification // This method used for CLI undo operations } }   ","version":"1.0.0","tagName":"h3"},{"title":"Pattern 2: Infrastructure Setup‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#pattern-2-infrastructure-setup","content":" @TargetSystem(&quot;messaging-infrastructure&quot;) @ChangeUnit(id = &quot;create-kafka-topics&quot;, order = &quot;020&quot;, author = &quot;platform-team&quot;, transactional = false) @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) public class CreateKafkaTopics { @Execution public void execute(KafkaAdminClient kafkaAdmin) { // Topic creation is idempotent - safe to retry List&lt;NewTopic&gt; topics = Arrays.asList( new NewTopic(&quot;user-events&quot;, 10, (short) 3), new NewTopic(&quot;order-events&quot;, 10, (short) 3) ); kafkaAdmin.createTopics(topics); } @RollbackExecution public void rollback(KafkaAdminClient kafkaAdmin) { // Delete topics - used for CLI undo operations kafkaAdmin.deleteTopics(Arrays.asList(&quot;user-events&quot;, &quot;order-events&quot;)); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Pattern 3: Conditional Logic Based on Environment‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#pattern-3-conditional-logic-based-on-environment","content":" @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;user-data-cleanup&quot;, order = &quot;030&quot;, author = &quot;data-team&quot;) @Recovery(strategy = RecoveryStrategy.MANUAL_INTERVENTION) // Explicit for clarity public class UserDataCleanup { @Execution public void execute(MongoDatabase userDb, @Value(&quot;${environment}&quot;) String env) { if (&quot;production&quot;.equals(env)) { // Production data cleanup requires manual oversight cleanupInactiveUsers(userDb); } else { // Non-production can be more aggressive cleanupAllTestData(userDb); } } }     ","version":"1.0.0","tagName":"h3"},{"title":"Cloud Edition Enhanced Recovery‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#cloud-edition-enhanced-recovery","content":" Cloud Edition uses the same recovery strategies but provides enhanced outcomes:  ","version":"1.0.0","tagName":"h2"},{"title":"Enhanced MANUAL_INTERVENTION‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#enhanced-manual_intervention","content":" Automatic issue detection with real-time alertsDetailed diagnostic information for faster resolutionWorkflow automation for common resolution patternsTeam collaboration features for complex issues  ","version":"1.0.0","tagName":"h3"},{"title":"Enhanced ALWAYS_RETRY‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#enhanced-always_retry","content":" Intelligent retry backoff prevents system overloadCircuit breaker patterns prevent cascading failuresAutomatic reconciliation detects and resolves inconsistenciesAdvanced monitoring provides visibility into retry patterns  ","version":"1.0.0","tagName":"h3"},{"title":"Marker Mechanism (Cloud Edition)‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#marker-mechanism-cloud-edition","content":" For transactional systems, Cloud Edition uses sophisticated coordination:  Intent markers placed before executionState tracking during executionResolution markers after completionAutomatic recovery based on marker state  This enables Cloud Edition to automatically resolve many issues that require manual intervention in Community Audit Stores.    ","version":"1.0.0","tagName":"h3"},{"title":"Operational Workflows‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#operational-workflows","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Issue Resolution Process‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#issue-resolution-process","content":" # 1. Detect issues flamingock issue list # Shows all changes requiring attention # 2. Get next priority issue flamingock issue get # Returns detailed context and guidance # 3. Investigate and resolve # Review target system state # Make necessary corrections # Document resolution # 4. Mark as resolved flamingock audit fix -c change-id --resolution APPLIED # or flamingock audit fix -c change-id --resolution ROLLED_BACK   ","version":"1.0.0","tagName":"h3"},{"title":"Monitoring and Alerting‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#monitoring-and-alerting","content":" Issue detection: Automated monitoring of failure statesAlert integration: Connect to PagerDuty, Slack, email systemsMetrics tracking: Success rates, failure patterns, resolution timesDashboard visibility: Real-time status across environments    ","version":"1.0.0","tagName":"h3"},{"title":"Best Practices‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Start Conservative, Optimize Gradually‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#start-conservative-optimize-gradually","content":" Begin with MANUAL_INTERVENTION (default)Monitor failure patterns and resolution outcomesIdentify truly idempotent operationsGradually move appropriate changes to ALWAYS_RETRY  ","version":"1.0.0","tagName":"h3"},{"title":"Design for Idempotency When Possible‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#design-for-idempotency-when-possible","content":" // ‚úÖ Idempotent design users.updateMany( eq(&quot;status&quot;, &quot;pending&quot;), set(&quot;status&quot;, &quot;processed&quot;) // Same result regardless of repetition ); // ‚ùå Non-idempotent design users.updateMany( eq(&quot;status&quot;, &quot;pending&quot;), inc(&quot;processCount&quot;, 1) // Different result each time );   ","version":"1.0.0","tagName":"h3"},{"title":"Document Recovery Strategy Decisions‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#document-recovery-strategy-decisions","content":" @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) // Document why: &quot;Cache SET operations are idempotent and safe to retry&quot; @ChangeUnit(description = &quot;Warm user profile cache - idempotent operation safe for automatic retry&quot;)   ","version":"1.0.0","tagName":"h3"},{"title":"Test Both Strategies in Development‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#test-both-strategies-in-development","content":" Simulate failures in lower environmentsVerify MANUAL_INTERVENTION workflowValidate ALWAYS_RETRY behaviorTest rollback logic for both strategies  ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Governance‚Äã","type":1,"pageTitle":"Recovery Strategies","url":"/docs/recovery-and-safety/recovery-strategies#enterprise-governance","content":" Policy definition: Establish organization-wide guidelinesCode review: Include recovery strategy in review processCompliance documentation: Maintain records of strategy decisionsRegular assessment: Review and update strategies based on operational experience    Key Takeaway: Recovery strategies are not just error handling - they're a core architectural decision that affects operational safety, team productivity, and business risk. Choose wisely, document thoroughly, and evolve based on operational experience. ","version":"1.0.0","tagName":"h3"},{"title":"Issue Resolution","type":0,"sectionRef":"#","url":"/docs/recovery-and-safety/issue-resolution","content":"","keywords":"","version":"1.0.0"},{"title":"Understanding Issues‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#understanding-issues","content":" ","version":"1.0.0","tagName":"h2"},{"title":"What Creates an Issue?‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#what-creates-an-issue","content":" An &quot;issue&quot; is detected when:  Change execution fails during the @Execution methodChange starts but never completes (process crash, timeout)Rollback fails during @RollbackExecution methodChange needs to run again but is in uncertain state  ","version":"1.0.0","tagName":"h3"},{"title":"Issue States‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#issue-states","content":" State\tDescription\tAction RequiredSTARTED\tExecution began but never completed\tManual investigation EXECUTION_FAILED\t@Execution method failed\tReview and resolve ROLLBACK_FAILED\t@RollbackExecution method failed\tManual cleanup    ","version":"1.0.0","tagName":"h3"},{"title":"CLI-Driven Resolution Workflow‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#cli-driven-resolution-workflow","content":" ","version":"1.0.0","tagName":"h2"},{"title":"1. Issue Discovery‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#1-issue-discovery","content":" flamingock issue list   Example Output:  ISSUES FOUND (3) ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Change ID ‚îÇ State ‚îÇ Error ‚îÇ Target ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ user-data-sync-v2 ‚îÇ STARTED ‚îÇ Connection lost ‚îÇ user-db ‚îÇ ‚îÇ cache-warming-q4 ‚îÇ FAILED ‚îÇ Redis timeout ‚îÇ redis-cache ‚îÇ ‚îÇ payment-processing ‚îÇ FAILED ‚îÇ Validation error ‚îÇ payment-api ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Use 'flamingock issue get' to process issues automatically, or 'flamingock issue get -c &lt;change-id&gt;' for specific issue details.   ","version":"1.0.0","tagName":"h3"},{"title":"2. Automated Issue Triage‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#2-automated-issue-triage","content":" flamingock issue get   What This Does:  Automatically selects the next priority issueProvides detailed context and diagnostic informationSuggests resolution approaches based on failure typeNo need to copy/paste change IDs  Example Output:  ISSUE: user-data-sync-v2 Status: STARTED (execution began but never completed) Target System: user-database Author: platform-team Started: 2024-01-15 14:32:15 UTC Error: Connection lost during execution DIAGNOSTIC INFORMATION: - Change was modifying user profiles in MongoDB - Execution started but connection dropped after 30 seconds - No rollback was triggered (connection failure before completion) - Potentially partial state in target system RESOLUTION GUIDANCE: 1. Check target system state: - Query user-database for partially updated records - Look for users with incomplete profile updates - Check MongoDB logs for connection errors around 14:32:15 UTC 2. Determine actual state: - If no changes were applied ‚Üí mark as APPLIED (safe to continue) - If changes were partially applied ‚Üí complete manually, then mark APPLIED - If changes were fully applied ‚Üí mark as APPLIED - If changes caused corruption ‚Üí rollback manually, then mark ROLLED_BACK 3. Resolve the issue: flamingock audit fix -c user-data-sync-v2 --resolution APPLIED flamingock audit fix -c user-data-sync-v2 --resolution ROLLED_BACK Next: flamingock issue get (to process next issue)   ","version":"1.0.0","tagName":"h3"},{"title":"3. Manual Investigation‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#3-manual-investigation","content":" Based on the guidance, investigate the target system (not the audit store):  # Example: Check MongoDB for partial updates mongo user-database --eval &quot; db.users.find({ profileUpdatedAt: { \\$gte: ISODate('2024-01-15T14:30:00Z') }, profileComplete: { \\$ne: true } }).count() &quot;   ","version":"1.0.0","tagName":"h3"},{"title":"4. Issue Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#4-issue-resolution","content":" After investigation, mark the issue as resolved:  # If changes were successfully applied (or completed manually) flamingock audit fix -c user-data-sync-v2 --resolution APPLIED # If changes were rolled back (or need to be skipped) flamingock audit fix -c user-data-sync-v2 --resolution ROLLED_BACK   Success Output:  ‚úÖ Issue resolved successfully Change: user-data-sync-v2 Resolution: APPLIED Audit State: MANUAL_MARKED_AS_EXECUTED Next Execution: Will skip this change (marked as completed)     ","version":"1.0.0","tagName":"h3"},{"title":"Resolution Types‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#resolution-types","content":" ","version":"1.0.0","tagName":"h2"},{"title":"APPLIED Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#applied-resolution","content":" When to use:  Changes were successfully applied to target systemPartial changes were completed manuallyChange should be marked as &quot;done&quot;  Effect:  Updates audit store to MANUAL_MARKED_AS_EXECUTEDFuture executions will skip this changeMaintains audit trail of manual resolution  flamingock audit fix -c change-id --resolution APPLIED   ","version":"1.0.0","tagName":"h3"},{"title":"ROLLED_BACK Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#rolled_back-resolution","content":" When to use:  Changes were rolled back from target systemChanges caused issues and were revertedChange should be marked as &quot;undone&quot;  Effect:  Updates audit store to MANUAL_MARKED_AS_ROLLED_BACKFuture executions will attempt to run this change againEnables retry after fixing underlying issues  flamingock audit fix -c change-id --resolution ROLLED_BACK     ","version":"1.0.0","tagName":"h3"},{"title":"Advanced Resolution Scenarios‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#advanced-resolution-scenarios","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Scenario 1: Partial Multi-System Update‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#scenario-1-partial-multi-system-update","content":" Issue: user-profile-sync failed Target Systems: user-database, elasticsearch, redis-cache Failure: Elasticsearch connection timeout after DB and cache updates   Investigation:  Database: Check if user profiles were updatedCache: Verify cache entries were createdElasticsearch: Confirm no documents were indexed  Resolution:  # Manually sync remaining Elasticsearch documents curl -X POST &quot;elasticsearch:9200/users/_bulk&quot; -H 'Content-Type: application/json' -d @user_updates.json # Mark as successfully applied flamingock audit fix -c user-profile-sync --resolution APPLIED   ","version":"1.0.0","tagName":"h3"},{"title":"Scenario 2: Failed DDL Operation‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#scenario-2-failed-ddl-operation","content":" Issue: create-user-indexes failed Target System: user-database Failure: Index creation failed due to duplicate key constraint   Investigation:  # Check which indexes were created before failure mongo user-database --eval &quot;db.users.getIndexes()&quot;   Resolution Options:  # Option 1: Complete the index creation manually mongo user-database --eval &quot;db.users.createIndex({email: 1}, {unique: true, sparse: true})&quot; flamingock audit fix -c create-user-indexes --resolution APPLIED # Option 2: Clean up partial indexes and retry later mongo user-database --eval &quot;db.users.dropIndex('partial_index_name')&quot; flamingock audit fix -c create-user-indexes --resolution ROLLED_BACK   ","version":"1.0.0","tagName":"h3"},{"title":"Scenario 3: External API Failure‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#scenario-3-external-api-failure","content":" Issue: notify-users-via-email failed Target System: email-service-api Failure: Email service returned 503 Service Unavailable   Investigation:  # Check email service logs curl -X GET &quot;https://email-service/api/v1/status&quot; # Check which emails were actually sent curl -X GET &quot;https://email-service/api/v1/notifications?batch=user-migration-2024&quot;   Resolution:  # If emails were sent despite the error flamingock audit fix -c notify-users-via-email --resolution APPLIED # If no emails were sent and service is now available flamingock audit fix -c notify-users-via-email --resolution ROLLED_BACK # This allows automatic retry on next execution     ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Operational Patterns‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#enterprise-operational-patterns","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Daily Operations Checklist‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#daily-operations-checklist","content":" #!/bin/bash # Daily Flamingock health check script echo &quot;=== Flamingock Issues Check ===&quot; ISSUE_COUNT=$(flamingock issue list --format count 2&gt;/dev/null || echo &quot;0&quot;) if [ &quot;$ISSUE_COUNT&quot; -gt 0 ]; then echo &quot;‚ö†Ô∏è Found $ISSUE_COUNT issues requiring attention&quot; echo &quot;Run: flamingock issue get&quot; # Optional: Send alert to ops team slack-notify &quot;#ops-alerts&quot; &quot;Flamingock: $ISSUE_COUNT issues need resolution&quot; else echo &quot;‚úÖ No issues detected&quot; fi echo &quot;=== Recent Changes ===&quot; flamingock audit list --since yesterday --format summary   ","version":"1.0.0","tagName":"h3"},{"title":"Bulk Issue Resolution‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#bulk-issue-resolution","content":" #!/bin/bash # Process all issues interactively while flamingock issue get --exists; do echo &quot;=== Processing Next Issue ===&quot; flamingock issue get echo &quot;&quot; echo &quot;Actions:&quot; echo &quot;1. Mark as APPLIED (changes were successful)&quot; echo &quot;2. Mark as ROLLED_BACK (changes were reverted)&quot; echo &quot;3. Skip (investigate manually later)&quot; echo &quot;&quot; read -p &quot;Choose action (1/2/3): &quot; choice case $choice in 1) CHANGE_ID=$(flamingock issue get --format id) flamingock audit fix -c &quot;$CHANGE_ID&quot; --resolution APPLIED echo &quot;‚úÖ Marked as APPLIED&quot; ;; 2) CHANGE_ID=$(flamingock issue get --format id) flamingock audit fix -c &quot;$CHANGE_ID&quot; --resolution ROLLED_BACK echo &quot;‚úÖ Marked as ROLLED_BACK&quot; ;; 3) echo &quot;‚è≠Ô∏è Skipped - investigate manually&quot; break ;; *) echo &quot;Invalid choice&quot; ;; esac echo &quot;&quot; done echo &quot;‚úÖ All issues processed&quot;   ","version":"1.0.0","tagName":"h3"},{"title":"Integration with Monitoring Systems‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#integration-with-monitoring-systems","content":" # Example: Prometheus alerting rule groups: - name: flamingock rules: - alert: FlamingockIssuesDetected expr: flamingock_unresolved_issues &gt; 0 for: 5m labels: severity: warning annotations: summary: &quot;Flamingock issues require attention&quot; description: &quot;{{ $value }} unresolved issues in Flamingock&quot; runbook_url: &quot;https://wiki.company.com/flamingock-issue-resolution&quot;   # Custom metrics collection script #!/bin/bash ISSUE_COUNT=$(flamingock issue list --format count 2&gt;/dev/null || echo &quot;0&quot;) echo &quot;flamingock_unresolved_issues $ISSUE_COUNT&quot; | curl -X POST --data-binary @- http://pushgateway:9091/metrics/job/flamingock     ","version":"1.0.0","tagName":"h3"},{"title":"Best Practices‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#best-practices","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Investigate Target Systems, Not Audit Store‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#investigate-target-systems-not-audit-store","content":" ‚ùå SELECT * FROM changeLog WHERE id = 'change-id'‚úÖ Check actual business data in target systems‚úÖ Use application logs and system metrics‚úÖ Verify intended business outcomes  ","version":"1.0.0","tagName":"h3"},{"title":"Document Resolution Decisions‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#document-resolution-decisions","content":" # Add documentation when resolving flamingock audit fix -c user-migration --resolution APPLIED \\ --notes &quot;Verified all users updated successfully. Connection timeout was transient.&quot; # Or maintain a resolution log echo &quot;$(date): user-migration APPLIED - connection timeout, data verified complete&quot; &gt;&gt; /var/log/flamingock-resolutions.log   ","version":"1.0.0","tagName":"h3"},{"title":"Establish Resolution SLAs‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#establish-resolution-slas","content":" Critical issues: Resolve within 4 hoursStandard issues: Resolve within 24 hoursNon-critical issues: Resolve within 72 hours  ","version":"1.0.0","tagName":"h3"},{"title":"Team Responsibilities‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#team-responsibilities","content":" Development team: Create runbooks for their changesOperations team: Daily issue monitoring and basic resolutionSubject matter experts: Complex issue investigation and resolutionManagement: Escalation procedures for critical failures  ","version":"1.0.0","tagName":"h3"},{"title":"Automation Where Appropriate‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#automation-where-appropriate","content":" # Example: Auto-resolve known transient failures #!/bin/bash for issue in $(flamingock issue list --format id --filter &quot;error:ConnectionTimeout&quot;); do # Check if target system is healthy now if ping -c 1 target-database &gt;/dev/null 2&gt;&amp;1; then echo &quot;Auto-resolving transient connection issue: $issue&quot; flamingock audit fix -c &quot;$issue&quot; --resolution ROLLED_BACK --notes &quot;Auto-resolved: transient connection issue&quot; fi done   ","version":"1.0.0","tagName":"h3"},{"title":"Compliance and Audit Requirements‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#compliance-and-audit-requirements","content":" Maintain records of all manual resolutionsDocument investigation process and findingsEstablish approval workflows for critical system changesRegular review of resolution patterns for process improvement    ","version":"1.0.0","tagName":"h3"},{"title":"Troubleshooting Common Issues‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#troubleshooting-common-issues","content":" ","version":"1.0.0","tagName":"h2"},{"title":"\"No issues found\" but changes are stuck‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#no-issues-found-but-changes-are-stuck","content":" # Check if changes are actually failing or just slow flamingock audit list --status STARTED --since &quot;1 hour ago&quot; # Check application logs for execution context tail -f /var/log/app/flamingock.log | grep &quot;EXECUTION&quot;   ","version":"1.0.0","tagName":"h3"},{"title":"CLI returns \"connection error\"‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#cli-returns-connection-error","content":" # Verify CLI configuration flamingock config verify # Check network connectivity to audit store telnet audit-database-host 27017   ","version":"1.0.0","tagName":"h3"},{"title":"Resolution doesn't take effect‚Äã","type":1,"pageTitle":"Issue Resolution","url":"/docs/recovery-and-safety/issue-resolution#resolution-doesnt-take-effect","content":" # Verify resolution was recorded flamingock audit list -c change-id --format detailed # Check for configuration issues flamingock consistency-check     Key Takeaway: Issue resolution is not just error handling - it's a structured operational discipline that ensures your distributed systems evolve safely and your team can respond confidently to any failure scenario. ","version":"1.0.0","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/docs/resources/examples","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#introduction","content":" The Flamingock Examples repository showcases a growing collection of real-world use cases demonstrating how to use Flamingock in different environments, integrations, and technologies. Each top-level folder represents a target technology and contains one or more self-contained example projects. Each project is designed to be cloned, explored, and run as a reference or foundation for your own implementation.  üëâ GitHub Repository: github.com/flamingock/flamingock-examples    ","version":"1.0.0","tagName":"h2"},{"title":"What you‚Äôll find‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#what-youll-find","content":" Within each technology folder, you‚Äôll find one or more example ‚Äãprojects that demonstrate how to configure Flamingock and apply change units in various scenarios. Each folder contains its own README.md with setup instructions, and each project inside has its own documentation.  Technology Folder\tDescriptionmongodb\tFolder containing Flamingock CE projects using MongoDB as the audit‚Äêlog backend. Each project shows different integration scenarios (standalone Java, Spring Boot, etc.). dynamodb\tFolder containing Flamingock CE projects using Amazon DynamoDB for audit logging. Includes both standalone and Spring Boot examples. couchbase\tFolder containing Flamingock CE projects using Couchbase as the audit‚Äêlog backend.  More examples are planned ‚Äî including PostgreSQL, Redis, LocalStack, Kafka, Spring Native, multi‚Äêmodule projects, and custom runners.    ","version":"1.0.0","tagName":"h2"},{"title":"How to use the examples‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#how-to-use-the-examples","content":" Each example folder and project includes its own README.md with detailed setup and run instructions. In general:  Clone the examples repository git clone https://github.com/flamingock/flamingock-examples.git This repository contains all the example folders for various technologies. Navigate to the technology folder of interest cd flamingock-examples/s3 Replace s3 with the folder name for the technology you are interested in (e.g., kafka, mongodb, dynamodb, etc.). Navigate to a specific example project cd s3 Each folder contains one or more projects. Move into the project folder that matches your use case or environment. Run the example For standalone Java applications: ./gradlew run For Spring Boot projects: ./gradlew bootRun Follow any additional instructions in the project‚Äôs README.md. Some examples may use Testcontainers or LocalStack; if so, ensure Docker is running on your machine.    ","version":"1.0.0","tagName":"h2"},{"title":"Who this is for‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#who-this-is-for","content":" New users: Learn by example. Pick an example that matches your tech stack and explore how Flamingock integrates with your environment.Advanced users: Discover integration patterns with external systems like Kafka, AWS, or NoSQL databases.Contributors: Want to improve or submit a new example? Fork the repo, add your example folder, and create a pull request!    ","version":"1.0.0","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Examples","url":"/docs/resources/examples#contributing","content":" We welcome community contributions to expand this repository! Please consider:  Adding new example projects or folders (e.g., Wiremock, Kafka, PostgreSQL, Redis)Fixing or modernizing existing examplesImproving documentation and setup instructions  See the CONTRIBUTING.md for detailed guidelines. ","version":"1.0.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/resources/faq","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#introduction","content":" This FAQ addresses frequent questions about Flamingock's enterprise-grade distributed system evolution platform, from basic usage to advanced recovery strategies and operational concerns.    ","version":"1.0.0","tagName":"h2"},{"title":"Getting started‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#getting-started","content":" Should I use a template-based or code-based ChangeUnit? Choose template-based ChangeUnits to eliminate boilerplate for common tools and integrations (SQL DDL, SaaS/API, etc) and for your custom ChangeUnits by defining changes declaratively in YAML or JSON. Use code-based ChangeUnits when you need custom or conditional logic in Java. See: Template introduction  Can I integrate Flamingock into a Spring Boot application? Yes, you can. You just need to import the Spring Boot integration module and annotate you main application with @EnableFlamingock. See: Spring Boot integration  Can I use Flamingock without Spring Boot? Yes. You can use Flamingock in any Java application by configuring it manually using the FlamingockBuilder. This approach is ideal for applications that do not rely on Spring Boot or that require finer control.  What Java version is required? Flamingock‚Äôs core engine runs on Java 8 and above. However, some optional integration modules (such as the Spring Boot support) target more recent ecosystems and require Java 17+. For those cases we publish two artifacts:  A modern module (e.g., flamingock-springboot-integration) built for Java 17+ and Spring Boot 3.xA legacy counterpart (e.g., flamingock-springboot-integration-v2-legacy) compatible with Java 8 and Spring Boot 2.x  Most users on Java 8 can stick with the core and legacy integrations; if you‚Äôre on Java 17 or newer, simply use the up-to-date modules.  Is it possible to use Flamingock in GraalVM native images? Yes, Flamingock provides a dedicated GraalVM integration guide. Ensure your dependencies and reflection requirements are correctly configured.    ","version":"1.0.0","tagName":"h3"},{"title":"Editions and compatibility‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#editions-and-compatibility","content":" What edition of Flamingock should I use? Flamingock is available in three flavors‚Äîpick the one that best fits your needs and operational model:  Cloud Edition (SaaS) A fully managed, enterprise-grade service hosted by Flamingock: Zero ops: no infrastructure to manage, no database to configureEnterprise features: cross-service dashboards, RBAC, team &amp; environment management, fully support for templates, batching, etc.24√ó7 support &amp; SLAs and seamless upgrades Perfect for teams that need scalability, governance, and out-of-the-box observability. Self-hosted Edition All the same features as our Cloud Edition‚Äîdashboards, governance, transaction protocols‚Äîbut deployed into your own infrastructure (on-premises or in your VPC): Full feature parity with SaaS CloudData residency &amp; compliance: you control where audit records live Ideal for organizations that require enterprise capabilities but cannot‚Äîor prefer not to‚Äîconsume a hosted SaaS. Community Audit Stores Open-source, self-hosted library you run alongside your application: Lightweight &amp; free: you supply your own audit store (MongoDB, DynamoDB, Couchbase, etc.)Core capabilities: ChangeUnits, audit logging, distributed locking, and transactional consistency where supported Perfect for smaller teams or projects that need a robust, code-centric change framework.  Can I switch between editions? Yes. Flamingock provides an importer that allows you to migrate seamlessly from a Community Audit Stores to the Cloud Edition, making it easy to adopt a fully managed backend for storing internal data.  If you are working with different Community Audit Storess that use the same underlying store (such as MongoDB), and they share the same structure and collection for storing metadata, it is possible to switch between them with minimal adjustments. This enables flexible integration depending on your preferred access layer, such as switching from the MongoDB Java Driver edition to the Spring Data edition.    ","version":"1.0.0","tagName":"h3"},{"title":"Behaviour and execution‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#behaviour-and-execution","content":" Does Flamingock guarantee idempotent execution? Yes. Each ChangeUnit has a unique ID and Flamingock ensures it runs only once per system, even across multiple instances.  What happens if a ChangeUnit execution fails midway? Flamingock's behavior depends on your recovery strategy configuration:  With MANUAL_INTERVENTION (default):  Transactional changes: Database automatically rolls back, issue logged for manual reviewNon-transactional changes: @RollbackExecution method called, issue logged for manual reviewResolution required: Use CLI (flamingock issue get, then flamingock audit fix) to resolve after investigation  With ALWAYS_RETRY:  Transactional changes: Database automatically rolls back, automatic retry on next executionNon-transactional changes: @RollbackExecution method called, automatic retry on next executionNo manual intervention: Continues until successful  This intelligent failure handling prevents silent data corruption and provides operational control.  How can I ensure changes are transactional? If your database supports transactions (e.g. MongoDB ‚â• 4.0 in replica set), you can enable them using Flamingock‚Äôs transaction config.  Should I implement the @RollbackExecution method in transactional environments?  Yes, we highly recommend to implement the @RollbackExecution method. The main reason for this is that some other operations like undo, rely on this method to work. However it's a very good practice as it provides a robust system that is less affected when moving to non-transactional environments.  Can I react to the execution of Flamingock from my application? Yes. Flamingock provides an event system that allows your application to listen to key lifecycle moments, such as when a ChangeUnit starts or finishes execution. These events can be used to trigger logging, monitoring, or other side effects external to the change execution logic itself.  This enables loose coupling between Flamingock‚Äôs core execution and your application-level behaviour, without modifying the ChangeUnit directly.  For more details, see the Events guide.  Is Flamingock compatible with Spring Boot profiles? Yes. You can conditionally run ChangeUnits using @Profile, allowing changes to vary by environment.    ","version":"1.0.0","tagName":"h3"},{"title":"Configuration‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#configuration","content":" Where do I set MongoDB connection options like write concern or read preference? You can define these directly in the config using dedicated properties (e.g. mongodb.writeConcern.w, readPreference, etc.). Refer to the extra configuration section for detailed examples.  Can I inject Spring beans or other services into my ChangeUnits? Yes. Flamingock supports full dependency injection in both Spring and non-Spring environments.  Can I define ChangeUnit dependencies and execution order? Yes. ChangeUnits can declare dependencies via annotations or configuration metadata. See ChangeUnit deep dive for more.    ","version":"1.0.0","tagName":"h3"},{"title":"Testing and development‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#testing-and-development","content":" How do I test Flamingock ChangeUnits? You can perform unit, integration, and Spring Boot integration tests using test runners and mocking utilities.  Can I use templates to generate ChangeUnits? Yes. Flamingock offers a templating mechanism for creating new ChangeUnits and defining reusable components.    ","version":"1.0.0","tagName":"h3"},{"title":"Migrating from Mongock‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#migrating-from-mongock","content":" What‚Äôs the relationship between Flamingock and Mongock? Flamingock is the direct evolution of Mongock. While it inherits the core idea of tracking and executing changes reliably, Flamingock is a complete architectural and conceptual redesign aimed at overcoming the limitations of Mongock.  Some of the key advancements introduced by Flamingock include:  Cloud-native capabilities: Support for cloud-managed storage and execution, enabling Flamingock to run in distributed, serverless, or ephemeral environments without additional setup.Execution stages and pipelines: A structured way to group and orchestrate ChangeUnits by context, environment, or lifecycle stage.Modular architecture: Clean separation of core, editions, templates, and integrations, enabling better extensibility and maintainability.Template-based ChangeUnits: An additional declarative mechanism to define reusable changes without writing Java code, accelerating development and standardisation.  While Flamingock retains conceptual compatibility with Mongock, it represents a significant leap forward in flexibility, scalability, and developer experience.  If you are currently using Mongock, we encourage you to review the migration guide and explore what Flamingock can offer in modern change management.    ","version":"1.0.0","tagName":"h3"},{"title":"Recovery Strategies & Safety‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#recovery-strategies--safety","content":" What are recovery strategies and why do I need them? Recovery strategies determine how Flamingock handles failures - the key differentiator from traditional tools that retry blindly or fail silently. You choose between:  MANUAL_INTERVENTION (default): Stop and alert for human review when uncertainALWAYS_RETRY: Continue automatically until successful for idempotent operations  This prevents silent data corruption and gives you operational control based on your risk tolerance.  When should I use MANUAL_INTERVENTION vs ALWAYS_RETRY? Use MANUAL_INTERVENTION for:  Financial transactionsUser data modificationsCritical business logicNon-idempotent operationsCompliance-sensitive changes  Use ALWAYS_RETRY for:  Cache warming operationsIdempotent API callsEvent publishing (with consistent keys)Configuration updatesIndex creationFile operations with overwrite  How do I know if my operation is idempotent? An operation is idempotent if running it multiple times produces the same result as running it once. Examples:  ‚úÖ SET user.status = 'active' (same result every time)‚úÖ CREATE INDEX IF NOT EXISTS (safe to repeat)‚úÖ File overwrite with same content‚ùå INCREMENT user.score (different result each time)‚ùå Append operations‚ùå Time-sensitive calculations  What is the issue resolution workflow?  Detection: flamingock issue list shows all unresolved issuesTriage: flamingock issue get provides next priority issue with guidanceInvestigation: Check target system state (not audit store)Resolution: flamingock audit fix -c change-id --resolution APPLIED|ROLLED_BACK  This structured workflow eliminates guesswork and provides complete audit trails.  Can I change recovery strategies after deployment? Yes, you can update the @Recovery annotation in your code and redeploy. Existing audit entries maintain their state, but new executions use the updated strategy.  How does Cloud Edition improve recovery without changing my code? Cloud Edition uses the same recovery strategies but provides enhanced outcomes through:  Intelligent automation: Advanced reconciliation and marker mechanismsEnhanced retry logic: Sophisticated backoff and circuit breaker patternsAutomatic issue resolution: Many failures requiring manual intervention in Community Audit Stores are resolved automatically  Your change definitions remain identical - Cloud Edition just delivers better results.    ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise & Operational Concerns‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#enterprise--operational-concerns","content":" How does Flamingock ensure data integrity in distributed systems? Flamingock uses a dual-architecture separating target systems (where changes are applied) from audit store (execution tracking):  Complete audit trail: Every change attempt recorded regardless of business system failuresRecovery capabilities: CLI operates on audit state, you fix business systemsCompliance independence: Audit integrity maintained during business system issuesGovernance separation: Business and compliance data have different access patterns  What compliance and audit capabilities does Flamingock provide?  Complete execution history with timestamp, author, system, and outcomeIssue tracking and resolution workflows for failed changesCLI-based audit management for governance and complianceIntegration ready for external observability platforms (ELK, Prometheus, Datadog)Regulatory reporting capabilities in Cloud Edition  How does Flamingock compare to traditional migration tools?  Aspect\tFlyway/Liquibase\tMongock\tFlamingockFocus\tSQL databases\tMongoDB only\tAll systems Distributed Systems\t‚ùå Not designed for\t‚ùå Limited\t‚úÖ First-class support Non-transactional\t‚ùå No support\t‚ùå Assumes transactions\t‚úÖ Full support Failure Handling\tRetry blindly\tRetry blindly\tConfigurable strategies Issue Resolution\tManual SQL\tNone\tCLI + Cloud automation Safety Default\tNone\tNone\tMANUAL_INTERVENTION  Can Flamingock handle multi-system coordination? Yes, Flamingock is designed for distributed systems. A single ChangeUnit can coordinate changes across multiple target systems (databases, APIs, message queues) while maintaining a unified audit trail and recovery strategy.  How do I ensure my team adopts Flamingock safely?  Start conservative: Use MANUAL_INTERVENTION (default) initiallyEstablish governance: Define organization-wide recovery strategy guidelinesCreate runbooks: Document investigation procedures for your changesTrain on CLI: Ensure team knows issue resolution workflowMonitor patterns: Review failure patterns to optimize strategies over time  What happens if the audit store goes down? Flamingock's safety guarantee: No business changes applied without proper audit tracking. If the audit store is unavailable:  Flamingock stops execution safelyNo changes are applied to target systemsSystem remains in safe, known stateResume automatically once audit store connectivity is restored  Can I use Flamingock in microservices architectures? Absolutely. Flamingock is designed for distributed systems:  Each microservice can have its own ChangeUnits for its domainShared audit store provides cross-service visibility (especially in Cloud Edition)CLI provides centralized operational control across all servicesRecovery strategies can be tailored per service's risk profile  What are the organizational benefits of adopting Flamingock?  Risk reduction: Prevent silent data corruption through safety-first defaultsTeam velocity: Eliminate deployment bottlenecks with autonomous change managementOperational excellence: Centralized governance with distributed executionCompliance automation: Complete audit trails and governance workflowsReduced dependencies: Teams control their domain without infrastructure dependencies  How does Flamingock support regulatory compliance requirements?  Complete audit trails with immutable execution historyGovernance workflows for change approval and reviewIssue resolution documentation for regulatory reportingCLI integration for compliance automationSeparation of concerns between business and compliance dataCloud Edition features: Advanced reporting, RBAC, multi-environment governance    ","version":"1.0.0","tagName":"h3"},{"title":"Other‚Äã","type":1,"pageTitle":"FAQ","url":"/docs/resources/faq#other","content":" Is Flamingock open-source? Yes. The Flamingock client library ‚Äî used across all editions, including Community, Self-managed, and Cloud ‚Äî is fully open-source.  For the Cloud and Self-managed editions, additional enterprise components such as the server runtime, dashboards, and governance tools are provided under a commercial licence. These components build on top of the open-source core to deliver advanced features like observability, orchestration, and centralised management.  Is there a CLI available? Yes! The Flamingock CLI provides enterprise-grade operational control for issue resolution, audit management, and maintenance tasks.    If your question is not listed here, please check the corresponding edition‚Äôs guide or open an issue on our GitHub repository. ","version":"1.0.0","tagName":"h3"},{"title":"Upgrade from Mongock to Flamingock","type":0,"sectionRef":"#","url":"/docs/resources/upgrade-from-mongock","content":"","keywords":"","version":"1.0.0"},{"title":"Upgrade steps (at a glance)‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#upgrade-steps-at-a-glance","content":" Update ChangeUnit imports ‚Äì Replace Mongock annotations with Flamingock equivalents.Upgrade application code ‚Äì Replace Mongock API usage with the Flamingock builder(or Spring annotation).Create system stage ‚Äì Add a template-based ChangeUnit that imports legacy audit records.Configure pipeline ‚Äì Point Flamingock to your legacy and new ChangeUnit packages.  That‚Äôs it! Once complete, Flamingock runs with your full history intact.  ","version":"1.0.0","tagName":"h2"},{"title":"Step1: Update artefacts‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step1-update-artefacts","content":" Replace the Mongock artefacts with Flamingock ones.  Mongock  implementation(platform(&quot;io.mongock:mongock-bom:5.5.0&quot;)) implementation(&quot;io.mongock:mongock-standalone&quot;) implementation(&quot;io.mongock:mongodb-sync-v4-driver&quot;)   Flamingock  implementation(platform(&quot;io.flamingock:flamingock-cloud-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-mongodb-sync&quot;) annotationProcessor(&quot;io.flamingock:flamingock-processor:$flamingockVersion&quot;)   ","version":"1.0.0","tagName":"h2"},{"title":"Step 1: Update ChangeUnit imports‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-1-update-changeunit-imports","content":" Update these imports in your existing ChangeUnits (keep them in their current packages):  Mongock import\tFlamingock importio.mongock.api.annotations.ChangeUnit\tio.flamingock.api.annotations.ChangeUnit io.mongock.api.annotations.Execution\tio.flamingock.api.annotations.Execution io.mongock.api.annotations.RollbackExecution\tio.flamingock.api.annotations.RollbackExecution  Legacy Support For existing change units: Keep them exactly as they are in their current packages - only update imports to maintain immutability.For new change units: Avoid using @BeforeExecution and @RollbackBeforeExecution. Instead, use dedicated @Execution and @RollbackExecution methods for better separation of concerns@BeforeExecution and @RollbackBeforeExecution from io.mongock.api are supported for backward compatibility  ","version":"1.0.0","tagName":"h2"},{"title":"Step 2: Upgrade application code‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-2-upgrade-application-code","content":" Flamingock(new)Mongock(legacy) Flamingock.builder() .addDependency(mongoClient) .addDependency(mongoDatabase) .build() .run();   ","version":"1.0.0","tagName":"h2"},{"title":"Key changes:‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#key-changes","content":" Replace MongockStandalone with Flamingock.builder()Remove explicit driver setup (Flamingock auto-configures it)Remove package scanning in favor of pipeline configInject dependencies via .addDependency()  For Spring Boot integration, see the Spring Boot guide.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 3: Create system stage‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-3-create-system-stage","content":" The system stage is a special stage handled by Flamingock for system-level operations. In this upgrade context, you'll create a template-based change unit in the system stage package to handle audit records migration.  Create a YAML file (e.g., _0001_upgrade_from_mongock.yaml) with the following structure:  id: upgrade-from-mongock order: 0001 template: MongoDbImporterChangeTemplate configuration: origin: mongockChangeLog failOnEmptyOrigin: true   Configuration parameters:  id: Choose how you want to identify this change unitorder: Should be the first one (0001) as this is typically the first system stage change unittemplate: Available templates: MongoDbImporterChangeTemplate, DynamoDbImporterChangeTemplate, CouchbaseImporterChangeTemplateorigin: The collection/table where Mongock's audit log is stored (typically mongockChangeLog)failOnEmptyOrigin: (Optional) Set to false to disable the security check that ensures the origin contains data. By default, Flamingock verifies the origin collection/table has content to prevent importing from the wrong source  ","version":"1.0.0","tagName":"h2"},{"title":"Step 4: Configure setup‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#step-4-configure-setup","content":" Configure Flamingock using the @EnableFlamingock annotation. Add this annotation to any class in your application:  @EnableFlamingock( stages = { @Stage(type = SYSTEM, location = &quot;com.yourapp.flamingock.system&quot;), @Stage(type = LEGACY, location = &quot;com.yourapp.mongock&quot;), @Stage(location = &quot;com.yourapp.flamingock.changes&quot;) } ) public class FlamingockConfig { // Configuration class }   ","version":"1.0.0","tagName":"h2"},{"title":"Configuration explained:‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#configuration-explained","content":" Stage types and usage:  System stage - A special stage for framework-level changeUnits handled by Flamingock itself. In this context, it contains the changeUnit(provided by flamingock team) that copies Mongock‚Äôs audit data into Flamingock‚Äôs storeLegacy stage - Designed specifically for the changeUnits that originally came from the legacy tool (here, Mongock). Flamingock treats it as read-only: it runs only the units that never executed under Mongock and skips those already recorded in the imported audit history. Do not add new ChangeUnits to this stage.Standard stage (default): For new Flamingock-native change units. This is where all your new application changes should be added going forward  For advanced stage configurations and multi-stage scenarios, see the setup &amp; stages guide  ","version":"1.0.0","tagName":"h3"},{"title":"Run and validate‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#run-and-validate","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Running the upgrade‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#running-the-upgrade","content":" ./gradlew run   ","version":"1.0.0","tagName":"h3"},{"title":"Expected output‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#expected-output","content":" After running Flamingock, you should see output similar to:  Stage: flamingock-system-stage 0001) id: upgrade-from-mongock Started ‚úÖ - OK Executed ‚úÖ - OK Audited[execution] ‚úÖ - OK Stage: Application Changes 0001) id: create-users-collection-with-index Started ‚úÖ - OK Executed ‚úÖ - OK Audited[execution] ‚úÖ - OK 0002) id: seed-users Started ‚úÖ - OK Executed ‚úÖ - OK Audited[execution] ‚úÖ - OK   ","version":"1.0.0","tagName":"h3"},{"title":"Validation checklist‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#validation-checklist","content":" ‚úÖ System stage executes the upgrade changeUnit successfully‚úÖ Already-applied existing changeUnits from Mongock are not reapplied‚úÖ Previously unapplied existing changeUnits from Mongock execute without errors‚úÖ New Flamingock changeUnits execute as expected‚úÖ All audit logs are properly created in Flamingock format‚úÖ Database changes match the expected results    ","version":"1.0.0","tagName":"h3"},{"title":"Why upgrade instead of removing or starting fresh?‚Äã","type":1,"pageTitle":"Upgrade from Mongock to Flamingock","url":"/docs/resources/upgrade-from-mongock#why-upgrade-instead-of-removing-or-starting-fresh","content":" Preserve your audit trail ‚Äì Every historical ChangeUnit and its execution log remains intact for compliance and debugging.Avoid unintended re-runs ‚Äì Flamingock imports Mongock‚Äôs history, so previously-executed ChangeUnits are never applied twice.Keep change-as-code semantics ‚Äì The act of migrating the audit store itself is handled as a versioned change, reinforcing the idea that history is part of your application.Future continuity ‚Äì Teams and tools that rely on Mongock‚Äôs records can transition seamlessly; dashboards and reports will show an unbroken timeline.    Ready to upgrade? See the pipeline &amp; stages guide and ChangeUnit reference.  Complete example project: https://github.com/flamingock/flamingock-examples/tree/master/import-from-mongock ","version":"1.0.0","tagName":"h2"},{"title":"Safety Patterns","type":0,"sectionRef":"#","url":"/docs/recovery-and-safety/safety-patterns","content":"","keywords":"","version":"1.0.0"},{"title":"Core Safety Principles‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#core-safety-principles","content":" ","version":"1.0.0","tagName":"h2"},{"title":"1. Explicit is Better Than Implicit‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#1-explicit-is-better-than-implicit","content":" Always be explicit about your intentions and system boundaries.  // ‚úÖ Explicit and clear @TargetSystem(&quot;user-database&quot;) // Clear target @ChangeUnit(id = &quot;user-status-update&quot;, transactional = true) // Explicit transaction control @Recovery(strategy = RecoveryStrategy.MANUAL_INTERVENTION) // Explicit strategy public class UserStatusUpdate { } // ‚ùå Implicit and unclear @ChangeUnit(id = &quot;update&quot;) // Unclear intent public class Update { } // No target, relies on defaults   ","version":"1.0.0","tagName":"h3"},{"title":"2. Design for Failure‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#2-design-for-failure","content":" Every change should anticipate and handle failure scenarios.  @TargetSystem(&quot;payment-system&quot;) @ChangeUnit(id = &quot;process-payment-batch&quot;, order = &quot;001&quot;, author = &quot;finance-team&quot;) public class ProcessPaymentBatch { @Execution public void execute(PaymentService paymentService) { List&lt;Payment&gt; pendingPayments = paymentService.getPendingPayments(); for (Payment payment : pendingPayments) { try { paymentService.processPayment(payment); // Mark individual payment as processed for granular tracking paymentService.markAsProcessed(payment.getId()); } catch (PaymentException e) { // Log failure but continue with other payments logger.error(&quot;Failed to process payment {}: {}&quot;, payment.getId(), e.getMessage()); paymentService.markAsFailed(payment.getId(), e.getMessage()); } } } @RollbackExecution public void rollback(PaymentService paymentService) { // Rollback only successfully processed payments List&lt;Payment&gt; processedPayments = paymentService.getProcessedPayments(); for (Payment payment : processedPayments) { paymentService.revertPayment(payment); } } }   ","version":"1.0.0","tagName":"h3"},{"title":"3. Idempotency by Design‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#3-idempotency-by-design","content":" When possible, design operations to be naturally idempotent.  // ‚úÖ Idempotent by design @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;set-user-preferences&quot;, author = &quot;product-team&quot;) @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) // Safe because idempotent public class SetUserPreferences { @Execution public void execute(MongoDatabase userDb) { // SET operations are naturally idempotent userDb.getCollection(&quot;users&quot;) .updateMany( new Document(), // All users new Document(&quot;$set&quot;, new Document(&quot;preferences&quot;, defaultPreferences())) ); } } // ‚ùå Non-idempotent design public class IncrementUserScores { @Execution public void execute(MongoDatabase userDb) { // INCREMENT is not idempotent - each run changes the result userDb.getCollection(&quot;users&quot;) .updateMany(new Document(), new Document(&quot;$inc&quot;, new Document(&quot;score&quot;, 10))); } }     ","version":"1.0.0","tagName":"h3"},{"title":"Enterprise Safety Patterns‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#enterprise-safety-patterns","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Pattern 1: Critical Path Protection‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#pattern-1-critical-path-protection","content":" Use Case: Financial operations, user authentication, compliance-sensitive changes  @TargetSystem(&quot;financial-database&quot;) @ChangeUnit(id = &quot;update-account-balances&quot;, order = &quot;001&quot;, author = &quot;finance-team&quot;, transactional = true) // Leverage database transactions // MANUAL_INTERVENTION default - explicit safety public class UpdateAccountBalances { @Execution public void execute(MongoDatabase financialDb, AuditLogger auditLogger) { MongoCollection&lt;Document&gt; accounts = financialDb.getCollection(&quot;accounts&quot;); // Pre-execution validation long totalBefore = calculateTotalBalance(accounts); auditLogger.logBalanceSnapshot(&quot;before&quot;, totalBefore); // Critical financial operation accounts.updateMany( eq(&quot;status&quot;, &quot;pending_interest&quot;), combine( set(&quot;status&quot;, &quot;interest_applied&quot;), inc(&quot;balance&quot;, calculateInterest()), set(&quot;lastInterestDate&quot;, new Date()) ) ); // Post-execution validation long totalAfter = calculateTotalBalance(accounts); auditLogger.logBalanceSnapshot(&quot;after&quot;, totalAfter); // Invariant check if (Math.abs(totalAfter - totalBefore - expectedInterestTotal()) &gt; 0.01) { throw new BalanceInconsistencyException(&quot;Total balance invariant violated&quot;); } } @RollbackExecution public void rollback(MongoDatabase financialDb, AuditLogger auditLogger) { auditLogger.logRollbackStart(&quot;update-account-balances&quot;); MongoCollection&lt;Document&gt; accounts = financialDb.getCollection(&quot;accounts&quot;); accounts.updateMany( eq(&quot;status&quot;, &quot;interest_applied&quot;), combine( set(&quot;status&quot;, &quot;pending_interest&quot;), inc(&quot;balance&quot;, -calculateInterest()), unset(&quot;lastInterestDate&quot;) ) ); auditLogger.logRollbackComplete(&quot;update-account-balances&quot;); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Pattern 2: Idempotent Operations with Retry‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#pattern-2-idempotent-operations-with-retry","content":" Use Case: Cache warming, event publishing, infrastructure setup  @TargetSystem(&quot;messaging-infrastructure&quot;) @ChangeUnit(id = &quot;setup-kafka-topics&quot;, order = &quot;002&quot;, author = &quot;platform-team&quot;, transactional = false) // External system calls @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) // Safe to retry public class SetupKafkaTopics { @Execution public void execute(KafkaAdminClient kafkaAdmin) { List&lt;NewTopic&gt; requiredTopics = Arrays.asList( new NewTopic(&quot;user-events&quot;, 10, (short) 3), new NewTopic(&quot;order-events&quot;, 15, (short) 3), new NewTopic(&quot;notification-events&quot;, 5, (short) 3) ); // Get existing topics to avoid creating duplicates Set&lt;String&gt; existingTopics = kafkaAdmin.listTopics().names().get(); List&lt;NewTopic&gt; topicsToCreate = requiredTopics.stream() .filter(topic -&gt; !existingTopics.contains(topic.name())) .collect(Collectors.toList()); if (!topicsToCreate.isEmpty()) { // Topic creation is idempotent - safe to retry kafkaAdmin.createTopics(topicsToCreate).all().get(); logger.info(&quot;Created {} new topics: {}&quot;, topicsToCreate.size(), topicsToCreate.stream().map(NewTopic::name).collect(Collectors.toList())); } else { logger.info(&quot;All required topics already exist&quot;); } } @RollbackExecution public void rollback(KafkaAdminClient kafkaAdmin) { // For infrastructure setup, rollback usually means cleanup List&lt;String&gt; topicNames = Arrays.asList(&quot;user-events&quot;, &quot;order-events&quot;, &quot;notification-events&quot;); kafkaAdmin.deleteTopics(topicNames); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Pattern 3: Progressive Migration‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#pattern-3-progressive-migration","content":" Use Case: Large-scale data transformations, phased rollouts  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;migrate-user-profiles-batch-1&quot;, order = &quot;003&quot;, author = &quot;data-team&quot;, transactional = false) // Large operation, process in batches public class MigrateUserProfilesBatch1 { private static final int BATCH_SIZE = 1000; private static final String MIGRATION_MARKER = &quot;profile_v2_migration&quot;; @Execution public void execute(MongoDatabase userDb) { MongoCollection&lt;Document&gt; users = userDb.getCollection(&quot;users&quot;); // Process only users without migration marker (idempotent) FindIterable&lt;Document&gt; unmigrated = users.find( and( exists(&quot;profileVersion&quot;, false), // Old schema exists(MIGRATION_MARKER, false) // Not yet processed ) ).limit(BATCH_SIZE); int processed = 0; for (Document user : unmigrated) { try { // Transform user profile to new schema Document newProfile = transformProfile(user); users.updateOne( eq(&quot;_id&quot;, user.getObjectId(&quot;_id&quot;)), combine( set(&quot;profile&quot;, newProfile), set(&quot;profileVersion&quot;, 2), set(MIGRATION_MARKER, new Date()) // Mark as processed ) ); processed++; } catch (Exception e) { logger.error(&quot;Failed to migrate user {}: {}&quot;, user.getObjectId(&quot;_id&quot;), e.getMessage()); // Mark this user as failed for separate handling users.updateOne( eq(&quot;_id&quot;, user.getObjectId(&quot;_id&quot;)), set(&quot;migrationError&quot;, e.getMessage()) ); } } logger.info(&quot;Migrated {} user profiles in this batch&quot;, processed); // Check if more batches are needed long remaining = users.countDocuments( and( exists(&quot;profileVersion&quot;, false), exists(MIGRATION_MARKER, false), exists(&quot;migrationError&quot;, false) // Exclude failed ones ) ); if (remaining &gt; 0) { logger.info(&quot;{} users remaining for migration&quot;, remaining); } else { logger.info(&quot;User profile migration completed successfully&quot;); } } @RollbackExecution public void rollback(MongoDatabase userDb) { MongoCollection&lt;Document&gt; users = userDb.getCollection(&quot;users&quot;); // Rollback users that were migrated in this execution users.updateMany( exists(MIGRATION_MARKER), combine( unset(&quot;profile&quot;), unset(&quot;profileVersion&quot;), unset(MIGRATION_MARKER), unset(&quot;migrationError&quot;) ) ); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Pattern 4: Multi-System Coordination‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#pattern-4-multi-system-coordination","content":" Use Case: Distributed system synchronization, event sourcing, complex workflows  @TargetSystem(&quot;user-database&quot;) // Primary system @ChangeUnit(id = &quot;sync-user-data-across-systems&quot;, order = &quot;004&quot;, author = &quot;integration-team&quot;, transactional = false) // Multi-system can't be transactional public class SyncUserDataAcrossSystems { @Execution public void execute(MongoDatabase userDb, ElasticsearchOperations searchOps, KafkaTemplate&lt;String, Object&gt; eventPublisher, RedisTemplate&lt;String, Object&gt; cacheOps) { // Get users that need synchronization List&lt;User&gt; usersToSync = findUsersNeedingSync(userDb); List&lt;String&gt; processedUsers = new ArrayList&lt;&gt;(); try { for (User user : usersToSync) { // Step 1: Update primary database updateUserInDatabase(userDb, user); // Step 2: Update search index indexUserInElasticsearch(searchOps, user); // Step 3: Update cache updateUserInCache(cacheOps, user); // Step 4: Publish change event publishUserChangeEvent(eventPublisher, user); // Track successful processing processedUsers.add(user.getId()); // Mark user as synchronized markUserAsSynced(userDb, user.getId()); } } catch (Exception e) { logger.error(&quot;Multi-system sync failed for user batch. Processed: {}. Error: {}&quot;, processedUsers.size(), e.getMessage()); // Store progress information for rollback storeProcessingProgress(userDb, processedUsers); throw e; // Re-throw to trigger rollback } } @RollbackExecution public void rollback(MongoDatabase userDb, ElasticsearchOperations searchOps, KafkaTemplate&lt;String, Object&gt; eventPublisher, RedisTemplate&lt;String, Object&gt; cacheOps) { // Get list of users that were processed before failure List&lt;String&gt; processedUsers = getProcessingProgress(userDb); for (String userId : processedUsers) { try { // Reverse each step in opposite order publishUserRollbackEvent(eventPublisher, userId); removeUserFromCache(cacheOps, userId); removeUserFromElasticsearch(searchOps, userId); rollbackUserInDatabase(userDb, userId); } catch (Exception e) { logger.error(&quot;Failed to rollback user {}: {}&quot;, userId, e.getMessage()); // Continue with other users - partial rollback is better than none } } // Clean up progress tracking clearProcessingProgress(userDb); } }     ","version":"1.0.0","tagName":"h3"},{"title":"Operational Safety Patterns‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#operational-safety-patterns","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Pattern 5: Environment-Aware Changes‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#pattern-5-environment-aware-changes","content":" Use Case: Different behavior across environments, gradual rollouts  @TargetSystem(&quot;feature-flags&quot;) @ChangeUnit(id = &quot;enable-new-checkout&quot;, order = &quot;005&quot;, author = &quot;product-team&quot;) @Recovery(strategy = RecoveryStrategy.ALWAYS_RETRY) // Feature flags are idempotent public class EnableNewCheckout { @Execution public void execute(FeatureFlagService flagService, @Value(&quot;${spring.profiles.active}&quot;) String environment) { FeatureFlagConfig config = buildConfigForEnvironment(environment); switch (environment) { case &quot;development&quot;: // Full rollout in dev flagService.enableFlag(&quot;new-checkout&quot;, config.withRollout(100)); break; case &quot;staging&quot;: // Full rollout in staging flagService.enableFlag(&quot;new-checkout&quot;, config.withRollout(100)); break; case &quot;production&quot;: // Gradual rollout in production flagService.enableFlag(&quot;new-checkout&quot;, config.withRollout(5)); // Start with 5% break; default: logger.warn(&quot;Unknown environment: {}. Skipping feature flag change.&quot;, environment); } } @RollbackExecution public void rollback(FeatureFlagService flagService) { flagService.disableFlag(&quot;new-checkout&quot;); } }   ","version":"1.0.0","tagName":"h3"},{"title":"Pattern 6: Validation and Verification‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#pattern-6-validation-and-verification","content":" Use Case: Critical changes requiring validation, compliance requirements  @TargetSystem(&quot;compliance-database&quot;) @ChangeUnit(id = &quot;update-gdpr-consent&quot;, order = &quot;006&quot;, author = &quot;legal-team&quot;) public class UpdateGdprConsent { @Execution public void execute(MongoDatabase complianceDb, GdprService gdprService) { MongoCollection&lt;Document&gt; userConsents = complianceDb.getCollection(&quot;user_consents&quot;); // Pre-execution validation long totalUsers = userConsents.countDocuments(); long usersWithoutConsent = userConsents.countDocuments(exists(&quot;gdprConsent&quot;, false)); logger.info(&quot;Starting GDPR consent update. Total users: {}, Without consent: {}&quot;, totalUsers, usersWithoutConsent); if (usersWithoutConsent == 0) { logger.info(&quot;All users already have GDPR consent recorded. No action needed.&quot;); return; } // Execute the change UpdateResult result = userConsents.updateMany( exists(&quot;gdprConsent&quot;, false), combine( set(&quot;gdprConsent&quot;, buildDefaultConsent()), set(&quot;consentUpdatedDate&quot;, new Date()), set(&quot;consentSource&quot;, &quot;system-migration&quot;) ) ); // Post-execution validation long updatedCount = result.getModifiedCount(); long stillWithoutConsent = userConsents.countDocuments(exists(&quot;gdprConsent&quot;, false)); logger.info(&quot;GDPR consent update completed. Updated: {}, Remaining without consent: {}&quot;, updatedCount, stillWithoutConsent); // Validation checks if (updatedCount != usersWithoutConsent) { throw new ValidationException( String.format(&quot;Expected to update %d users but actually updated %d&quot;, usersWithoutConsent, updatedCount)); } if (stillWithoutConsent &gt; 0) { logger.warn(&quot;Some users still without consent after migration: {}&quot;, stillWithoutConsent); } // Compliance reporting gdprService.reportConsentUpdate(updatedCount, &quot;system-migration&quot;); } @RollbackExecution public void rollback(MongoDatabase complianceDb, GdprService gdprService) { MongoCollection&lt;Document&gt; userConsents = complianceDb.getCollection(&quot;user_consents&quot;); // Rollback only system-generated consent entries UpdateResult result = userConsents.updateMany( eq(&quot;consentSource&quot;, &quot;system-migration&quot;), combine( unset(&quot;gdprConsent&quot;), unset(&quot;consentUpdatedDate&quot;), unset(&quot;consentSource&quot;) ) ); logger.info(&quot;Rolled back GDPR consent for {} users&quot;, result.getModifiedCount()); gdprService.reportConsentRollback(result.getModifiedCount(), &quot;system-migration&quot;); } }     ","version":"1.0.0","tagName":"h3"},{"title":"Anti-Patterns to Avoid‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#anti-patterns-to-avoid","content":" ","version":"1.0.0","tagName":"h2"},{"title":"‚ùå Anti-Pattern 1: Silent Failures‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#-anti-pattern-1-silent-failures","content":" // DON'T DO THIS @Execution public void execute(ExternalService service) { try { service.updateData(data); } catch (Exception e) { // Silent failure - no one knows this failed! logger.debug(&quot;Update failed: {}&quot;, e.getMessage()); } }   ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Better Approach:‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#-better-approach","content":" @Execution public void execute(ExternalService service) { try { service.updateData(data); } catch (ServiceUnavailableException e) { logger.error(&quot;Service temporarily unavailable: {}&quot;, e.getMessage()); throw new RetryableException(&quot;External service unavailable&quot;, e); } catch (ValidationException e) { logger.error(&quot;Data validation failed: {}&quot;, e.getMessage()); throw new PermanentException(&quot;Invalid data provided&quot;, e); } }   ","version":"1.0.0","tagName":"h3"},{"title":"‚ùå Anti-Pattern 2: Mixing Transactional and Non-Transactional‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#-anti-pattern-2-mixing-transactional-and-non-transactional","content":" // DON'T DO THIS @ChangeUnit(transactional = true) // This won't work for Kafka! public class MixedOperations { @Execution public void execute(MongoDatabase db, KafkaTemplate kafka) { db.getCollection(&quot;users&quot;).updateMany(...); // Transactional kafka.send(&quot;user-topic&quot;, event); // Non-transactional } }   ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Better Approach:‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#-better-approach-1","content":" // Separate concerns @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;update-users&quot;, transactional = true) public class UpdateUsers { } @TargetSystem(&quot;event-stream&quot;) @ChangeUnit(id = &quot;publish-events&quot;, transactional = false) public class PublishEvents { }   ","version":"1.0.0","tagName":"h3"},{"title":"‚ùå Anti-Pattern 3: Assuming Success‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#-anti-pattern-3-assuming-success","content":" // DON'T DO THIS @Execution public void execute(List&lt;ExternalService&gt; services) { for (ExternalService service : services) { service.update(); // What if some succeed and others fail? } }   ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Better Approach:‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#-better-approach-2","content":" @Execution public void execute(List&lt;ExternalService&gt; services) { List&lt;String&gt; successfulServices = new ArrayList&lt;&gt;(); try { for (ExternalService service : services) { service.update(); successfulServices.add(service.getId()); } } catch (Exception e) { // Store partial progress for rollback storeProgress(successfulServices); throw e; } }     ","version":"1.0.0","tagName":"h3"},{"title":"Best Practices Summary‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#best-practices-summary","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Design for Production‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#design-for-production","content":" Assume failures will happen - design changes to handle partial completionMake operations idempotent when possible to enable safe retryValidate inputs and outputs to catch issues earlyLog extensively for troubleshooting and audit purposes  ","version":"1.0.0","tagName":"h3"},{"title":"Choose the Right Strategy‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#choose-the-right-strategy","content":" MANUAL_INTERVENTION for critical, non-idempotent operationsALWAYS_RETRY for idempotent, low-risk operationsDocument your reasoning for recovery strategy decisions  ","version":"1.0.0","tagName":"h3"},{"title":"Implement Proper Rollback‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#implement-proper-rollback","content":" Always provide @RollbackExecution methodsTest rollback logic as thoroughly as execution logicHandle partial failures in rollback scenariosLog rollback operations for audit trails  ","version":"1.0.0","tagName":"h3"},{"title":"Monitor and Alert‚Äã","type":1,"pageTitle":"Safety Patterns","url":"/docs/recovery-and-safety/safety-patterns#monitor-and-alert","content":" Set up monitoring for change execution patternsCreate alerts for failure conditionsEstablish SLAs for issue resolutionReview patterns regularly to improve safety  Remember: Safety patterns are not just about preventing failures - they're about building confidence in your system evolution process and enabling your team to move fast while maintaining enterprise-grade reliability. ","version":"1.0.0","tagName":"h3"},{"title":"Couchbase Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/couchbase-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum recommended setup‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#minimum-recommended-setup","content":" CouchbaseTargetSystem couchbaseTarget = new CouchbaseTargetSystem(&quot;user-database&quot;) .withCluster(cluster) .withBucket(bucket);   While dependencies can be provided through the global context, we highly recommend injecting them directly at the target system level. This provides clearer scoping, better isolation between systems, and makes dependencies explicit and easier to track.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#dependencies","content":" Following Flamingock's dependency resolution hierarchy, you can provide dependencies via direct injection or global context.  ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#required-dependencies","content":" Dependency\tMethod\tDescriptionCluster\t.withCluster(cluster)\tCouchbase cluster connection - required for both ChangeUnit execution and transaction management Bucket\t.withBucket(bucket)\tTarget bucket instance - required for both ChangeUnit execution and transaction management  Remember: If not provided directly via .withXXX(), Flamingock searches the global context. If still not found:  Required dependencies will throw an exception  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#configuration-example","content":" Here's a comprehensive example showing dependency resolution:  // Target system with specific dependencies CouchbaseTargetSystem couchbaseTarget = new CouchbaseTargetSystem(&quot;user-database&quot;) .withCluster(productionCluster) // Target-specific cluster .withBucket(userBucket) // Target-specific bucket .addDependency(auditService); // Custom service for this target // Global context with different dependencies Flamingock.builder() .addDependency(defaultCluster) // Different cluster in global .addDependency(defaultBucket) // Different bucket in global .addDependency(emailService) // Available to all targets .addTargetSystems(couchbaseTarget) .build();   What gets resolved for ChangeUnits in &quot;user-database&quot;:  Cluster: Uses productionCluster (from target system, not defaultCluster from global)Bucket: Uses userBucket (from target system, not defaultBucket from global)AuditService: Available from target system contextEmailService: Available from global context  The target system context always takes precedence, ensuring proper isolation between different systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#transactional-support","content":" For a ChangeUnit to leverage Couchbase's transactional capabilities, it must use the AttemptContext parameter. Flamingock uses the injected Cluster and Bucket dependencies to create and manage this context's lifecycle - creating the transaction context before execution, committing on success, and rolling back on failure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;create-users&quot;, order = &quot;001&quot;) public class CreateUsers { @Execution public void execution(Cluster cluster, Bucket bucket, AttemptContext txContext) { // AttemptContext is required for transactional execution // Flamingock uses the target system's Cluster and Bucket to handle transaction operations // and manages transaction start, commit, and rollback automatically Collection collection = bucket.defaultCollection(); JsonObject user = JsonObject.create() .put(&quot;name&quot;, &quot;John Doe&quot;) .put(&quot;email&quot;, &quot;john@example.com&quot;); txContext.insert(collection, &quot;user::001&quot;, user); } }   You can also work with the Cluster and Bucket directly without transactions:  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;update-configs&quot;, order = &quot;002&quot;) public class UpdateConfigs { @Execution public void execution(Cluster cluster, Bucket bucket) { // Operations without AttemptContext won't participate in transactions Collection collection = bucket.defaultCollection(); JsonObject config = JsonObject.create() .put(&quot;version&quot;, &quot;2.0&quot;) .put(&quot;updated&quot;, Instant.now().toString()); collection.upsert(&quot;config::app&quot;, config); } }   How transactions work:  Context creation: Flamingock uses the target system's Cluster to create an AttemptContext for transaction managementTransaction management: The same Cluster and Bucket handle transaction operations and coordinate with the contextLifecycle: Flamingock automatically creates the transaction context, commits on success, or rolls back on failure  Without the AttemptContext parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in ChangeUnits‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#available-dependencies-in-changeunits","content":" Your ChangeUnits can inject Couchbase-specific dependencies like Cluster, Bucket, and AttemptContext (for transactions), but are not limited to these. Any dependency can be added to the target system context via .addDependency(), taking precedence over global dependencies.  For more details on dependency resolution, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Couchbase Target System","url":"/docs/target-systems/couchbase-target-system#next-steps","content":" Learn about Target system configurationExplore ChangeUnitsSee Couchbase examples ","version":"1.0.0","tagName":"h2"},{"title":"Default Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/default-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Why use DefaultTargetSystem?‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#why-use-defaulttargetsystem","content":" DefaultTargetSystem is the fallback choice when there's no specialized target system implementation available for your technology. While Flamingock provides dedicated target systems for technologies that benefit from specific handling (like transactional systems that leverage native rollback capabilities), many systems don't require such specialization.  When to use DefaultTargetSystem:  No dedicated target system exists for your technologyYour system doesn't have unique characteristics that warrant specialized handlingYou need a simple, flexible solution without technology-specific optimizations  Future extensibility: The Flamingock ecosystem may expand with more specialized target systems as specific needs are identified.  Common systems using DefaultTargetSystem: Kafka Schema Registry, message queues, object storage (S3), REST APIs, file systems, cache systems, feature flags, search engines  ","version":"1.0.0","tagName":"h2"},{"title":"Minimum recommended setup‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#minimum-recommended-setup","content":" DefaultTargetSystem schemaRegistry = new DefaultTargetSystem(&quot;kafka-schema-registry&quot;);   Unlike specialized target systems, DefaultTargetSystem requires no mandatory dependencies. You have complete flexibility to inject whatever dependencies your ChangeUnits need.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#dependencies","content":" Following Flamingock's dependency resolution hierarchy, you can provide dependencies via direct injection or global context.  ","version":"1.0.0","tagName":"h2"},{"title":"No required dependencies‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#no-required-dependencies","content":" DefaultTargetSystem has no .withXXX() methods for required dependencies. This provides maximum flexibility for working with any type of system.  ","version":"1.0.0","tagName":"h3"},{"title":"Generic dependency injection‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#generic-dependency-injection","content":" All dependencies are provided through generic methods:  Method\tDescription.addDependency(object)\tAdd a dependency by type .addDependency(name, object)\tAdd a named dependency .setProperty(key, value)\tSet a configuration property  Remember: If not provided directly, Flamingock searches the global context for dependencies.  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#configuration-example","content":" Here's a comprehensive example showing dependency resolution:  // Target system with Kafka Schema Registry dependencies DefaultTargetSystem schemaRegistry = new DefaultTargetSystem(&quot;kafka-schema-registry&quot;) .addDependency(schemaRegistryClient) .addDependency(&quot;registry-url&quot;, &quot;http://schema-registry:8081&quot;) .setProperty(&quot;compatibility.level&quot;, &quot;BACKWARD&quot;); // Global context with shared dependencies Flamingock.builder() .addDependency(metricsService) // Available to all targets .addDependency(notificationService) // Available to all targets .addTargetSystems(schemaRegistry) .build();   What gets resolved for ChangeUnits in &quot;kafka-schema-registry&quot;:  SchemaRegistryClient: Available from target system contextRegistry URL: Available as &quot;registry-url&quot; from target system contextCompatibility level: Available as property from target system contextMetricsService: Available from global contextNotificationService: Available from global context  The target system context always takes precedence, ensuring proper isolation between different systems.  How compensation works:  No transaction boundaries: Operations execute immediately with no automatic rollbackRollback execution: If any failure occurs, Flamingock calls the @RollbackExecution methodManual compensation: You provide the logic to undo or compensate for the changes made  Important: Always provide @RollbackExecution methods for DefaultTargetSystem ChangeUnits to ensure safe rollback capabilities.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in ChangeUnits‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#available-dependencies-in-changeunits","content":" Your ChangeUnits can inject any dependencies you add to the target system context via .addDependency(), taking precedence over global dependencies. Common examples include system clients, configuration values, custom services, and properties.  For more details on dependency resolution, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"Default Target System","url":"/docs/target-systems/default-target-system#next-steps","content":" Learn about Target system configurationExplore ChangeUnitsSee DefaultTargetSystem examples ","version":"1.0.0","tagName":"h2"},{"title":"DynamoDB Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/dynamodb-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum recommended setup‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#minimum-recommended-setup","content":" DynamoDBTargetSystem dynamoTarget = new DynamoDBTargetSystem(&quot;inventory-database&quot;) .withDynamoDBClient(dynamoDbClient);   While dependencies can be provided through the global context, we highly recommend injecting them directly at the target system level. This provides clearer scoping, better isolation between systems, and makes dependencies explicit and easier to track.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#dependencies","content":" Following Flamingock's dependency resolution hierarchy, you can provide dependencies via direct injection or global context.  ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#required-dependencies","content":" Dependency\tMethod\tDescriptionDynamoDbClient\t.withDynamoDBClient(client)\tAWS DynamoDB client - required for both ChangeUnit execution and transaction management  Remember: If not provided directly via .withXXX(), Flamingock searches the global context. If still not found:  Required dependencies will throw an exception  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#configuration-example","content":" Here's a comprehensive example showing dependency resolution:  // Target system with specific dependencies DynamoDBTargetSystem dynamoTarget = new DynamoDBTargetSystem(&quot;inventory-database&quot;) .withDynamoDBClient(inventoryDynamoClient) // Target-specific client .addDependency(inventoryService); // Custom service for this target // Global context with different dependencies Flamingock.builder() .addDependency(defaultDynamoClient) // Different client in global .addDependency(emailService) // Available to all targets .addTargetSystems(dynamoTarget) .build();   What gets resolved for ChangeUnits in &quot;inventory-database&quot;:  DynamoDbClient: Uses inventoryDynamoClient (from target system, not defaultDynamoClient from global)InventoryService: Available from target system contextEmailService: Available from global context  The target system context always takes precedence, ensuring proper isolation between different systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#transactional-support","content":" For a ChangeUnit to leverage DynamoDB's transactional capabilities, it must use the TransactWriteItemsEnhancedRequest.Builder parameter. Flamingock uses the injected DynamoDbClient dependency to create and manage this builder's lifecycle - creating it before execution and executing the transaction with all operations on success.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;inventory-database&quot;) @ChangeUnit(id = &quot;update-inventory&quot;, order = &quot;001&quot;) public class UpdateInventory { @Execution public void execution(DynamoDbClient client, TransactWriteItemsEnhancedRequest.Builder txBuilder) { // The transaction builder is required for transactional execution // Flamingock uses the target system's DynamoDbClient to handle transaction operations // and manages transaction creation, execution, and rollback automatically DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder() .dynamoDbClient(client) .build(); DynamoDbTable&lt;Product&gt; table = enhancedClient.table(&quot;products&quot;, TableSchema.fromBean(Product.class)); // Add operations to the transaction txBuilder.addPutItem(table, new Product(&quot;123&quot;, &quot;Updated Product&quot;)); txBuilder.addDeleteItem(table, Key.builder().partitionValue(&quot;456&quot;).build()); } }   How transactions work:  Builder creation: Flamingock uses the target system's DynamoDbClient to create a TransactWriteItemsEnhancedRequest.BuilderTransaction management: The same DynamoDbClient executes the transaction with all accumulated operationsLifecycle: Flamingock automatically creates the builder, executes the transaction on success, or handles rollback on failure  Without the TransactWriteItemsEnhancedRequest.Builder parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in ChangeUnits‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#available-dependencies-in-changeunits","content":" Your ChangeUnits can inject DynamoDB-specific dependencies like DynamoDbClient and TransactWriteItemsEnhancedRequest.Builder, but are not limited to these. Any dependency can be added to the target system context via .addDependency(), taking precedence over global dependencies.  For more details on dependency resolution, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"DynamoDB Target System","url":"/docs/target-systems/dynamodb-target-system#next-steps","content":" Learn about Target system configurationExplore ChangeUnitsSee DynamoDB examples ","version":"1.0.0","tagName":"h2"},{"title":"Target systems","type":0,"sectionRef":"#","url":"/docs/target-systems/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Why target systems matter‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#why-target-systems-matter","content":" ","version":"1.0.0","tagName":"h2"},{"title":"Explicit ownership‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#explicit-ownership","content":" Every change is tied to a named target system, avoiding ambiguity and enabling clear governance.  ","version":"1.0.0","tagName":"h3"},{"title":"Transactionality awareness‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#transactionality-awareness","content":" Transactional target systems (like PostgreSQL, MySQL, or MongoDB with transactions) allow Flamingock to use native rollback and guarantees.Non-transactional systems (like S3, Kafka, or REST APIs) are still safe, but Flamingock relies on rollback methods you provide.  This distinction is built into the target system definition.  For detailed information on transaction handling, see Transactions.  ","version":"1.0.0","tagName":"h3"},{"title":"Dependency injection‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#dependency-injection","content":" Each target system can expose the dependencies required by its ChangeUnits. For example:  A MongoDB target system provides a MongoDatabaseA Kafka target system provides a KafkaTemplateA SQL target system provides a Connection or DataSource  Dependency resolution hierarchy‚Äã  Each target system needs specific dependencies to function (except DefaultTargetSystem which requires none). When Flamingock initializes a target system, it resolves dependencies using this hierarchy:  Direct injection via .withXXX() methods (highest priority)Global context lookup if not directly injectedDefault values for optional configurations, or exception for required ones  This approach provides maximum flexibility while ensuring all requirements are met:  MongoSyncTargetSystem mongoTarget = new MongoSyncTargetSystem(&quot;user-db&quot;) .withDatabase(database);   In this example, Flamingock resolves dependencies as follows:  MongoDatabase: Provided directly via .withDatabase(), so it's immediately availableMongoClient: Not provided directly, so Flamingock searches the global contextWriteConcern: Not found in either place, so uses the default value (MAJORITY with journal)If MongoClient is missing from the global context, Flamingock throws an exception since it's a required dependency  info ChangeUnits are not limited to target system dependencies. They can also request shared or application-level dependencies. Flamingock resolves them automatically, starting from the target system context and falling back to the general context.    ","version":"1.0.0","tagName":"h3"},{"title":"Registering target systems‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#registering-target-systems","content":" Target systems are registered at runtime with the Flamingock builder. You can define and register as many as you need:   SqlTargetSystem mysql = new SqlTargetSystem(&quot;mysql-inventory&quot;) .withDatasource(ds); DefaultTargetSystem s3 = new DefaultTargetSystem(&quot;aws-s3&quot;); DefaultTargetSystem kafka = new DefaultTargetSystem(&quot;kafka-stock&quot;); Flamingock.builder() .setAuditStore(new MongoSyncAuditStore(mongoClient, mongoDatabase)) .addTargetSystems(mysql, s3, kafka) .build() .run();   At startup, Flamingock automatically injects the right dependencies from the corresponding target system into each ChangeUnit.  ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot Integration‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#spring-boot-integration","content":" For Spring Boot applications, target systems are configured as beans:  @Bean public SqlTargetSystem sqlTargetSystem(DataSource dataSource) { return new SqlTargetSystem(&quot;mysql-inventory&quot;) .withDatasource(dataSource); } @Bean public DefaultTargetSystem kafkaTargetSystem() { return new DefaultTargetSystem(&quot;kafka-stock&quot;); }   Spring Boot's auto-configuration will automatically register these target systems with Flamingock.  For more details, see Spring Boot Integration.    ","version":"1.0.0","tagName":"h3"},{"title":"Linking ChangeUnits to target systems‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#linking-changeunits-to-target-systems","content":" When defining ChangeUnits, you specify which target system they belong to using the @TargetSystem annotation:  @TargetSystem(&quot;mysql-inventory&quot;) @ChangeUnit(id = &quot;add-category&quot;, order = &quot;001&quot;, author = &quot;team&quot;) public class _001_AddCategory { //... }     ","version":"1.0.0","tagName":"h2"},{"title":"Cloud Edition visibility‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#cloud-edition-visibility","content":" In the Cloud Edition, target systems become a first-class part of the dashboard:  See all changes grouped by target systemFilter execution history by systemTrack failures and recoveries per system  This makes it easier to govern and audit distributed environments at scale.    ","version":"1.0.0","tagName":"h2"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#best-practices","content":" Use descriptive names (mysql-inventory, aws-s3, kafka-stock)Be consistent across related ChangeUnitsAvoid generic names like &quot;database&quot; or &quot;api&quot;Provide rollback logic for non-transactional systemsKeep dependencies scoped to the system they belong to ‚Äî don‚Äôt overload the general context when they are system-specific    ","version":"1.0.0","tagName":"h2"},{"title":"Available target system implementations‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#available-target-system-implementations","content":" Flamingock provides several built-in target system implementations. The ecosystem includes specialized implementations for technologies that benefit from specific handling, and a universal fallback for everything else:  ","version":"1.0.0","tagName":"h2"},{"title":"Specialized target systems‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#specialized-target-systems","content":" These target systems provide optimized handling for specific technologies:  Transactional systems - Leverage native transaction capabilities for automatic rollback:  MongoDB target system - For MongoDB with the sync driverMongoDB Spring Data target system - For MongoDB with Spring DataSQL target system - For relational databases (PostgreSQL, MySQL, etc.)DynamoDB target system - For Amazon DynamoDBCouchbase target system - For Couchbase  ","version":"1.0.0","tagName":"h3"},{"title":"Universal fallback‚Äã","type":1,"pageTitle":"Target systems","url":"/docs/target-systems/introduction#universal-fallback","content":" For any system that doesn't require specialized handling:  Default target system - The fallback choice for any system without a dedicated implementation (Kafka Schema Registry, S3, REST APIs, file systems, etc.)  Future extensibility: The Flamingock ecosystem may expand with more specialized target systems as specific needs are identified. These can be implemented by the Flamingock team, community contributions, or custom implementations by users.    Key Takeaway: Target systems provide the foundation for safe, auditable changes across your entire technology stack. By explicitly declaring and configuring them, you enable Flamingock to orchestrate complex distributed system evolution with confidence. ","version":"1.0.0","tagName":"h3"},{"title":"MongoDB Spring Data Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/mongodb-springdata-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum recommended setup‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#minimum-recommended-setup","content":" MongoSpringDataTargetSystem mongoTarget = new MongoSpringDataTargetSystem(&quot;user-database&quot;) .withMongoTemplate(mongoTemplate);   While dependencies can be provided through the global context, we highly recommend injecting them directly at the target system level. This provides clearer scoping, better isolation between systems, and makes dependencies explicit and easier to track.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#dependencies","content":" Following Flamingock's dependency resolution hierarchy, you can provide dependencies via direct injection or global context.  ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#required-dependencies","content":" Dependency\tMethod\tDescriptionMongoTemplate\t.withMongoTemplate(template)\tSpring Data MongoDB template - required for both ChangeUnit execution and transaction management  ","version":"1.0.0","tagName":"h3"},{"title":"Optional configurations‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#optional-configurations","content":" Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads  Important: These default values are optimized for maximum consistency and should ideally be left unchanged. Override them only for testing purposes or exceptional cases where the defaults cannot be used (e.g., specific infrastructure limitations).  Remember: If not provided directly via .withXXX(), Flamingock searches the global context. If still not found:  Required dependencies will throw an exceptionOptional configurations will use the defaults shown above  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#configuration-example","content":" Here's a comprehensive example showing dependency resolution:  // Target system with specific dependencies MongoSpringDataTargetSystem mongoTarget = new MongoSpringDataTargetSystem(&quot;user-database&quot;) .withMongoTemplate(userMongoTemplate) // Target-specific template .addDependency(userAuditService); // Custom service for this target // Global context with different dependencies Flamingock.builder() .addDependency(defaultMongoTemplate) // Different template in global .addDependency(emailService) // Available to all targets .addTargetSystems(mongoTarget) .build();   What gets resolved for ChangeUnits in &quot;user-database&quot;:  MongoTemplate: Uses userMongoTemplate (from target system, not defaultMongoTemplate from global)UserAuditService: Available from target system contextEmailService: Available from global contextWriteConcern/ReadConcern: Use defaults (MAJORITY with journal)  The target system context always takes precedence, ensuring proper isolation between different systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#transactional-support","content":" Spring Data MongoDB target system integrates with Spring's transaction management. When a ChangeUnit is marked as transactional (the default), Flamingock uses the injected MongoTemplate dependency to handle transaction operations through Spring's infrastructure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;create-users&quot;, order = &quot;001&quot;) public class CreateUsers { @Execution public void execution(MongoTemplate mongoTemplate) { // MongoTemplate automatically participates in Spring transactions // Flamingock uses the target system's MongoTemplate for transaction management // through Spring's @Transactional infrastructure mongoTemplate.save(new User(&quot;john@example.com&quot;, &quot;John Doe&quot;)); } }   How transactions work:  Spring integration: Flamingock leverages the target system's MongoTemplate within Spring's transaction contextTransaction management: The same MongoTemplate handles both ChangeUnit operations and transaction coordinationLifecycle: Spring's transaction infrastructure manages start, commit, and rollback automatically  The transaction lifecycle is managed through Spring's transaction infrastructure, ensuring consistency with your existing Spring Data operations.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in ChangeUnits‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#available-dependencies-in-changeunits","content":" Your ChangeUnits can inject Spring Data dependencies like MongoTemplate, but are not limited to these. Any dependency can be added to the target system context via .addDependency(), taking precedence over global dependencies.  For more details on dependency resolution, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Spring integration‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#spring-integration","content":" This target system is designed to work seamlessly with Spring Boot applications. When using Spring Boot auto-configuration, your existing MongoTemplate beans are automatically available for injection into target systems.  For more information on Spring Boot integration, see Spring Boot integration.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Spring Data Target System","url":"/docs/target-systems/mongodb-springdata-target-system#next-steps","content":" Learn about Target system configurationExplore ChangeUnitsSee MongoDB Spring Data examples ","version":"1.0.0","tagName":"h2"},{"title":"SQL Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/sql-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum recommended setup‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#minimum-recommended-setup","content":" SqlTargetSystem sqlTarget = new SqlTargetSystem(&quot;inventory-database&quot;) .withDatasource(dataSource);   While dependencies can be provided through the global context, we highly recommend injecting them directly at the target system level. This provides clearer scoping, better isolation between systems, and makes dependencies explicit and easier to track.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#dependencies","content":" Following Flamingock's dependency resolution hierarchy, you can provide dependencies via direct injection or global context.  ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#required-dependencies","content":" Dependency\tMethod\tDescriptionDataSource\t.withDatasource(dataSource)\tJDBC DataSource connection pool - required for both ChangeUnit execution and transaction management  ","version":"1.0.0","tagName":"h3"},{"title":"Optional configurations‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#optional-configurations","content":" Configuration\tMethod\tDefault\tDescriptionConnection\t.withConnection(connection)\tNone\tDirect JDBC connection (alternative to DataSource)  Remember: If not provided directly via .withXXX(), Flamingock searches the global context. If still not found:  Required dependencies will throw an exception  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#configuration-example","content":" Here's a comprehensive example showing dependency resolution:  // Target system with specific dependencies SqlTargetSystem sqlTarget = new SqlTargetSystem(&quot;inventory-database&quot;) .withDatasource(inventoryDataSource) // Target-specific datasource .addDependency(inventoryService); // Custom service for this target // Global context with different dependencies Flamingock.builder() .addDependency(defaultDataSource) // Different datasource in global .addDependency(emailService) // Available to all targets .addTargetSystems(sqlTarget) .build();   What gets resolved for ChangeUnits in &quot;inventory-database&quot;:  DataSource: Uses inventoryDataSource (from target system, not defaultDataSource from global)InventoryService: Available from target system contextEmailService: Available from global context  The target system context always takes precedence, ensuring proper isolation between different systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#transactional-support","content":" For a ChangeUnit to leverage SQL's transactional capabilities, it must use either the DataSource or Connection parameter. Flamingock uses the injected DataSource dependency to create connections and manage the transaction lifecycle - starting the transaction before execution, committing on success, and rolling back on failure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;inventory-database&quot;) @ChangeUnit(id = &quot;update-products&quot;, order = &quot;001&quot;) public class UpdateProducts { @Execution public void execution(DataSource dataSource) throws SQLException { // DataSource automatically participates in transactions // Flamingock uses the target system's DataSource for transaction management // and handles transaction start, commit, and rollback automatically try (Connection conn = dataSource.getConnection()) { try (PreparedStatement stmt = conn.prepareStatement( &quot;INSERT INTO products (id, name, price) VALUES (?, ?, ?)&quot;)) { stmt.setString(1, &quot;P001&quot;); stmt.setString(2, &quot;Updated Product&quot;); stmt.setBigDecimal(3, new BigDecimal(&quot;19.99&quot;)); stmt.executeUpdate(); } } } }   You can also inject a Connection directly if you prefer to work with connections instead of DataSource:  @TargetSystem(&quot;inventory-database&quot;) @ChangeUnit(id = &quot;create-indexes&quot;, order = &quot;002&quot;) public class CreateIndexes { @Execution public void execution(Connection connection) throws SQLException { // Connection automatically participates in transactions // Flamingock uses the target system's connection for transaction operations // and handles transaction lifecycle automatically try (Statement stmt = connection.createStatement()) { stmt.execute(&quot;CREATE INDEX idx_product_name ON products(name)&quot;); } } }   How transactions work:  Connection management: Flamingock uses the target system's DataSource to obtain database connectionsTransaction management: The same DataSource or Connection handles transaction operations (begin, commit, rollback)Lifecycle: Flamingock automatically manages transaction boundaries, committing on success or rolling back on failure  Without the DataSource or Connection parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in ChangeUnits‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#available-dependencies-in-changeunits","content":" Your ChangeUnits can inject SQL-specific dependencies like DataSource and Connection, but are not limited to these. Any dependency can be added to the target system context via .addDependency(), taking precedence over global dependencies.  For more details on dependency resolution, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"SQL Target System","url":"/docs/target-systems/sql-target-system#next-steps","content":" Learn about Target system configurationExplore ChangeUnitsSee SQL examples ","version":"1.0.0","tagName":"h2"},{"title":"MongoDB Sync Target System","type":0,"sectionRef":"#","url":"/docs/target-systems/mongodb-target-system","content":"","keywords":"","version":"1.0.0"},{"title":"Minimum recommended setup‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#minimum-recommended-setup","content":" MongoSyncTargetSystem mongoTarget = new MongoSyncTargetSystem(&quot;user-database&quot;) .withMongoClient(mongoClient) .withDatabase(database);   While dependencies can be provided through the global context, we highly recommend injecting them directly at the target system level. This provides clearer scoping, better isolation between systems, and makes dependencies explicit and easier to track.  ","version":"1.0.0","tagName":"h2"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#dependencies","content":" Following Flamingock's dependency resolution hierarchy, you can provide dependencies via direct injection or global context.  ","version":"1.0.0","tagName":"h2"},{"title":"Required dependencies‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#required-dependencies","content":" Dependency\tMethod\tDescriptionMongoClient\t.withMongoClient(client)\tMongoDB connection client - required for both ChangeUnit execution and transaction management MongoDatabase\t.withDatabase(database)\tTarget database instance - required for both ChangeUnit execution and transaction management  ","version":"1.0.0","tagName":"h3"},{"title":"Optional configurations‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#optional-configurations","content":" Configuration\tMethod\tDefault\tDescriptionWriteConcern\t.withWriteConcern(concern)\tMAJORITY with journal\tWrite acknowledgment level ReadConcern\t.withReadConcern(concern)\tMAJORITY\tRead isolation level ReadPreference\t.withReadPreference(pref)\tPRIMARY\tServer selection for reads  Important: These default values are optimized for maximum consistency and should ideally be left unchanged. Override them only for testing purposes or exceptional cases where the defaults cannot be used (e.g., specific infrastructure limitations).  Remember: If not provided directly via .withXXX(), Flamingock searches the global context. If still not found:  Required dependencies will throw an exceptionOptional configurations will use the defaults shown above  ","version":"1.0.0","tagName":"h3"},{"title":"Configuration example‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#configuration-example","content":" Here's a comprehensive example showing dependency resolution:  // Target system with specific dependencies MongoSyncTargetSystem mongoTarget = new MongoSyncTargetSystem(&quot;user-database&quot;) .withMongoClient(productionMongoClient) // Target-specific client .withDatabase(userDatabase) // Target-specific database .addDependency(auditService); // Custom service for this target // Global context with different dependencies Flamingock.builder() .addDependency(defaultMongoClient) // Different client in global .addDependency(defaultDatabase) // Different database in global .addDependency(emailService) // Available to all targets .addTargetSystems(mongoTarget) .build();   What gets resolved for ChangeUnits in &quot;user-database&quot;:  MongoClient: Uses productionMongoClient (from target system, not defaultMongoClient from global)MongoDatabase: Uses userDatabase (from target system, not defaultDatabase from global)AuditService: Available from target system contextEmailService: Available from global contextWriteConcern/ReadConcern: Use defaults (MAJORITY with journal)  The target system context always takes precedence, ensuring proper isolation between different systems.  ","version":"1.0.0","tagName":"h2"},{"title":"Transactional support‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#transactional-support","content":" For a ChangeUnit to leverage MongoDB's transactional capabilities, it must use the ClientSession parameter. Flamingock uses the injected MongoClient and MongoDatabase dependencies to create and manage this session's lifecycle - starting the transaction before execution, committing on success, and rolling back on failure.  For detailed information on transaction handling, see Transactions.  @TargetSystem(&quot;user-database&quot;) @ChangeUnit(id = &quot;create-users&quot;, order = &quot;001&quot;) public class CreateUsers { @Execution public void execution(MongoDatabase db, ClientSession session) { // The ClientSession is required for transactional execution // Flamingock uses the target system's MongoClient to create this session // and handles transaction start, commit, and rollback automatically db.getCollection(&quot;users&quot;) .insertOne(session, new Document(&quot;name&quot;, &quot;John&quot;)); } }   How transactions work:  Session creation: Flamingock uses the target system's MongoClient to create a ClientSessionTransaction management: The same MongoClient and MongoDatabase handle transaction operationsLifecycle: Flamingock automatically starts the transaction, commits on success, or rolls back on failure  Without the ClientSession parameter, operations will execute but won't participate in transactions.  ","version":"1.0.0","tagName":"h2"},{"title":"Available dependencies in ChangeUnits‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#available-dependencies-in-changeunits","content":" Your ChangeUnits can inject MongoDB-specific dependencies like MongoClient, MongoDatabase, and ClientSession (for transactions), but are not limited to these. Any dependency can be added to the target system context via .addDependency(), taking precedence over global dependencies.  For more details on dependency resolution, see Context and dependencies.  ","version":"1.0.0","tagName":"h2"},{"title":"Next steps‚Äã","type":1,"pageTitle":"MongoDB Sync Target System","url":"/docs/target-systems/mongodb-target-system#next-steps","content":" Learn about Target system configurationExplore ChangeUnitsSee MongoDB examples ","version":"1.0.0","tagName":"h2"},{"title":"Template mapping","type":0,"sectionRef":"#","url":"/docs/templates/template-mapping-section","content":"","keywords":"","version":"1.0.0"},{"title":"How Execution and Rollback Mapping Works‚Äã","type":1,"pageTitle":"Template mapping","url":"/docs/templates/template-mapping-section#how-execution-and-rollback-mapping-works","content":" In a template-based change unit (declarative format), Flamingock uses the execution and rollback sections to determine which methods to invoke in your template class.  Execution‚Äã  The method annotated with @Execution is mandatory for the template developer.The execution section in the declarative change unit is mandatory for the user.If the execution section is missing, Flamingock throws an exception at startup.  Rollback‚Äã  The method annotated with @RollbackExecution is mandatory for the template developer.The rollback section in the declarative change unit is optional for the user.  The behavior of rollback varies depending on context:  Rollback during execution failure  If the system is transactional (e.g., MySQL), Flamingock relies on the system‚Äôs native transaction handling. It will not call the rollback method.If the system is non-transactional, Flamingock will: Attempt to call the @RollbackExecution method only if the user provides a rollback section in the declarative file.If no rollback config is provided, Flamingock skips the method call and logs the change as FAILED.  Rollback during Undo operations (manual reversion)  If a rollback section is present in the declarative file, Flamingock will call the @RollbackExecution method ‚Äî even if the change was previously applied successfully.If no rollback is provided, Flamingock skips the rollback logic, but still marks the change as ROLLED_BACK in the audit.  note In undo operations, if rollback is not defined in the declarative file, the change is marked as reverted even though no actual rollback was executed. It‚Äôs up to the user to ensure reversibility when needed. ","version":"1.0.0","tagName":"h3"},{"title":"How to use Flamingock Templates","type":0,"sectionRef":"#","url":"/docs/templates/templates-how-to-use","content":"","keywords":"","version":"1.0.0"},{"title":"Step 1: Add the Template dependency‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-1-add-the-template-dependency","content":" Ensure your Flamingock Template dependency is included in your project. Example of using sql-template:  GradleMaven implementation(platform(&quot;io.flamingock:flamingock-ce-bom:$flamingockVersion&quot;)) implementation(&quot;io.flamingock:flamingock-ce-sql-template&quot;)   ","version":"1.0.0","tagName":"h3"},{"title":"Step 2: define a Template-based change‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-2-define-a-template-based-change","content":" In Flamingock, a ChangeUnit represents a single unit of work that needs to be applied to your system ‚Äî for example, creating a table, updating a configuration, or setting up a cloud resource.  When using template-based changes, instead of implementing a code-based file to define the logic of the change, you describe the change in a declarative format (e.g., YAML file). The structure you use will depend on the template you‚Äôre leveraging.  Create a YAML file (e.g., _0001_create_persons_table.yaml) inside your application‚Äôs resources directory:  id: create-persons-table-from-template order: 1 templateName: sql-template templateConfiguration: executionSql: | CREATE TABLE Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) )   info Note that your application must provide a java.sql.Connection instance as a dependency to Flamingock.  üîç Understanding the configuration attributes‚Äã  id: Unique identifier for the change, used for tracking (same as in code-based changes).order: Execution order relative to other changes (also shared with code-based).templateName: Indicates which template should be used to handle the change logic. This is required for all template-based changes.templateConfiguration: Section where you define the input parameters for the selected template. These parameters vary depending on the template. In this example, the template expects an executionSql field. Other fields: Some templates may define additional, custom configuration fields (e.g., rollbackSql for SQL template).  Template-based changes provide both structure and flexibility. They share the core concepts of change tracking with code-based ChangeUnits, but introduce a flexible configuration model where each template defines its own behavior through external parameters.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 3: Configure Flamingock to use the template file‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-3-configure-flamingock-to-use-the-template-file","content":" To configure Flamingock to use the YAML template file, you need to define a stage that includes the path to the template file using the @EnableFlamingock annotation:  @EnableFlamingock( stages = { @Stage(location = &quot;src/main/resources/templates&quot;) } ) public class MainApplication { // Configuration class }   If you prefer to use a pipeline YAML file for configuration, refer to the Setup &amp; Stages guide for more details.  ","version":"1.0.0","tagName":"h3"},{"title":"Step 4: Run Flamingock‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#step-4-run-flamingock","content":" At application startup, Flamingock will automatically detect the YAML file and process it as a standard change, following the same execution flow as code-based changes.    ","version":"1.0.0","tagName":"h3"},{"title":"Use case: SQL database migration‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#use-case-sql-database-migration","content":" Let‚Äôs compare how an SQL migration is handled using a template-based ChangeUnit vs. a traditional code-based ChangeUnit.  ","version":"1.0.0","tagName":"h2"},{"title":"Approach 1: Using a Traditional Code-Based ChangeUnit‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#approach-1-using-a-traditional-code-based-changeunit","content":" @ChangeUnit(id = &quot;create-persons-table&quot;, order = 1, author = &quot;developer&quot;) public class CreatePersonsTableChangeUnit { private final DataSource dataSource; public CreatePersonsTableChangeUnit(DataSource dataSource) { this.dataSource = dataSource; } @Execution public void execute() throws SQLException { try (Connection connection = dataSource.getConnection(); Statement statement = connection.createStatement()) { statement.executeUpdate(&quot;&quot;&quot; CREATE TABLE Persons ( PersonID int PRIMARY KEY, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) ) &quot;&quot;&quot;); } } }   ","version":"1.0.0","tagName":"h3"},{"title":"Approach 2: Using a Flamingock SQL Template‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#approach-2-using-a-flamingock-sql-template","content":" With the SQL Template, users define the same migration in YAML instead of Java:  id: create-persons-table-from-template order: 1 templateName: sql-template templateConfiguration: executionSql: | CREATE TABLE Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) )   ","version":"1.0.0","tagName":"h3"},{"title":"Key Benefits of Using a Template Instead of Code-Based ChangeUnits:‚Äã","type":1,"pageTitle":"How to use Flamingock Templates","url":"/docs/templates/templates-how-to-use#key-benefits-of-using-a-template-instead-of-code-based-changeunits","content":" Less code maintenance: No need to write Java classes, inject DataSource, manage connections, or handle SQL execution manually.Faster onboarding: YAML is easier for non-Java developers.Standardised migrations: Ensures best practices and avoids custom implementation errors.Improved readability: Easier to review and version control. ","version":"1.0.0","tagName":"h3"},{"title":"Create your own Flamingock template","type":0,"sectionRef":"#","url":"/docs/templates/create-your-own-template","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#introduction","content":" Flamingock Templates allow you to encapsulate common logic and reduce boilerplate when defining change units. This document explains how to create your own templates for reuse across projects or for contribution to the Flamingock community.    ","version":"1.0.0","tagName":"h2"},{"title":"Overview of the required components‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#overview-of-the-required-components","content":" To create a template, you need:  A Java class extending AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt;An @Execution method to perform the main change(Optionally) A @RollbackExecution method for undo supportA service loader registration file (META-INF/services)(Optional) Package and distribute your template    ","version":"1.0.0","tagName":"h2"},{"title":"1. Implement the Template class‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#1-implement-the-template-class","content":" Extend AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt; with three generics:  SHARED_CONFIG: Shared configuration that applies to both execution and rollback (e.g., database connection, common settings). Use Void if no shared config is needed.EXECUTION: The type representing the execution logic/dataROLLBACK: The type representing the rollback logic/data  Example:  public class MongoChangeTemplate extends AbstractChangeTemplate&lt;Void, MongoOperation, MongoOperation&gt; { public MongoChangeTemplate() { super(MongoOperation.class); } @Execution public void execute(MongoDatabase db, @Nullable ClientSession clientSession) { if (this.isTransactional &amp;&amp; clientSession == null) { throw new IllegalArgumentException(String.format(&quot;Transactional changeUnit[%s] requires transactional ecosystem with ClientSession&quot;, changeId)); } executeOp(db, execution, clientSession); } @RollbackExecution public void rollback(MongoDatabase db, @Nullable ClientSession clientSession) { if (this.isTransactional &amp;&amp; clientSession == null) { throw new IllegalArgumentException(String.format(&quot;Transactional changeUnit[%s] requires transactional ecosystem with ClientSession&quot;, changeId)); } executeOp(db, rollback, clientSession); } private void executeOp(MongoDatabase db, MongoOperation op, ClientSession clientSession) { op.getOperator(db).apply(clientSession); } }   Important notes‚Äã  Access your execution and rollback data directly via this.execution and this.rollback fields.Access shared configuration via this.configuration field (if using a non-Void shared config type).If your template references custom types, make sure to register them for reflection‚Äîespecially for GraalVM native builds. When extending AbstractChangeTemplate, you can pass your custom types to the superclass constructor to ensure proper reflection support.  note See 2. Define Execution and Rollback methods section for how to implement the core logic inside your template class using the execution/rollback data and dependency injection    ","version":"1.0.0","tagName":"h2"},{"title":"2. Define Execution and Rollback methods‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#2-define-execution-and-rollback-methods","content":" Each template must include an @Execution method, and may optionally include a @RollbackExecution method. These methods define the core logic that will be executed when Flamingock runs the corresponding change.  Inside these methods, it‚Äôs expected that you use the data provided by the user in the template-based change unit through the following fields:  this.execution ‚Äî the execution logic/data to apply during executionthis.rollback ‚Äî the rollback logic/data to apply during rollback or undothis.configuration ‚Äî shared configuration data (if using a non-Void shared config type)  An example of a template for Kafka topic management:  info This is an illustrative example to demonstrate the template structure. Real Kafka templates would use different parameters and configuration structures based on actual requirements.  public class KafkaTopicTemplate extends AbstractChangeTemplate&lt;Void, TopicConfig, String&gt; { public KafkaTopicTemplate() { super(TopicConfig.class); } @Execution public void execute(AdminClient adminClient) throws Exception { // Create topic using the execution configuration NewTopic newTopic = new NewTopic( this.execution.getName(), this.execution.getPartitions(), this.execution.getReplicationFactor() ); newTopic.configs(this.execution.getConfigs()); adminClient.createTopics(List.of(newTopic)).all().get(); } @RollbackExecution public void rollback(AdminClient adminClient) throws Exception { // Delete topic using the rollback topic name adminClient.deleteTopics(List.of(this.rollback)).all().get(); } }   ","version":"1.0.0","tagName":"h2"},{"title":"Example with Shared Configuration‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#example-with-shared-configuration","content":" When you need to share configuration between execution and rollback (such as connection details, common settings, etc.), you can use a non-Void shared configuration type:  info This is an illustrative example to demonstrate the shared configuration pattern. Real S3 templates would use different parameters and configuration structures based on actual AWS SDK requirements.  public class S3BucketTemplate extends AbstractChangeTemplate&lt;S3ConnectionConfig, BucketCreationRequest, String&gt; { public S3BucketTemplate() { super(S3ConnectionConfig.class, BucketCreationRequest.class); } @Execution public void execute() { // Access shared configuration for AWS connection AmazonS3 s3Client = AmazonS3ClientBuilder.standard() .withRegion(this.configuration.getRegion()) .withCredentials(this.configuration.getCredentialsProvider()) .build(); // Create bucket using execution configuration CreateBucketRequest request = new CreateBucketRequest(this.execution.getBucketName()) .withCannedAcl(this.execution.getAcl()); if (this.execution.getEncryption() != null) { // Apply encryption settings request.withObjectLockEnabledForBucket(this.execution.getEncryption().isEnabled()); } s3Client.createBucket(request); } @RollbackExecution public void rollback() { // Use the same shared configuration for rollback AmazonS3 s3Client = AmazonS3ClientBuilder.standard() .withRegion(this.configuration.getRegion()) .withCredentials(this.configuration.getCredentialsProvider()) .build(); // Delete bucket using rollback bucket name s3Client.deleteBucket(this.rollback); } }   This pattern is useful when:  Both execution and rollback need the same configuration data (AWS credentials, region, etc.)You want to avoid duplicating connection details or common settingsThe template needs different data for execution vs rollback operations  ","version":"1.0.0","tagName":"h3"},{"title":"Injecting dependencies into Template methods‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#injecting-dependencies-into-template-methods","content":" Template methods (such as those annotated with @Execution and @RollbackExecution) support method-level dependency injection using the same mechanism as change units.  Template classes do not support constructor injection. All dependencies must be injected as parameters in the @Execution and @RollbackExecution methods.  You can inject any registered dependency as a method parameter:  @Execution public void execute(MongoDatabase db, ClientService clientService) { clientService.doSomething(); }   info Flamingock will apply lock-safety guards unless you annotate the parameter with @NonLockGuarded.  ","version":"1.0.0","tagName":"h3"},{"title":"Mapping between template-base changeUnit file and template methods‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#mapping-between-template-base-changeunit-file-and-template-methods","content":" For details on how Flamingock maps the execution and rollback sections in your declarative change unit to the methods in your template class, refer to the Template mapping documentation.    ","version":"1.0.0","tagName":"h3"},{"title":"3. Register the Template with ServiceLoader‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#3-register-the-template-with-serviceloader","content":" Templates are discovered automatically at runtime using Java‚Äôs ServiceLoader system.  Steps:  Create a file at:  src/main/resources/META-INF/services/io.flamingock.core.api.template.ChangeTemplate   List the fully qualified class names of all templates in the file:  io.flamingock.template.kafka.CreateTopicTemplate io.flamingock.template.kafka.UpdateTopicConfigTemplate io.flamingock.template.kafka.DeleteTopicTemplate   tip Group templates by domain or technology for better maintainability.    ","version":"1.0.0","tagName":"h2"},{"title":"4. Package and distribute the Template‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#4-package-and-distribute-the-template","content":" Depending on your target:  ","version":"1.0.0","tagName":"h2"},{"title":"Internal Templates (Private)‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#internal-templates-private","content":" No special packaging needed.Keep your template class inside your application.  ","version":"1.0.0","tagName":"h3"},{"title":"Public Templates (Contributing to the Community)‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#public-templates-contributing-to-the-community","content":" Package your template as a JAR.Notify the Flamingock team via development@flamingock.io or GitHub.Submit your template for validation.  Validation Requirements:‚Äã  Clear and justified use caseName must align and not conflict with existing templatesTechnically correct and production-grade implementationPublic classes must be Javadoc-documentedSubmit a Pull Request adding the template's documentation to flamingock.github.io    ","version":"1.0.0","tagName":"h3"},{"title":"‚úÖ Best Practices‚Äã","type":1,"pageTitle":"Create your own Flamingock template","url":"/docs/templates/create-your-own-template#-best-practices","content":" Use AbstractChangeTemplate&lt;SHARED_CONFIG, EXECUTION, ROLLBACK&gt; with the appropriate generic types for your use case.Always provide an @RollbackExecution method if rollback or undo is expected.Use Void for generics when that type is not needed (e.g., &lt;Void, String, String&gt; for simple SQL templates).Use shared configuration (&lt;ConfigType, Void, Void&gt;) when both execution and rollback need the same configuration data.Document your template's purpose and generic types clearly for users.Ensure all custom types are registered for reflection by passing them to the superclass constructor, especially when targeting native builds.Group multiple templates by domain when packaging a library.   ","version":"1.0.0","tagName":"h2"},{"title":"Templates","type":0,"sectionRef":"#","url":"/docs/templates/templates-introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#introduction","content":" Flamingock Templates are pre-built modules designed to streamline the integration of common third-party services, databases, and configurations into the Flamingock change management system. These templates provide a structured way to define configuration changes in declarative format (such as YAML files), reducing the need for custom code-based ChangeUnits while ensuring seamless execution and versioning of changes.  ","version":"1.0.0","tagName":"h2"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#how-it-works","content":" Flamingock Templates are designed to simplify change definitions by extracting reusable logic into modular building blocks. While Flamingock‚Äôs core approach relies on code-based ChangeUnits to manage database and system changes, Flamingock Templates provide a low-code alternative that simplifies the process for common integration scenarios. Instead of writing Java classes for each migration, users can leverage existing templates by defining changes in a declarative format(YAML, etc.).  ","version":"1.0.0","tagName":"h2"},{"title":"Who Provides Templates?‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#who-provides-templates","content":" Templates can be:  Provided by the Flamingock core team (e.g., SQL, Kafka, Redis)Offered by the communityCreated internally by teams to address common patterns in their own systems  This makes them highly adaptable: whether you're integrating a database, messaging system, or internal service, templates give you a low-code mechanism to structure your changes cleanly and consistently.  ","version":"1.0.0","tagName":"h3"},{"title":"Why Do Templates Exist?‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#why-do-templates-exist","content":" Templates exist to solve a common problem in traditional, code-based migrations: duplicated logic across ChangeUnits.  Instead of repeating the same boilerplate code over and over, templates let you externalize the logic into a reusable definition and parameterize what‚Äôs different.  ","version":"1.0.0","tagName":"h3"},{"title":"Key Features‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#key-features","content":" Pre-built, reusable modules: Each template provides a well-defined structure for managing migrations and configurations.Declarative ChangeUnits: Users define changes in YAML, avoiding Java boilerplate.Support for third-party integrations: Includes databases, messaging systems, and cloud configurations.Automatic execution and versioning: Templates are applied and tracked as part of Flamingock‚Äôs change management process.Built-in best practices: Ensures correctness and reliability for each integration.Extensible by the community: Developers can contribute new templates to expand Flamingock‚Äôs ecosystem.  ","version":"1.0.0","tagName":"h2"},{"title":"When to use Template-based ChangeUnits vs. code-based ChangeUnits‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#when-to-use-template-based-changeunits-vs-code-based-changeunits","content":" Use Case\tTemplate-Based ChangeUnit\tCode-Based ChangeUnitIntegration with third-party services (e.g., Kafka, Twilio)\t‚úÖ\t‚úÖ Simple database migrations (e.g., SQL schema updates)\t‚úÖ\t‚úÖ Custom logic and advanced migrations\t‚òëÔ∏è*\t‚úÖ Complex, dynamic change sequences\t‚òëÔ∏è**\t‚úÖ Low-code, configuration-driven changes\t‚úÖ\t‚ùå  ‚òëÔ∏è* Templates can handle custom logic if it can be abstracted and reused. Users can create custom templates to manage these scenarios.  ‚òëÔ∏è** While templates may support complex change sequences, full control and dynamic logic might be easier to implement in code when the scenario is highly specific or non-repetitive.  ","version":"1.0.0","tagName":"h2"},{"title":"List of current Flamingock templates‚Äã","type":1,"pageTitle":"Templates","url":"/docs/templates/templates-introduction#list-of-current-flamingock-templates","content":" Template Name\tDescriptionSQL Template\tEnables SQL-based migrations using YAML-defined ChangeUnits. Kafka Template (Upcoming)\tManages Kafka topics and configurations using YAML definitions. Twilio Template (Upcoming)\tSimplifies Twilio messaging configurations via YAML. Redis Template (Upcoming)\tAllows structured updates to Redis configurations.    Flamingock Templates unlock new possibilities for seamless application evolution. Whether you‚Äôre managing databases, configurations, or third-party services, templates simplify the process, ensuring faster, safer, and more standardised migrations.  tip Join the Flamingock community and start building your own templates today! üöÄ ","version":"1.0.0","tagName":"h2"},{"title":"Integration Testing","type":0,"sectionRef":"#","url":"/docs/testing/integration-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#introduction","content":" Integration tests ensure that Flamingock operates correctly in a real environment by executing changes against live systems ‚Äî such as databases, cloud APIs, or internal services.  These tests involve spinning up the actual backend system and running Flamingock end-to-end:  Change unit executionAudit log persistenceDistributed lock acquisition  Integration tests should be used to validate that the full pipeline behaves as expected ‚Äî from execution to rollback.    ","version":"1.0.0","tagName":"h2"},{"title":"Example: Creating an S3 bucket‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#example-creating-an-s3-bucket","content":" Suppose you have a change unit that creates an Amazon S3 bucket:  @Change(id = &quot;create-bucket&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;) public class _0001_CreateS3BucketChange { @Execution public void execute(S3Client s3Client) { s3Client.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } @RollbackExecution public void rollback(S3Client s3Client) { s3Client.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Integration test with Testcontainers‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#integration-test-with-testcontainers","content":" To test this change end-to-end, we will:  Spin up a MongoDB container to be used as Flamingock‚Äôs audit backendInject a real S3 client (mocked, localstack, or real AWS)Configure Flamingock and execute it  class IntegrationTest { static final MongoDBContainer mongoContainer = new MongoDBContainer(&quot;mongo:6.0&quot;); @BeforeAll static void initMongo() { mongoContainer.start(); } @AfterAll static void tearDown() { mongoContainer.stop(); } @Test void shouldExecuteChangeAgainstS3AndAuditToMongo() { S3Client s3Client = S3Client.builder() .region(Region.EU_WEST_1) .build(); MongoClient mongoClient = MongoClients.create(mongoContainer.getReplicaSetUrl()); Runner runner = Flamingock.builder() .addDependency(s3Client) .addDependency(mongoClient) .setProperty(&quot;mongodb.databaseName&quot;, &quot;test-db&quot;) .build(); runner.execute(); // ‚úÖ Verify the S3 bucket was created ListBucketsResponse buckets = s3Client.listBuckets(); boolean bucketExists = buckets.buckets().stream() .anyMatch(b -&gt; b.name().equals(&quot;flamingock-test-bucket&quot;)); assertTrue(bucketExists, &quot;Expected S3 bucket was not found&quot;); // ‚úÖ Verify the change was audited in MongoDB MongoDatabase db = mongoClient.getDatabase(&quot;test-db&quot;); MongoCollection&lt;Document&gt; auditCollection = db.getCollection(&quot;flamingockAuditLogs&quot;); Document document = new Document(&quot;changeId&quot;, &quot;create-bucket&quot;) .append(&quot;state&quot;,&quot;EXECUTED&quot;); Document auditEntry = auditCollection.find(document).first(); assertNotNull(auditEntry, &quot;Flamingock audit log entry was not found in MongoDB&quot;); } }     ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Integration Testing","url":"/docs/testing/integration-testing#-best-practices","content":" Use Testcontainers to spin up a real audit backend (e.g., MongoDB) ‚Äî this avoids the need for manual test setupRun Flamingock fully using .build().execute() ‚Äî don‚Äôt call internal methods manuallyClean up the backend between tests or isolate data with unique test identifiersValidate changes by checking the actual target system or using custom assertionsUse integration tests sparingly ‚Äî unit tests are faster and should cover most logic ","version":"1.0.0","tagName":"h2"},{"title":"Testing Flamingock","type":0,"sectionRef":"#","url":"/docs/testing/introduction","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#introduction","content":" This section provides guidance on how to test applications that use Flamingock, including strategies for validating your change logic, ensuring proper execution coordination, and maintaining audit and rollback guarantees.  Whether you are running Flamingock in a local development environment, as part of CI pipelines, or through framework integrations like Spring Boot, testing is a key part of ensuring consistency and reliability across deployments.  Flamingock is not limited to database systems ‚Äî it supports a wide range of targets (e.g., message brokers, file systems, APIs). Your testing strategy should reflect the behavior of the underlying systems you integrate with.    ","version":"1.0.0","tagName":"h2"},{"title":"What to test‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#what-to-test","content":" There are three primary levels at which Flamingock-related functionality can be tested:  ","version":"1.0.0","tagName":"h2"},{"title":"1. Unit test: Change logic‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#1-unit-test-change-logic","content":" Isolate and test the logic inside your @Execution and @RollbackExecution methods without involving Flamingock‚Äôs runtime or audit mechanism.  Use mocks for dependencies (e.g., MongoTemplate, DynamoDbClient, S3Client)Focus on business correctness and expected side effectsNo audit logs or locking are involved  üëâ See Unit testing your change units    ","version":"1.0.0","tagName":"h3"},{"title":"2. Integration test: Flamingock execution‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#2-integration-test-flamingock-execution","content":" Run Flamingock end-to-end in a controlled environment to verify:  Execution of the @Execution methodAudit log persistenceRollback behavior on failure  This usually requires a real or containerized backend system (e.g., using Testcontainers).  üëâ See Integration testing Flamingock    ","version":"1.0.0","tagName":"h3"},{"title":"3. Spring Boot integration‚Äã","type":1,"pageTitle":"Testing Flamingock","url":"/docs/testing/introduction#3-spring-boot-integration","content":" For applications using Spring Boot, test how Flamingock integrates with your app lifecycle:  Use @SpringBootTest to validate full configurationConfirm that changes run on startupOptionally inject mocks to verify execution paths  üëâ See Testing with Spring Boot ","version":"1.0.0","tagName":"h3"},{"title":"Unit Testing","type":0,"sectionRef":"#","url":"/docs/testing/unit-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#introduction","content":" Unit tests focus on verifying the internal logic of a single change unit, without relying on any external system. They are fast, isolated, and ideal for validating:  That the @Execution method performs the correct logicThat the @RollbackExecution method compensates properly on failureThat injected dependencies are used as expected (using mocks or fakes)  Unit tests are most useful when your change unit contains business logic, computation, validation, or decisions.    ","version":"1.0.0","tagName":"h2"},{"title":"Example: Creating an S3 bucket‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#example-creating-an-s3-bucket","content":" Suppose you have a change unit that creates an Amazon S3 bucket:  @Change(id = &quot;create-bucket&quot;, order = &quot;0001&quot;, author = &quot;dev-team&quot;) public class _0001_CreateS3BucketChange { @Execution public void execute(S3Client s3Client) { s3Client.createBucket(CreateBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } @RollbackExecution public void rollback(S3Client s3Client) { s3Client.deleteBucket(DeleteBucketRequest.builder() .bucket(&quot;flamingock-test-bucket&quot;) .build()); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Writing a unit test‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#writing-a-unit-test","content":" To unit test this class, we use JUnit and a mocking library (e.g., Mockito). We'll mock the S3Client and verify the correct calls were made.  class _0001_CreateS3BucketChangeTest { private final S3Client s3Client = mock(S3Client.class); private final CreateS3BucketChange change = new CreateS3BucketChange(); @Test void shouldCallCreateBucketOnExecution() { S3Client s3Client = mock(S3Client.class); new _0001_CreateS3BucketChange().execute(s3Client); verify(s3Client).createBucket(argThat(req -&gt; req.bucket().equals(&quot;flamingock-test-bucket&quot;))); } @Test void shouldCallDeleteBucketOnRollback() { S3Client s3Client = mock(S3Client.class); new _0001_CreateS3BucketChange().rollback(s3Client); verify(s3Client).deleteBucket(argThat(req -&gt; req.bucket().equals(&quot;flamingock-test-bucket&quot;))); } }     ","version":"1.0.0","tagName":"h2"},{"title":"‚úÖ Best practices‚Äã","type":1,"pageTitle":"Unit Testing","url":"/docs/testing/unit-testing#-best-practices","content":" Use mocks or fakes to isolate the dependencies used in your change unitFocus only on the logic inside the @Execution and @RollbackExecution methodsKeep assertions specific and minimal ‚Äî check that the right dependencies are calledAvoid testing Flamingock itself (e.g., locking or audit behavior ‚Äî that‚Äôs handled in integration tests)Use descriptive test names like shouldCallCreateBucketOnExecution() for readability ","version":"1.0.0","tagName":"h2"},{"title":"Spring Boot Testing","type":0,"sectionRef":"#","url":"/docs/testing/springboot-integration-testing","content":"","keywords":"","version":"1.0.0"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#introduction","content":" This guide explains how to write integration tests for Flamingock when using Spring Boot with the @EnableFlamingock annotation.  With this setup:  Flamingock is auto-configured using Spring Boot propertiesDependencies like Kafka AdminClient or DynamoDbClient must be declared as Spring beansThe change units are executed end-to-end using real systems (e.g., DynamoDB Local, Kafka, S3)  This test style is ideal for verifying that Flamingock interacts correctly with both its audit backend and any external systems.    ","version":"1.0.0","tagName":"h2"},{"title":"Example: Modifying a Kafka topic and auditing to DynamoDB‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#example-modifying-a-kafka-topic-and-auditing-to-dynamodb","content":" Suppose you have a change unit that modifies a Kafka topic configuration:  @Change(id = &quot;modify-topic-config&quot;, order = &quot;0002&quot;, author = &quot;dev-team&quot;) public class _0002_ModifyKafkaTopicConfig { @Execution public void execute(AdminClient adminClient) { Map&lt;ConfigResource, Config&gt; configs = Map.of( new ConfigResource(ConfigResource.Type.TOPIC, &quot;orders&quot;), new Config(List.of(new ConfigEntry(&quot;retention.ms&quot;, &quot;86400000&quot;))) ); adminClient.alterConfigs(configs).all().join(); } @RollbackExecution public void rollback(AdminClient adminClient) { Map&lt;ConfigResource, Config&gt; configs = Map.of( new ConfigResource(ConfigResource.Type.TOPIC, &quot;orders&quot;), new Config(List.of(new ConfigEntry(&quot;retention.ms&quot;, &quot;604800000&quot;))) ); adminClient.alterConfigs(configs).all().join(); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Writing the test‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#writing-the-test","content":" In this test, we‚Äôll:  Spin up Kafka and DynamoDB Local using TestcontainersProvide the required beans (AdminClient, DynamoDbClient) to Spring BootAssert that the Flamingock change unit executed and was audited to DynamoDB  info Flamingock requires DynamoDbClient and other injected services (like AdminClient) to be present in the Spring ApplicationContext. Spring Boot will auto-detect them if they are declared as @Beans.  @SpringBootTest @Testcontainers @EnableFlamingock( stages = { @Stage(location = &quot;com.yourapp.changes&quot;) } ) public class FlamingockSpringbootTest { static final KafkaContainer kafka = new KafkaContainer(DockerImageName.parse(&quot;confluentinc/cp-kafka:7.2.1&quot;)); static final GenericContainer&lt;?&gt; dynamoDb = new GenericContainer&lt;&gt;(&quot;amazon/dynamodb-local&quot;) .withExposedPorts(8000); @BeforeAll static void startContainers() { kafka.start(); dynamoDb.start(); } @AfterAll static void stopContainers() { kafka.stop(); dynamoDb.stop(); } @Bean public DynamoDbClient dynamoDbClient() { return DynamoDbClient.builder() .region(Region.US_EAST_1) .endpointOverride(URI.create(&quot;http://&quot; + dynamoDb.getHost() + &quot;:&quot; + dynamoDb.getFirstMappedPort())) .build(); } @Bean public AdminClient kafkaAdminClient() { Properties config = new Properties(); config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()); return AdminClient.create(config); } @Test void shouldExecuteChangeAndWriteAuditToDynamoDB() { DynamoDbClient client = dynamoDbClient(); ScanResponse scan = client.scan(ScanRequest.builder() .tableName(&quot;flamingockAuditLogs&quot;) .build()); boolean changeExecuted = scan.items().stream() .anyMatch(item -&gt; &quot;modify-topic-config&quot;.equals(item.get(&quot;changeId&quot;).s()) &amp;&amp; &quot;EXECUTED&quot;.equals(item.get(&quot;state&quot;).s())); assertTrue(changeExecuted, &quot;Audit log entry for executed change not found in DynamoDB&quot;); } }     ","version":"1.0.0","tagName":"h2"},{"title":"Advanced configuration‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#advanced-configuration","content":" Flamingock can be configured using Spring Boot properties, either in your application.yml or dynamically via @DynamicPropertySource.  This is especially useful for setting values like:  @DynamicPropertySource static void overrideProperties(DynamicPropertyRegistry registry) { String endpoint = &quot;http://&quot; + dynamoDb.getHost() + &quot;:&quot; + dynamoDb.getFirstMappedPort(); registry.add(&quot;flamingock.dynamodb.readCapacityUnits&quot;, () -&gt; 5L); registry.add(&quot;flamingock.dynamodb.writeCapacityUnits&quot;, () -&gt; 5L); registry.add(&quot;flamingock.dynamodb.autoCreate&quot;, () -&gt; true); registry.add(&quot;flamingock.dynamodb.auditRepositoryName&quot;, () -&gt; &quot;flamingockAuditLogs&quot;); registry.add(&quot;flamingock.dynamodb.lockRepositoryName&quot;, () -&gt; &quot;flamingockLocks&quot;); }   These properties allow Flamingock to connect to the appropriate DynamoDB instance and create its internal metadata tables automatically.    ","version":"1.0.0","tagName":"h2"},{"title":"Best practices‚Äã","type":1,"pageTitle":"Spring Boot Testing","url":"/docs/testing/springboot-integration-testing#best-practices","content":" Declare all required dependencies (like DynamoDbClient, AdminClient, etc.) as Spring beansUse @DynamicPropertySource to inject dynamic config for local/test environmentsValidate both the external effect (Kafka, S3, etc.) and the audit record in the backendUse Testcontainers for isolation and reproducibility across environmentsKeep tests focused: use Spring Boot only when testing real integration scenarios (not just logic) ","version":"1.0.0","tagName":"h2"}],"options":{"languages":["en"],"id":"default"}}